<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network Graph</title>
    <style>
        :root {
            --transition: 0.3s;
            --shadow-light: 0 2px 10px rgba(0, 0, 0, 0.1);
            --shadow-dark: 0 2px 10px rgba(0, 0, 0, 0.3);
            --border-light: #d1d5db;
            --border-dark: #4b5563;
        }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 0; display: flex; height: 100vh; font-size: 12px; transition: background-color var(--transition), color var(--transition); }
        body.light-mode { background-color: #f0f2f5; color: #1f2a44; }
        body.dark-mode { background-color: #1e293b; color: #e2e8f0; }
       

/* Controls container */
#controls {
    transition: width var(--transition);
    position: fixed;
    left: 0;
    top: 0;
    height: 100vh;
    z-index: 1000;
    display: flex;
    flex-direction: column;
    overflow-y: auto; /* Allow scrolling if content overflows */
}

#controls.collapsed {
    width: 50px;
}

#controls:not(.collapsed) {
    width: 300px;
}

/* Header area for buttons */
#controls-header {
    padding: 10px;
    display: flex;
    flex-direction: column;
    gap: 10px; /* Space between buttons */
}

/* Menu toggle button */
#menu-toggle {
  
    transition: transform var(--transition);
}



/* Top buttons - no absolute positioning */
#mode-toggle, #pause-toggle, #reset-layout {
    padding: 6px 12px;
    background-color: #6b7280;
    color: white;
    border: none;
    border-radius: 4px;
    font-size: 12px;
    cursor: pointer;
    transition: background-color var(--transition);
}

.light-mode #pause-toggle, .light-mode #reset-layout {
    background-color: #6b7280;
}

.dark-mode #pause-toggle, .dark-mode #reset-layout {
    background-color: #9ca3af;
}

#pause-toggle.paused {
    background-color: #ef4444;
}

/* Hide buttons when collapsed, except menu toggle */
#controls.collapsed #mode-toggle,
#controls.collapsed #pause-toggle,
#controls.collapsed #reset-layout,
#controls.collapsed .tab-buttons,
#controls.collapsed .tab-content,
#controls.collapsed #footer {
    display: none;
}

/* Tab buttons and content */
.tab-buttons {
    display: flex;
    flex-wrap: wrap;
    border-bottom: 1px solid var(--border-light);
    transition: border-color var(--transition);
    margin-top: 10px; /* Small margin after header */
}

.tab-content {
    padding: 15px;
    display: none;
    flex-grow: 1;
}

.tab-content.active {
    display: block;
}

/* Network margin */
#myNetwork {
    transition: margin-left var(--transition);
}

#controls.collapsed ~ #myNetwork {
    margin-left: 50px;
}

#controls:not(.collapsed) ~ #myNetwork {
    margin-left: 300px;
}

/* Media query for mobile */
@media (max-width: 768px) {
    #controls:not(.collapsed) {
        width: 100%;
    }
    
    #controls:not(.collapsed) ~ #myNetwork {
        margin-left: 0;
        display: none;
    }
    
    #controls.collapsed ~ #myNetwork {
        margin-left: 50px;
        display: block;
    }
}


/* Hide content when collapsed except for toggle button */
#controls.collapsed > *:not(#menu-toggle) {
    display: none;
}

/* Adjust button positions when expanded */
#controls:not(.collapsed) #mode-toggle {
    top: 50px;
}

#controls:not(.collapsed) #pause-toggle {
    top: 80px;
}

#controls:not(.collapsed) #reset-layout {
    top: 110px;
}

/* Media query for mobile */
@media (max-width: 768px) {
    #controls:not(.collapsed) {
        width: 100%;
    }
    
    #controls:not(.collapsed) ~ #myNetwork {
        margin-left: 0;
        display: none; /* Hide graph when menu is expanded on mobile */
    }
    
    #controls.collapsed ~ #myNetwork {
        margin-left: 50px;
        display: block;
    }
}
        #myNetwork { flex-grow: 1; height: 100%; border-radius: 0 8px 8px 0; box-shadow: var(--shadow-light); transition: background-color var(--transition); }
        .light-mode #myNetwork { background-color: #fff; }
        .dark-mode #myNetwork { background-color: #334155; box-shadow: var(--shadow-dark); }
        .tab-buttons { display: flex; flex-wrap: wrap; border-bottom: 1px solid var(--border-light); transition: border-color var(--transition); padding-top: 100px; }
        .dark-mode .tab-buttons { border-bottom: 1px solid var(--border-dark); }
        .tab-button { flex: 1 0 14.28%; padding: 10px; text-align: center; border: none; cursor: pointer; transition: background-color var(--transition), color var(--transition); font-size: 10px; }
        .light-mode .tab-button { background-color: #f9fafb; color: #1f2a44; }
        .dark-mode .tab-button { background-color: #374151; color: #e2e8f0; }
        .tab-button.active { font-weight: bold; }
        .light-mode .tab-button.active { background-color: #fff; border-bottom: 2px solid #3b82f6; }
        .dark-mode .tab-button.active { background-color: #2d3748; border-bottom: 2px solid #60a5fa; }
        .light-mode .tab-button:hover:not(.active) { background-color: #e5e7eb; }
        .dark-mode .tab-button:hover:not(.active) { background-color: #4b5563; }
        .tab-content { padding: 15px; display: none; flex-grow: 1; }
        .tab-content.active { display: block; }
        .input-group { margin: 15px 0; padding: 10px; border-radius: 6px; transition: background-color var(--transition); }
        .light-mode .input-group { background-color: #f9fafb; }
        .dark-mode .input-group { background-color: #374151; }
        .input-group h3 { margin: 0 0 8px 0; font-size: 14px; }
        .light-mode .input-group h3 { color: #1f2a44; }
        .dark-mode .input-group h3 { color: #e2e8f0; }
        input, select, textarea { margin: 4px 0; padding: 6px 10px; border-radius: 4px; font-size: 12px; transition: border-color var(--transition), background-color var(--transition), color var(--transition); width: 100%; box-sizing: border-box; }
        .light-mode input, .light-mode select, .light-mode textarea { border: 1px solid var(--border-light); background-color: #fff; color: #1f2a44; }
        .dark-mode input, .dark-mode select, .dark-mode textarea { border: 1px solid var(--border-dark); background-color: #4b5563; color: #e2e8f0; }
        textarea { height: 100px; resize: vertical; }
        button { padding: 6px 12px; border: none; border-radius: 4px; font-size: 12px; cursor: pointer; transition: background-color var(--transition), color var(--transition); width: 100%; margin: 4px 0; }
        .light-mode button { background-color: #3b82f6; color: white; }
        .dark-mode button { background-color: #60a5fa; color: #1e293b; }
        #mode-toggle { position: absolute; top: 10px; right: 10px; padding: 6px 12px; background-color: #6b7280; color: white; border: none; border-radius: 4px; font-size: 12px; cursor: pointer; }
        #pause-toggle { position: absolute; top: 40px; right: 10px; padding: 6px 12px; background-color: #6b7280; color: white; border: none; border-radius: 4px; font-size: 12px; cursor: pointer; transition: background-color var(--transition); }
        .light-mode #pause-toggle { background-color: #6b7280; }
        .dark-mode #pause-toggle { background-color: #9ca3af; }
        #pause-toggle.paused { background-color: #ef4444; }
        #reset-layout { position: absolute; top: 70px; right: 10px; padding: 6px 12px; background-color: #6b7280; color: white; border: none; border-radius: 4px; font-size: 12px; cursor: pointer; transition: background-color var(--transition); }
        .light-mode #reset-layout { background-color: #6b7280; }
        .dark-mode #reset-layout { background-color: #9ca3af; }
        #footer { text-align: center; padding: 10px; font-size: 10px; margin-top: auto; transition: color var(--transition); }
        .light-mode #footer { color: #6b7280; }
        .dark-mode #footer { color: #94a3b8; }
        #contextMenu { position: absolute; background-color: #fff; border: 1px solid #ccc; box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2); z-index: 1000; padding: 5px 0; }
        #contextMenu button { display: block; width: 100%; text-align: left; padding: 5px 10px; background: none; border: none; cursor: pointer; }
        #contextMenu button:hover { background-color: #f0f0f0; }
        .light-mode #contextMenu button { 
    color: #1f2a44 !important; 
}
.light-mode #contextMenu button:hover { 
    color: #1f2a44 !important; 
    background-color: #f0f0f0; 
}
        .dark-mode #contextMenu { background-color: #2d3748; border: 1px solid var(--border-dark); }
        .dark-mode #contextMenu button { color: #e2e8f0; }
        .dark-mode #contextMenu button:hover { background-color: #4b5563; }
        .checkbox-label { display: flex; align-items: center; margin: 4px 0; font-size: 12px; }
        .light-mode .checkbox-label { color: #1f2a44; }
        .dark-mode .checkbox-label { color: #e2e8f0; }
        input[type="checkbox"] { margin-right: 8px; width: auto; }
        #edgeContextMenu {
    position: absolute;
    background-color: #fff;
    border: 1px solid #ccc;
    box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2);
    z-index: 1000;
    padding: 5px 0;
}

#edgeContextMenu button {
    display: block;
    width: 100%;
    text-align: left;
    padding: 5px 10px;
    background: none;
    border: none;
    cursor: pointer;
}

#edgeContextMenu button:hover {
    background-color: #f0f0f0;
}

.light-mode #edgeContextMenu {
    background-color: #fff;
}

.light-mode #edgeContextMenu button {
    color: #1f2a44 !important;
}

.light-mode #edgeContextMenu button:hover {
    color: #1f2a44 !important;
    background-color: #f0f0f0;
}

.dark-mode #edgeContextMenu {
    background-color: #2d3748;
    border: 1px solid var(--border-dark);
}

.dark-mode #edgeContextMenu button {
    color: #e2e8f0;
}

.dark-mode #edgeContextMenu button:hover {
    background-color: #4b5563;
}
    </style>
    <script src="https://cdn.jsdelivr.net/npm/vis-network@9.1.9/dist/vis-network.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/toastify-js/1.12.0/toastify.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/toastify-js/1.12.0/toastify.min.css">
</head>
<body class="dark-mode">
    <div id="controls" class="collapsed">
        <button id="menu-toggle" onclick="toggleMenu()">></button>
        <button id="mode-toggle" onclick="toggleMode()">Switch to Light Mode</button>
        <button id="pause-toggle" onclick="togglePhysics()">Pause Physics</button>
        <button id="reset-layout" onclick="resetLayout()">Reset Layout</button>
        <div class="tab-buttons">
            <button class="tab-button active" onclick="showTab('object-management')">Object Management</button>
            <button class="tab-button" onclick="showTab('link-management')">Link Management</button>
            <button class="tab-button" onclick="showTab('import-export')">Import/Export</button>
            <button class="tab-button" onclick="showTab('api-keys')">API Keys</button>
            <button class="tab-button" onclick="showTab('enrichment')">Enrichment</button>
            <button class="tab-button" onclick="showTab('import-iocs')">Import IOCs</button>
            <button class="tab-button" onclick="showTab('layouts')">Layouts</button>
        </div>
        <div id="object-management" class="tab-content active">
            <div class="input-group">
                <h3>Add Entity</h3>
                <select id="addEntityType">
                    <option value="contact">Contact</option>
                    <option value="ip">IP Address</option>
                    <option value="domain">Domain</option>
                    <option value="organization">Organization</option>
                    <option value="port">Port</option>
                    <option value="wallet">Wallet</option>
                    <option value="bank">Bank Account</option>
                    <option value="technology">Technology</option>
                    <option value="device">Device</option>
                    <option value="malware">Malware</option>
                </select>
                <input type="text" id="addNameInput" placeholder="Name">
                <input type="email" id="addEmailInput" placeholder="Email (optional)">
                <input type="text" id="addIpInput" placeholder="IP Address" style="display: none;">
                <input type="text" id="addDomainInput" placeholder="Domain" style="display: none;">
                <input type="text" id="addOrgInput" placeholder="Organization Name" style="display: none;">
                <input type="text" id="addPortNumInput" placeholder="Port Number" style="display: none;">
                <select id="addPortType" style="display: none;">
                    <option value="TCP">TCP</option>
                    <option value="UDP">UDP</option>
                </select>
                <input type="text" id="addWalletAddressInput" placeholder="Wallet Address" style="display: none;">
                <input type="text" id="addAccountNumberInput" placeholder="Account Number" style="display: none;">
                <input type="text" id="addSortCodeInput" placeholder="Sort Code" style="display: none;">
                <input type="text" id="addTechNameInput" placeholder="Technology Name" style="display: none;">
                <input type="text" id="addTechVersionInput" placeholder="Version" style="display: none;">
                <select id="addDeviceCategory" style="display: none;">
                    <option value="Server">Server</option>
                    <option value="PC">PC</option>
                    <option value="Laptop">Laptop</option>
                    <option value="MAC">MAC</option>
                    <option value="SmartPhone">SmartPhone</option>
                    <option value="IOT">IOT</option>
                    <option value="Router">Router</option>
                    <option value="Switch">Switch</option>
                    <option value="Wireless Access Point">Wireless Access Point</option>
                    <option value="Other">Other</option>
                </select>
                <input type="text" id="addDeviceNameInput" placeholder="Device Name" style="display: none;">
                <input type="text" id="addMalwareNameInput" placeholder="Malware Name" style="display: none;">
                <select id="addMalwareType" style="display: none;">
                    <option value="Wiper">Wiper</option>
                    <option value="RAT">RAT</option>
                    <option value="Encryptor">Encryptor</option>
                    <option value="Stealer">Stealer</option>
                    <option value="Other">Other</option>
                </select>
                <button onclick="addNode()">Add Entity</button>
            </div>
            <div class="input-group">
                <h3>Edit Entity</h3>
                <select id="editNodeSelect" onchange="loadNodeForEdit()"></select>
                <select id="editEntityType" disabled>
                    <option value="contact">Contact</option>
                    <option value="ip">IP Address</option>
                    <option value="domain">Domain</option>
                    <option value="organization">Organization</option>
                    <option value="port">Port</option>
                    <option value="wallet">Wallet</option>
                    <option value="bank">Bank Account</option>
                    <option value="technology">Technology</option>
                    <option value="device">Device</option>
                    <option value="malware">Malware</option>
                </select>
                <input type="text" id="editNameInput" placeholder="Name">
                <input type="email" id="editEmailInput" placeholder="Email (optional)">
                <input type="text" id="editIpInput" placeholder="IP Address" style="display: none;">
                <input type="text" id="editDomainInput" placeholder="Domain" style="display: none;">
                <input type="text" id="editOrgInput" placeholder="Organization Name" style="display: none;">
                <input type="text" id="editPortNumInput" placeholder="Port Number" style="display: none;">
                <select id="editPortType" style="display: none;">
                    <option value="TCP">TCP</option>
                    <option value="UDP">UDP</option>
                </select>
                <input type="text" id="editWalletAddressInput" placeholder="Wallet Address" style="display: none;">
                <input type="text" id="editAccountNumberInput" placeholder="Account Number" style="display: none;">
                <input type="text" id="editSortCodeInput" placeholder="Sort Code" style="display: none;">
                <input type="text" id="editTechNameInput" placeholder="Technology Name" style="display: none;">
                <input type="text" id="editTechVersionInput" placeholder="Version" style="display: none;">
                <select id="editDeviceCategory" style="display: none;">
                    <option value="Server">Server</option>
                    <option value="PC">PC</option>
                    <option value="Laptop">Laptop</option>
                    <option value="MAC">MAC</option>
                    <option value="SmartPhone">SmartPhone</option>
                    <option value="IOT">IOT</option>
                    <option value="Router">Router</option>
                    <option value="Switch">Switch</option>
                    <option value="Wireless Access Point">Wireless Access Point</option>
                    <option value="Other">Other</option>
                </select>
                <input type="text" id="editDeviceNameInput" placeholder="Device Name" style="display: none;">
                <input type="text" id="editMalwareNameInput" placeholder="Malware Name" style="display: none;">
                <select id="editMalwareType" style="display: none;">
                    <option value="Wiper">Wiper</option>
                    <option value="RAT">RAT</option>
                    <option value="Encryptor">Encryptor</option>
                    <option value="Stealer">Stealer</option>
                    <option value="Other">Other</option>
                </select>
                <button onclick="editNode()">Save Changes</button>
            </div>
            <div class="input-group">
                <h3>Remove Entity</h3>
                <select id="removeNode"></select>
                <button onclick="removeNode()">Remove Entity</button>
            </div>
        </div>
        <div id="link-management" class="tab-content">
            <div class="input-group">
                <h3>Create Link</h3>
                <select id="fromNode"></select>
                <select id="toNode"></select>
                <input type="text" id="edgeLabel" placeholder="Link Label">
                <button onclick="addEdge()">Add Link</button>
            </div>
            <div class="input-group">
                <h3>Remove Link</h3>
                <select id="removeEdge"></select>
                <button onclick="removeEdge()">Remove Link</button>
            </div>
        </div>
        <div id="import-export" class="tab-content">
            <div class="input-group">
                <h3>Export/Import</h3>
                <button onclick="exportGraph()">Export to JSON</button>
                <input type="file" id="importFile" accept=".json">
                <button onclick="importGraph()">Import from JSON</button>
                <button onclick="clearGraph()">Clear Graph</button>
            </div>
        </div>
        <div id="api-keys" class="tab-content">
            <div class="input-group">
                <h3>IPINFO API Key</h3>
                <input type="text" id="ipinfoApiKey" placeholder="Enter IPinfo API Key">
                <label class="checkbox-label">
                    <input type="checkbox" id="storeIpinfoKey"> Store in local storage
                </label>
                <button onclick="saveIpinfoApiKey()">Save IPinfo API Key</button>
            </div>
            <div class="input-group">
                <h3>Shodan API Key</h3>
                <input type="text" id="shodanApiKey" placeholder="Enter Shodan API Key">
                <label class="checkbox-label">
                    <input type="checkbox" id="storeShodanKey"> Store in local storage
                </label>
                <button onclick="saveShodanApiKey()">Save Shodan API Key</button>
            </div>
            <div class="input-group">
                <h3>CORS Proxy URL</h3>
                <input type="text" id="corsProxyUrl" placeholder="Enter CORS Proxy URL" value="https://cors-anywhere.herokuapp.com/">
                <label class="checkbox-label">
                    <input type="checkbox" id="storeCorsProxy" checked> Store in local storage
                </label>
                <button onclick="saveCorsProxyUrl()">Save CORS Proxy URL</button>
            </div>
        </div>
        <div id="enrichment" class="tab-content">
            <div class="input-group">
                <h3>Bulk Enrichment</h3>
                <button onclick="enrichAllIpinfo()">Enrich All IPs with IPinfo</button>
                <button onclick="enrichAllShodan()">Enrich All IPs with Shodan</button>
                <button onclick="enrichAllInternetDB()">Enrich All IPs with InternetDB</button>
                <button onclick="enrichAllGoogleDNS()">Enrich All Domains with Google DNS</button>
            </div>
        </div>
        <div id="import-iocs" class="tab-content">
            <div class="input-group">
                <h3>Import IOCs</h3>
                <textarea id="iocText" placeholder="Paste IOC text here (IPs, domains)"></textarea>
                <button onclick="importIOCsFromText()">Import from Text</button>
                <input type="file" id="iocFile" accept=".txt">
                <button onclick="importIOCsFromFile()">Import from File</button>
            </div>
        </div>
        <div id="layouts" class="tab-content">
            <div class="input-group">
                <h3>Graph Layouts</h3>
                <!-- Existing layout buttons remain here -->
                <button onclick="setOrganicLayout()">Organic</button>
                <button onclick="setCircularLayout()">Circular</button>
                <button onclick="setOrthogonalLayout()">Orthogonal</button>
                <button onclick="setTreeLayout()">Tree</button>
                <button onclick="setHierarchicalLayout()">Hierarchical</button>
            </div>
            <!-- New section for label visibility -->
            <div class="input-group">
                <h3>Label Visibility</h3>
                <label class="checkbox-label">
                    <input type="checkbox" id="showNodeLabels" checked onchange="toggleNodeLabels()">
                    Show Node Labels
                </label>
                <label class="checkbox-label">
                    <input type="checkbox" id="showEdgeLabels" checked onchange="toggleEdgeLabels()">
                    Show Edge Labels
                </label>
                <label class="checkbox-label">
                    <input type="checkbox" id="hideIsolatedNodes" onchange="toggleIsolatedNodes()">
                    Hide Nodes Without Links
                </label>
            </div>
        </div>
         <!-- Buy Me a Coffee Button -->
         <div style="text-align: center; padding: 10px;">
            <script type="text/javascript" src="https://cdnjs.buymeacoffee.com/1.0.0/button.prod.min.js" 
                data-name="bmc-button" 
                data-slug="mrr3b00t" 
                data-color="#FFDD00" 
                data-emoji=""  
                data-font="Cookie" 
                data-text="Buy me a coffee" 
                data-outline-color="#000000" 
                data-font-color="#000000" 
                data-coffee-color="#ffffff">
            </script>
        </div>
        <div id="footer">
            Â© Xservus Limited - v0.2
        </div>
    </div>
    <div id="myNetwork"></div>
    <div id="contextMenu" style="display: none;"></div>
    <div id="edgeContextMenu" style="display: none;"></div>

    <script>
        let nodes = new vis.DataSet([]);
        let edges = new vis.DataSet([]);
        let nextId = 1;
        let isDarkMode = true;
        let ipinfoApiKey = '';
        let shodanApiKey = '';
        let corsProxyUrl = 'https://cors-anywhere.herokuapp.com/'; // Default value
        let isPhysicsPaused = false;
        let lastRequestTime = 0;
        const RATE_LIMIT_MS = 500;

        const ipRegex = { ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/, ipv6: /^([0-9a-fA-F]{0,4}:){7}[0-9a-fA-F]{0,4}$/ };
        const domainRegex = /^(?!:\/\/)([a-zA-Z0-9-_]+\.)*[a-zA-Z0-9][a-zA-Z0-9-_]+\.[a-zA-Z]{2,}$/;

        let selectedNodes = new Set(); // To track multiple selected nodes

        function toggleMenu() {
    const controls = document.getElementById('controls');
    controls.classList.toggle('collapsed');
    
    // Optional: You could also dynamically change the symbol
    const toggleButton = document.getElementById('menu-toggle');
    toggleButton.textContent = controls.classList.contains('collapsed') ? '>' : '<';
    
    setTimeout(() => {
        network.fit({
            animation: {
                duration: 300,
                easingFunction: 'easeInOutQuad'
            }
        });
    }, 300);
}



function saveState() {
    const state = {
        nodes: nodes.get(),
        edges: edges.get(),
        nextId: nextId,
        isDarkMode: isDarkMode,
        isPhysicsPaused: isPhysicsPaused
    };
    localStorage.setItem('networkGraphState', JSON.stringify(state));
}



// Function to trigger save after key operations
function saveStateAfterOperation() {
    saveState();
    showToast('Progress saved', 'success');
}

window.onload = function() {
    // Load API keys from localStorage
    const storedIpinfoKey = localStorage.getItem('ipinfoApiKey');
    if (storedIpinfoKey) {
        ipinfoApiKey = storedIpinfoKey;
        document.getElementById('ipinfoApiKey').value = storedIpinfoKey;
        document.getElementById('storeIpinfoKey').checked = true;
    }
    const storedShodanKey = localStorage.getItem('shodanApiKey');
    if (storedShodanKey) {
        shodanApiKey = storedShodanKey;
        document.getElementById('shodanApiKey').value = storedShodanKey;
        document.getElementById('storeShodanKey').checked = true;
    }
    const storedCorsProxy = localStorage.getItem('corsProxyUrl');
            if (storedCorsProxy) {
                corsProxyUrl = storedCorsProxy;
                document.getElementById('corsProxyUrl').value = storedCorsProxy;
                document.getElementById('storeCorsProxy').checked = true;
            } else {
                // Set default value if not in localStorage
                document.getElementById('corsProxyUrl').value = corsProxyUrl;
            }
    // Load saved state
    const stateLoaded = loadState();

    // If no state was loaded, apply defaults
    if (!stateLoaded) {
        console.log('No saved state found or loading failed, applying defaults');
        updateTheme();
        ensureInteractionSettings();
    }

    // Update UI elements regardless of state
    updateSelectOptions();

    // Handle mobile layout
    if (window.innerWidth <= 768) {
        document.getElementById('controls').classList.add('collapsed');
    }

    // Stabilize network after everything is set up
    stabilizeNetwork();

    // Start periodic saving
    setInterval(saveState, 5 * 60 * 1000); // Save every 5 minutes
};

// Improve the loadState function with better error handling and logging
function loadState() {
    const savedState = localStorage.getItem('networkGraphState');
    if (!savedState) {
        console.log('No saved state found in localStorage');
        return false;
    }

    try {
        console.log('Loading saved state...');
        const state = JSON.parse(savedState);
        
        // Validate state object
        if (!state.nodes || !state.edges) {
            console.error('Invalid state format: missing nodes or edges');
            return false;
        }

        // Clear existing data
        nodes.clear();
        edges.clear();
        
        // Load nodes with error checking
        state.nodes.forEach(node => {
            if (!node.id || !node.type) {
                console.warn('Skipping invalid node:', node);
                return;
            }
            nodes.add(node);
        });
        
        // Load edges with error checking
        state.edges.forEach(edge => {
            if (!edge.from || !edge.to) {
                console.warn('Skipping invalid edge:', edge);
                return;
            }
            edges.add(edge);
        });
        
        // Set other state properties
        nextId = state.nextId || 1;
        isDarkMode = state.isDarkMode !== undefined ? state.isDarkMode : true;
        isPhysicsPaused = state.isPhysicsPaused || false;
        
        // Apply UI updates
        updateTheme();
        const pauseButton = document.getElementById('pause-toggle');
        pauseButton.textContent = isPhysicsPaused ? 'Resume Physics' : 'Pause Physics';
        pauseButton.classList.toggle('paused', isPhysicsPaused);
        network.setOptions({ physics: { enabled: !isPhysicsPaused } });
        ensureInteractionSettings();
        
        console.log('State loaded successfully:', {
            nodes: nodes.length,
            edges: edges.length,
            nextId: nextId,
            isDarkMode: isDarkMode,
            isPhysicsPaused: isPhysicsPaused
        });
        
        return true;
    } catch (e) {
        console.error('Error loading state:', e);
        showToast('Failed to load saved state: ' + e.message, 'error');
        localStorage.removeItem('networkGraphState'); // Clear corrupt state
        return false;
    }
}
        function showToast(message, type = 'info') {
            const toastOptions = {
                text: message,
                duration: 6500,
                position: "center",
                style: {
                    background: isDarkMode ? '#2d3748' : '#fff',
                    color: isDarkMode ? '#e2e8f0' : '#1f2a44',
                    border: `1px solid ${isDarkMode ? '#4b5563' : '#d1d5db'}`,
                    boxShadow: isDarkMode ? '0 2px 10px rgba(0, 0, 0, 0.3)' : '0 2px 10px rgba(0, 0, 0, 0.1)',
                    position: 'fixed',
                    top: '50px',
                    left: '50%',
                    transform: 'translateX(-50%)',
                    width: 'auto',
                    maxWidth: '80%',
                    zIndex: 1000
                }
            };
            switch (type) {
                case 'success': toastOptions.style.background = isDarkMode ? '#166534' : '#22c55e'; toastOptions.style.color = '#fff'; break;
                case 'error': toastOptions.style.background = isDarkMode ? '#991b1b' : '#ef4444'; toastOptions.style.color = '#fff'; break;
            }
            Toastify(toastOptions).showToast();
        }

        function throttleRequest(fn) {
            return async function(...args) {
                const now = Date.now();
                const timeSinceLast = now - lastRequestTime;
                if (timeSinceLast < RATE_LIMIT_MS) await new Promise(resolve => setTimeout(resolve, RATE_LIMIT_MS - timeSinceLast));
                lastRequestTime = now;
                return fn(...args);
            };
        }

        const baseInteractionOptions = {
    dragView: true,
    zoomView: true,
    dragNodes: true,
    zoomSpeed: 0.5,
    navigationButtons: false,
    multiselect: true, // Changed from false to true
    hover: true
};

        let container = document.getElementById('myNetwork');
        let data = { nodes: nodes, edges: edges };
        let options = {
    nodes: {
        shape: 'dot',  // Changed from 'circle' to 'dot' for consistent sizing
        size: 20,      // Base size for all nodes
        font: { 
            size: 12, 
            color: '#e2e8f0', 
            multi: true 
        },
        scaling: {
            min: 10,
            max: 70
        },
        // Add these to prevent label influence
        fixed: {
            x: false,
            y: false
        },
        shapeProperties: {
            useBorderWithImage: false
        },
        color: {
            hover: {
                border: '#60a5fa',
                background: '#4b5563'
            },
            highlight: {
                border: '#60a5fa',
                background: '#4b5563'
            }
        }
    },
    edges: { 
        arrows: { to: { enabled: true, scaleFactor: 0.5 } }, 
        font: { size: 12, color: '#e2e8f0' },
        smooth: true,
        width: 1
    },
    physics: { 
        enabled: true,
        stabilization: {
            enabled: true,
            iterations: 100,
            updateInterval: 25
        },
        barnesHut: { 
            gravitationalConstant: -8000,
            centralGravity: 0.1,
            springLength: 200,
            springConstant: 0.04,
            damping: 0.9,
            avoidOverlap: 0.5
        },
        maxVelocity: 25,
        minVelocity: 0.1,
        solver: 'barnesHut'
    },
    interaction: { ...baseInteractionOptions },
    layout: { improvedLayout: true }
};
        
        let network = new vis.Network(container, data, options);

        network.on('selectNode', function(params) {
    selectedNodes = new Set(params.nodes); // Update selected nodes
});

network.on('deselectNode', function(params) {
    selectedNodes = new Set(params.nodes); // Update when deselected
});




        function ensureInteractionSettings() {
    network.setOptions({
        interaction: { ...baseInteractionOptions },
        physics: {
            enabled: !isPhysicsPaused,
            stabilization: { enabled: false },
            barnesHut: {
                gravitationalConstant: -8000,
                centralGravity: 0.1,
                springLength: 200,
                springConstant: 0.04,
                damping: 0.9,
                avoidOverlap: 0.5
            },
            maxVelocity: 25,
            minVelocity: 0.1
        }
    });
}

function stabilizeNetwork(skipFit = false) {
    return new Promise(resolve => {
        network.setOptions({
            physics: {
                enabled: true,
                stabilization: {
                    enabled: true,
                    iterations: 200,
                    updateInterval: 50
                },
                barnesHut: {
                    gravitationalConstant: -8000,
                    centralGravity: 0.3,
                    springLength: 150,
                    avoidOverlap: 1.0,
                    damping: 0.9    // Added higher damping
                }
            }
        });

        network.stabilize(200);
        network.once('stabilizationIterationsDone', () => {
            // Automatically pause physics after stabilization
            isPhysicsPaused = true;
            network.setOptions({
                physics: {
                    enabled: false,  // Changed to false after stabilization
                    stabilization: { enabled: false },
                    barnesHut: {
                        gravitationalConstant: -8000,
                        centralGravity: 0.3,
                        springLength: 150,
                        avoidOverlap: 1.0,
                        damping: 0.9
                    },
                    minVelocity: 0.1,
                    maxVelocity: 25
                }
            });

            // Update pause button UI
            const pauseButton = document.getElementById('pause-toggle');
            pauseButton.textContent = 'Resume Physics';
            pauseButton.classList.add('paused');

            if (!skipFit) {
                network.fit({
                    animation: {
                        duration: 500,
                        easingFunction: 'easeInOutQuad'
                    }
                });
            }

            setTimeout(() => {
                const boundingBox = network.getBoundingBox();
                if (boundingBox && nodes.length > 0) {
                    const margin = 50;
                    nodes.forEach(node => {
                        const { x, y } = network.getPositions([node.id])[node.id] || { x: 0, y: 0 };
                        nodes.update({
                            id: node.id,
                            x: Math.max(boundingBox.left + margin, Math.min(boundingBox.right - margin, x)),
                            y: Math.max(boundingBox.top + margin, Math.min(boundingBox.bottom - margin, y))
                        });
                    });
                }
                resolve();
            }, skipFit ? 0 : 550);
        });
    });
}


       

        network.on('init', function() {
            container.addEventListener('wheel', function(event) {
                event.preventDefault();
                const scale = event.deltaY > 0 ? 0.9 : 1.1;
                const currentScale = network.getScale();
                network.moveTo({
                    scale: currentScale * scale,
                    animation: { duration: 100 }
                });
            }, { passive: false });
        });

        network.on('oncontext', function(params) {
    params.event.preventDefault();
    const nodeId = this.getNodeAt(params.pointer.DOM);
    const edgeId = this.getEdgeAt(params.pointer.DOM);

    if (nodeId && !selectedNodes.has(nodeId)) {
        selectedNodes.add(nodeId);
        this.selectNodes([...selectedNodes]); // Update visual selection
    }

     // If there are selected nodes, show context menu for them
     if (selectedNodes.size > 0) {
        const firstNode = nodes.get([...selectedNodes][0]);
        let value;
        switch (firstNode.type) {
            case 'ip': value = firstNode.ip; break;
            case 'domain': value = firstNode.domain; break;
            default: value = firstNode.label;
        }
        showContextMenu(params.pointer.DOM.x, params.pointer.DOM.y, value, [...selectedNodes], firstNode.type);
    } else if (edgeId) {
        showEdgeContextMenu(params.pointer.DOM.x, params.pointer.DOM.y, edgeId);
    }
    
    if (nodeId) {
        const node = nodes.get(nodeId);
        let value;
        switch (node.type) {
            case 'ip': value = node.ip; break;
            case 'domain': value = node.domain; break;
            default: value = node.label;
        }
        showContextMenu(params.pointer.DOM.x, params.pointer.DOM.y, value, nodeId, node.type);
    } else if (edgeId) {
        showEdgeContextMenu(params.pointer.DOM.x, params.pointer.DOM.y, edgeId);
    }
});

// Add click event handler for nodes
network.on('click', function(params) {
    if (params.nodes.length > 0) {
        const nodeId = params.nodes[0];
        const node = nodes.get(nodeId);
        
        // Determine the primary value based on node type
        let valueToCopy;
        switch (node.type) {
            case 'ip':
                valueToCopy = node.ip;
                break;
            case 'domain':
                valueToCopy = node.domain;
                break;
            case 'contact':
                valueToCopy = node.email || node.name;
                break;
            case 'organization':
                valueToCopy = node.organization;
                break;
            case 'port':
                valueToCopy = `${node.portType}/${node.portNumber}`;
                break;
            case 'wallet':
                valueToCopy = node.address;
                break;
            case 'bank':
                valueToCopy = node.accountNumber;
                break;
            case 'technology':
                valueToCopy = node.techName;
                break;
            case 'device':
                valueToCopy = node.deviceName;
                break;
            case 'malware':
                valueToCopy = node.malwareName;
                break;
            default:
                valueToCopy = node.label.split('\n')[0]; // Fallback to first line of label
        }

        if (valueToCopy) {
            // Copy to clipboard
            navigator.clipboard.writeText(valueToCopy)
                .then(() => {
                    showToast(`Copied "${valueToCopy}" to clipboard`, 'success');
                })
                .catch(err => {
                    showToast(`Failed to copy: ${err.message}`, 'error');
                });
        }
    }
});

function showEdgeContextMenu(x, y, edgeId) {
    const menu = document.getElementById('edgeContextMenu');
    const edge = edges.get(edgeId);
    if (!edge) return;
    
    const menuHtml = `
        <button onclick="editEdgeLabel('${edgeId}')">Edit Label</button>
        <button onclick="removeEdgeDirect('${edgeId}')">Delete Edge</button>
    `;
    
    menu.innerHTML = menuHtml;
    const canvasOffset = container.getBoundingClientRect();
    menu.style.left = `${x + canvasOffset.left}px`;
    menu.style.top = `${y + canvasOffset.top}px`;
    menu.style.display = 'block';
    document.addEventListener('click', hideEdgeContextMenu);
}

function hideEdgeContextMenu() {
    document.getElementById('edgeContextMenu').style.display = 'none';
    document.removeEventListener('click', hideEdgeContextMenu);
}

function editEdgeLabel(edgeId) {
    const edge = edges.get(edgeId);
    if (!edge) {
        showToast('Edge not found', 'error');
        return;
    }
    
    const currentLabel = edge.label || '';
    const newLabel = prompt('Enter new edge label (leave empty to remove):', currentLabel);
    
    if (newLabel !== null) { // null means user cancelled
        edges.update({
            id: edgeId,
            label: newLabel.trim() === '' ? undefined : newLabel.trim()
        });
        updateEdgeSelectOptions();
        stabilizeNetwork();
        saveStateAfterOperation();
        showToast('Edge label updated', 'success');
    }
    
    hideEdgeContextMenu();
}

function removeEdgeDirect(edgeId) {
    const edge = edges.get(edgeId);
    if (!edge) {
        showToast('Edge not found', 'error');
        return;
    }
    
    edges.remove({ id: edgeId });
    updateNodeSizes();
    updateEdgeSelectOptions();
    stabilizeNetwork();
    saveStateAfterOperation();
    showToast('Edge removed', 'success');
    hideEdgeContextMenu();
}

function showContextMenu(x, y, value, nodeIds, type) {
    const menu = document.getElementById('contextMenu');
    const isMultiple = nodeIds.length > 1;
    
    let menuHtml = `
        <button onclick="deleteNodes([${nodeIds}])">Delete ${isMultiple ? 'Selected Nodes' : 'Node'}</button>
        ${isMultiple ? '' : `<button onclick="startLinkCreation(${nodeIds[0]})">Create Link From Here</button>`}
    `;
    
    // Add type-specific options (only for single selection or all same type)
    const allSameType = nodeIds.every(id => nodes.get(id).type === type);
    if (allSameType) {
        if (type === 'ip') {
            menuHtml += `
                <button onclick="throttledEnrichIPMultiple([${nodeIds.map(id => `'${nodes.get(id).ip}'`)}], [${nodeIds}])">Enrich via IPINFO</button>
                <button onclick="throttledEnrichShodanMultiple([${nodeIds.map(id => `'${nodes.get(id).ip}'`)}], [${nodeIds}])">Enrich via Shodan</button>
                <button onclick="throttledEnrichInternetDBMultiple([${nodeIds.map(id => `'${nodes.get(id).ip}'`)}], [${nodeIds}])">Enrich via InternetDB</button>
                <button onclick="throttledSendHttpsRequestMultiple([${nodeIds.map(id => `'${nodes.get(id).ip}'`)}], 'ip', 'https')">Send HTTPS Request</button>
                <button onclick="throttledSendHttpsRequestMultiple([${nodeIds.map(id => `'${nodes.get(id).ip}'`)}], 'ip', 'http')">Send HTTP Request</button>
            `;
        } else if (type === 'domain') {
            menuHtml += `
                <button onclick="throttledEnrichGoogleDNSMultiple([${nodeIds.map(id => `'${nodes.get(id).domain}'`)}], [${nodeIds}])">Enrich via Google DNS</button>
                <button onclick="throttledSendHttpsRequestMultiple([${nodeIds.map(id => `'${nodes.get(id).domain}'`)}], 'domain', 'https')">Send HTTPS Request</button>
                <button onclick="throttledSendHttpsRequestMultiple([${nodeIds.map(id => `'${nodes.get(id).domain}'`)}], 'domain', 'http')">Send HTTP Request</button>
            `;
        }
    }

    menu.innerHTML = menuHtml;
    const canvasOffset = container.getBoundingClientRect();
    menu.style.left = `${x + canvasOffset.left}px`;
    menu.style.top = `${y + canvasOffset.top}px`;
    menu.style.display = 'block';
    document.addEventListener('click', hideContextMenu);
}

let linkFromNode = null;

function startLinkCreation(nodeId) {
    linkFromNode = nodeId;
    hideContextMenu();
    showToast('Select another node to create a link (right-click to cancel)', 'info');
    
    // Add temporary visual feedback
    nodes.update({
        id: nodeId,
        color: { border: '#22c55e', background: nodes.get(nodeId).color.background }
    });
    
    // Add one-time event listener for next node selection
    network.once('oncontext', handleLinkDestination);
    network.once('click', cancelLinkCreation);
}

function handleLinkDestination(params) {
    params.event.preventDefault();
    const nodeId = network.getNodeAt(params.pointer.DOM);
    
    if (!nodeId || nodeId === linkFromNode) {
        cancelLinkCreation();
        return;
    }
    
    // Create the edge
    const edgeId = `edge_${linkFromNode}_${nodeId}_${Date.now()}`;
    if (!edges.get({ filter: e => e.from === linkFromNode && e.to === nodeId }).length) {
        edges.add({
            id: edgeId,
            from: linkFromNode,
            to: nodeId,
            label: 'Connected' // Default label, could be made configurable
        });
        
        updateNodeSizes();
        updateEdgeSelectOptions();
        stabilizeNetwork();
        saveStateAfterOperation();
        showToast(`Link created between nodes`, 'success');
    } else {
        showToast('Link already exists between these nodes', 'error');
    }
    
    // Reset visual feedback
    const originalNode = nodes.get(linkFromNode);
    nodes.update({
        id: linkFromNode,
        color: { border: isDarkMode ? '#94a3b8' : '#6b7280', background: originalNode.color.background }
    });
    
    linkFromNode = null;
}

function cancelLinkCreation() {
    if (linkFromNode) {
        // Reset visual feedback
        const originalNode = nodes.get(linkFromNode);
        nodes.update({
            id: linkFromNode,
            color: { border: isDarkMode ? '#94a3b8' : '#6b7280', background: originalNode.color.background }
        });
        
        showToast('Link creation cancelled', 'info');
        linkFromNode = null;
        
        // Remove temporary listeners
        network.off('oncontext', handleLinkDestination);
        network.off('click', cancelLinkCreation);
    }
}

function deleteNode(nodeId) {
            const node = nodes.get(nodeId);
            if (!node) {
                showToast('Node not found', 'error');
                return;
            }

            // Remove all edges connected to this node
            const connectedEdges = edges.get({
                filter: edge => edge.from === nodeId || edge.to === nodeId
            });
            edges.remove(connectedEdges.map(edge => edge.id));

            // Remove the node
            nodes.remove({ id: nodeId });

            // Update UI and network
            updateSelectOptions();
            updateNodeSizes();
            stabilizeNetwork();
            saveStateAfterOperation();
            showToast(`Node "${node.label.split('\n')[0]}" deleted`, 'success');
        }

        function hideContextMenu() {
            document.getElementById('contextMenu').style.display = 'none';
            document.removeEventListener('click', hideContextMenu);
        }

        const throttledSendHttpsRequest = throttleRequest(async function sendHttpsRequest(target, type) {
            network.setOptions({ physics: { enabled: false } });
            let url = `${corsProxyUrl}/https://${target}`;
            let message;

            try {
                const response = await fetch(url, {
                    method: 'GET',
                    headers: {
                        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                        'Origin': window.location.origin
                    },
                    mode: 'cors',
                    credentials: 'omit'
                });

                const status = response.status;
                const statusText = response.statusText;
                const headers = {};
                response.headers.forEach((value, key) => {
                    headers[key] = value;
                });

                let body = '';
                const contentType = headers['content-type'] || '';
                if (contentType.includes('text') || contentType.includes('html') || contentType.includes('json')) {
                    body = await response.text();
                    if (body.length > 500) {
                        body = body.substring(0, 500) + '... (truncated)';
                    }
                } else {
                    body = '(Binary or unsupported content type)';
                }

                message = `
                    HTTPS Request to https://${target}
                    Status: ${status} ${statusText}
                    Headers: ${JSON.stringify(headers, null, 2)}
                    Body: ${body}
                `.trim();
                showToast(message, 'success');
            } catch (error) {
                message = `
                    HTTPS Request to https://${target}
                    Error: ${error.message}
                    Note: Ensure the CORS proxy (${corsProxyUrl}) is active and correctly configured
                `.trim();
                showToast(message, 'error');
            } finally {
                await stabilizeNetwork();
            }
        });

        function saveCorsProxyUrl() {
            corsProxyUrl = document.getElementById('corsProxyUrl').value.trim();
            const storeProxy = document.getElementById('storeCorsProxy').checked;
            if (corsProxyUrl) {
                if (storeProxy) {
                    localStorage.setItem('corsProxyUrl', corsProxyUrl);
                    showToast('CORS Proxy URL saved successfully!', 'success');
                } else {
                    localStorage.removeItem('corsProxyUrl');
                    showToast('CORS Proxy URL set for this session only', 'success');
                }
            } else {
                corsProxyUrl = 'https://cors-anywhere.herokuapp.com/'; // Reset to default if empty
                localStorage.removeItem('corsProxyUrl');
                document.getElementById('corsProxyUrl').value = corsProxyUrl;
                showToast('CORS Proxy URL reset to default', 'info');
            }
        }

        function throttleRequest(fn) {
            return async function(...args) {
                const now = Date.now();
                const timeSinceLast = now - lastRequestTime;
                if (timeSinceLast < RATE_LIMIT_MS) await new Promise(resolve => setTimeout(resolve, RATE_LIMIT_MS - timeSinceLast));
                lastRequestTime = now;
                return fn(...args);
            };
        }

        function showToast(message, type = 'info') {
            const toastOptions = {
                text: message,
                duration: 6500,
                position: "center",
                style: {
                    background: isDarkMode ? '#2d3748' : '#fff',
                    color: isDarkMode ? '#e2e8f0' : '#1f2a44',
                    border: `1px solid ${isDarkMode ? '#4b5563' : '#d1d5db'}`,
                    boxShadow: isDarkMode ? '0 2px 10px rgba(0, 0, 0, 0.3)' : '0 2px 10px rgba(0, 0, 0, 0.1)',
                    position: 'fixed',
                    top: '50px',
                    left: '50%',
                    transform: 'translateX(-50%)',
                    width: 'auto',
                    maxWidth: '80%',
                    zIndex: 1000
                }
            };
            switch (type) {
                case 'success': toastOptions.style.background = isDarkMode ? '#166534' : '#22c55e'; toastOptions.style.color = '#fff'; break;
                case 'error': toastOptions.style.background = isDarkMode ? '#991b1b' : '#ef4444'; toastOptions.style.color = '#fff'; break;
            }
            Toastify(toastOptions).showToast();
        }

        async function stabilizeNetwork() {
            return new Promise(resolve => {
                network.stabilize(200);
                network.once('stabilizationIterationsDone', () => {
                    network.fit({ animation: { duration: 500, easingFunction: 'easeInOutQuad' } });
                    resolve();
                });
            });
        }

        function throttleRequest(fn) {
            return async function(...args) {
                const now = Date.now();
                const timeSinceLast = now - lastRequestTime;
                if (timeSinceLast < RATE_LIMIT_MS) await new Promise(resolve => setTimeout(resolve, RATE_LIMIT_MS - timeSinceLast));
                lastRequestTime = now;
                return fn(...args);
            };
        }

        function showToast(message, type = 'info') {
            const toastOptions = {
                text: message,
                duration: 6500,
                position: "center",
                style: {
                    background: isDarkMode ? '#2d3748' : '#fff',
                    color: isDarkMode ? '#e2e8f0' : '#1f2a44',
                    border: `1px solid ${isDarkMode ? '#4b5563' : '#d1d5db'}`,
                    boxShadow: isDarkMode ? '0 2px 10px rgba(0, 0, 0, 0.3)' : '0 2px 10px rgba(0, 0, 0, 0.1)',
                    position: 'fixed',
                    top: '50px',
                    left: '50%',
                    transform: 'translateX(-50%)',
                    width: 'auto',
                    maxWidth: '80%',
                    zIndex: 1000
                }
            };
            switch (type) {
                case 'success': toastOptions.style.background = isDarkMode ? '#166534' : '#22c55e'; toastOptions.style.color = '#fff'; break;
                case 'error': toastOptions.style.background = isDarkMode ? '#991b1b' : '#ef4444'; toastOptions.style.color = '#fff'; break;
            }
            Toastify(toastOptions).showToast();
        }

        async function stabilizeNetwork() {
            return new Promise(resolve => {
                network.stabilize(200);
                network.once('stabilizationIterationsDone', () => {
                    network.fit({ animation: { duration: 500, easingFunction: 'easeInOutQuad' } });
                    resolve();
                });
            });
        }



        const throttledEnrichInternetDB = throttleRequest(async function enrichInternetDB(ip, ipNodeId, isBulk = false) {
    network.setOptions({ physics: { enabled: false } });
    try {
        const response = await fetch(`https://internetdb.shodan.io/${ip}`);
        if (!response.ok) throw new Error('Failed to fetch InternetDB data');
        const data = await response.json();

        // Process open ports
        if (data.ports && data.ports.length > 0) {
            data.ports.forEach(port => {
                const existingPort = nodes.get({ filter: n => n.type === 'port' && n.portNumber === port.toString() && n.portType === 'TCP' })[0];
                const portId = existingPort ? existingPort.id : nextId++;
                if (!existingPort) {
                    nodes.add({ 
                        id: portId, 
                        type: 'port', 
                        label: `TCP/${port}`, 
                        title: `Port\nType: TCP\nNumber: ${port}`, 
                        color: { background: '#a78bfa' }, 
                        portType: 'TCP', 
                        portNumber: port.toString() 
                    });
                }
                const edgeId = `${ipNodeId}-${portId}-Exposes`;
                if (!edges.get(edgeId)) edges.add({ id: edgeId, from: ipNodeId, to: portId, label: 'Exposes' });
            });
        }

        // Process hostnames
        if (data.hostnames && data.hostnames.length > 0) {
            data.hostnames.forEach(hostname => {
                const existingDomain = nodes.get({ filter: n => n.type === 'domain' && n.domain === hostname })[0];
                const domainId = existingDomain ? existingDomain.id : nextId++;
                if (!existingDomain) {
                    nodes.add({ 
                        id: domainId, 
                        type: 'domain', 
                        label: hostname, 
                        title: `Domain: ${hostname}`, 
                        color: { background: '#60a5fa' }, 
                        domain: hostname 
                    });
                }
                const edgeId = `${ipNodeId}-${domainId}-ResolvesTo`;
                if (!edges.get(edgeId)) edges.add({ id: edgeId, from: ipNodeId, to: domainId, label: 'Resolves to' });
            });
        }

        // Process vulnerabilities (CVEs)
        if (data.cves && data.cves.length > 0) {
            data.cves.forEach(cve => {
                const existingCVE = nodes.get({ filter: n => n.type === 'vulnerability' && n.cve === cve })[0];
                const cveId = existingCVE ? existingCVE.id : nextId++;
                if (!existingCVE) {
                    nodes.add({ 
                        id: cveId, 
                        type: 'vulnerability', 
                        label: cve, 
                        title: `Vulnerability: ${cve}`, 
                        color: { background: '#ef4444' }, 
                        cve: cve 
                    });
                }
                const edgeId = `${ipNodeId}-${cveId}-Has`;
                if (!edges.get(edgeId)) edges.add({ id: edgeId, from: ipNodeId, to: cveId, label: 'Has' });
            });
        }

        updateNodeSizes();
        updateSelectOptions();
        await stabilizeNetwork();
        if (!isBulk) showToast(`IP ${ip} enrichment completed using InternetDB`, 'success');
    } catch (error) {
        console.error(`Error enriching IP ${ip} with InternetDB: ${error.message}`);
        showToast(`Error enriching IP ${ip} with InternetDB: ${error.message}`, 'error');
        await stabilizeNetwork();
    }
});

async function enrichAllInternetDB() {
    network.setOptions({ physics: { enabled: false } });
    const ipNodes = nodes.get({ filter: n => n.type === 'ip' && n.ip });
    let successfulEnrichments = 0;
    
    console.log(`Found ${ipNodes.length} IP nodes to enrich with InternetDB`);
    
    for (const node of ipNodes) {
        try {
            console.log(`Enriching IP: ${node.ip}`);
            await throttledEnrichInternetDB(node.ip, node.id, true);
            successfulEnrichments++;
        } catch (error) {
            console.error(`Failed to enrich IP ${node.ip}: ${error.message}`);
            showToast(`Failed to enrich IP ${node.ip}: ${error.message}`, 'error');
        }
    }
    
    await stabilizeNetwork();
    showToast(`InternetDB enrichment completed: ${successfulEnrichments}/${ipNodes.length} IPs enriched`, 'success');
    
    // Add this: Restore mobile layout after enrichment
    if (window.innerWidth <= 768) {
        const controls = document.getElementById('controls');
        controls.classList.add('collapsed');
        document.getElementById('myNetwork').style.display = 'block';
        network.fit({
            animation: {
                duration: 300,
                easingFunction: 'easeInOutQuad'
            }
        });
    }
}

        const throttledEnrichIP = throttleRequest(async function enrichIP(ip, ipNodeId, isBulk = false) {
            if (!ipinfoApiKey) { showToast('Please set your IPinfo API key in the "API Keys" tab first.', 'error'); return; }
            network.setOptions({ physics: { enabled: false } });
            try {
                const response = await fetch(`https://ipinfo.io/${ip}/json?token=${ipinfoApiKey}`);
                if (!response.ok) throw new Error('Failed to fetch IP info');
                const data = await response.json();
                const asn = data.asn?.asn || 'Unknown ASN';
                const city = data.city || 'Unknown City';
                const companyName = data.company?.name || 'Unknown Company';
                const country = data.country || 'Unknown Country';
                const privacy = data.privacy || { vpn: false, proxy: false, tor: false, relay: false, hosting: false };

                function linkOrCreateNode(type, key, value, label, title, color, edgeLabel) {
                    const existingNode = nodes.get({ filter: n => n.type === type && n[key] === value })[0];
                    const targetId = existingNode ? existingNode.id : nextId++;
                    if (!existingNode) nodes.add({ id: targetId, type: type, label: label, title: title, color: { background: color }, [key]: value });
                    const edgeId = `${ipNodeId}-${targetId}-${edgeLabel}`;
                    if (!edges.get(edgeId)) edges.add({ id: edgeId, from: ipNodeId, to: targetId, label: edgeLabel });
                }

                linkOrCreateNode('asn', 'asn', asn, asn, `ASN: ${asn}`, '#a3e635', 'Assigned to');
                linkOrCreateNode('city', 'city', city, city, `City: ${city}`, '#f97316', 'Located in');
                linkOrCreateNode('organization', 'organization', companyName, companyName, `Company: ${companyName}`, '#facc15', 'Belongs to');
                linkOrCreateNode('country', 'country', country, country, `Country: ${country}`, '#34d399', 'Located in');

                const privacyTypes = [
                    { key: 'vpn', label: 'VPN', color: '#9333ea' },
                    { key: 'proxy', label: 'Proxy', color: '#f43f5e' },
                    { key: 'tor', label: 'Tor', color: '#64748b' },
                    { key: 'relay', label: 'Relay', color: '#eab308' },
                    { key: 'hosting', label: 'Hosting', color: '#14b8a6' }
                ];
                privacyTypes.forEach(privacyType => {
                    if (privacy[privacyType.key]) {
                        const existingPrivacy = nodes.get({ filter: n => n.type === privacyType.key })[0];
                        const privacyNodeId = existingPrivacy ? existingPrivacy.id : nextId++;
                        if (!existingPrivacy) {
                            nodes.add({ 
                                id: privacyNodeId, 
                                type: privacyType.key, 
                                label: privacyType.label, 
                                title: `${privacyType.label}`,
                                color: { background: privacyType.color }
                            });
                        }
                        const edgeId = `${ipNodeId}-${privacyNodeId}-Uses`;
                        if (!edges.get(edgeId)) edges.add({ id: edgeId, from: ipNodeId, to: privacyNodeId, label: 'Uses' });
                    }
                });

                updateNodeSizes();
                updateSelectOptions();
                await stabilizeNetwork();
                if (!isBulk) showToast(`IP ${ip} enrichment completed using IPinfo`, 'success');
            } catch (error) {
                console.error(`Error enriching IP ${ip}: ${error.message}`);
                showToast(`Error enriching IP ${ip}: ${error.message}`, 'error');
                await stabilizeNetwork();
            }
        });

        // Add this with your other enrichment functions
const throttledTestHTTPS = throttleRequest(async function testHTTPS(ip, nodeId) {
    try {
        // Disable physics during operation
        network.setOptions({ physics: { enabled: false } });
        
        // Make the HTTPS request
        const response = await fetch(`https://${ip}`, {
            method: 'GET',
            mode: 'no-cors', // Using no-cors since we just want to test connectivity
            timeout: 5000    // 5 second timeout
        });
        
        // If we get here without error, the connection was successful
        const existingStatus = nodes.get({ 
            filter: n => n.type === 'https_status' && n.ip === ip 
        })[0];
        
        const statusId = existingStatus ? existingStatus.id : nextId++;
        
        if (!existingStatus) {
            nodes.add({
                id: statusId,
                type: 'https_status',
                label: 'HTTPS Active',
                title: `HTTPS Status\nIP: ${ip}\nPort: 443\nStatus: Reachable`,
                color: { background: '#22c55e' }, // Green for success
                ip: ip
            });
        }
        
        const edgeId = `${nodeId}-${statusId}-HasHTTPS`;
        if (!edges.get(edgeId)) {
            edges.add({ 
                id: edgeId, 
                from: nodeId, 
                to: statusId, 
                label: 'Has HTTPS' 
            });
        }
        
        updateNodeSizes();
        updateSelectOptions();
        await stabilizeNetwork();
        showToast(`HTTPS test successful for ${ip}:443`, 'success');
        
    } catch (error) {
        // Handle connection failure
        const existingStatus = nodes.get({ 
            filter: n => n.type === 'https_status' && n.ip === ip 
        })[0];
        
        const statusId = existingStatus ? existingStatus.id : nextId++;
        
        if (!existingStatus) {
            nodes.add({
                id: statusId,
                type: 'https_status',
                label: 'HTTPS Unavailable',
                title: `HTTPS Status\nIP: ${ip}\nPort: 443\nStatus: Unreachable\nError: ${error.message}`,
                color: { background: '#ef4444' }, // Red for failure
                ip: ip
            });
        }
        
        const edgeId = `${nodeId}-${statusId}-HasHTTPS`;
        if (!edges.get(edgeId)) {
            edges.add({ 
                id: edgeId, 
                from: nodeId, 
                to: statusId, 
                label: 'No HTTPS' 
            });
        }
        
        console.error(`HTTPS test failed for ${ip}: ${error.message}`);
        showToast(`HTTPS test failed for ${ip}: ${error.message}`, 'error');
        
        updateNodeSizes();
        updateSelectOptions();
        await stabilizeNetwork();
    }
});

        const throttledEnrichShodan = throttleRequest(async function enrichShodan(ip, ipNodeId, isBulk = false) {
            if (!shodanApiKey) { showToast('Please set your Shodan API key in the "API Keys" tab first.', 'error'); return; }
            network.setOptions({ physics: { enabled: false } });
            try {
                const response = await fetch(`https://api.shodan.io/shodan/host/${ip}?key=${shodanApiKey}`);
                if (!response.ok) throw new Error('Failed to fetch Shodan data');
                const data = await response.json();
                if (data.ports && data.ports.length > 0) {
                    data.ports.forEach(port => {
                        const existingPort = nodes.get({ filter: n => n.type === 'port' && n.portNumber === port.toString() && n.portType === 'TCP' })[0];
                        const portId = existingPort ? existingPort.id : nextId++;
                        if (!existingPort) nodes.add({ id: portId, type: 'port', label: `TCP/${port}`, title: `Port\nType: TCP\nNumber: ${port}`, color: { background: '#a78bfa' }, portType: 'TCP', portNumber: port.toString() });
                        const edgeId = `${ipNodeId}-${portId}-Exposes`;
                        if (!edges.get(edgeId)) edges.add({ id: edgeId, from: ipNodeId, to: portId, label: 'Exposes' });
                    });
                }
                updateNodeSizes();
                updateSelectOptions();
                await stabilizeNetwork();
                if (!isBulk) showToast(`IP ${ip} enrichment completed using Shodan`, 'success');
            } catch (error) {
                console.error(`Error enriching IP ${ip} with Shodan: ${error.message}`);
                showToast(`Error enriching IP ${ip} with Shodan: ${error.message}`, 'error');
                await stabilizeNetwork();
            }
        });

        const throttledEnrichGoogleDNS = throttleRequest(async function enrichGoogleDNS(domain, domainNodeId, isBulk = false) {
            network.setOptions({ physics: { enabled: false } });
            try {
                const response = await fetch(`https://dns.google/resolve?name=${domain}`);
                if (!response.ok) throw new Error('Failed to fetch DNS data');
                const data = await response.json();
                if (data.Answer) {
                    data.Answer.forEach(answer => {
                        if (answer.type === 1) { // Type 1 is A record (IPv4)
                            const ip = answer.data;
                            const existingIP = nodes.get({ filter: n => n.type === 'ip' && n.ip === ip })[0];
                            const ipId = existingIP ? existingIP.id : nextId++;
                            if (!existingIP) nodes.add({ id: ipId, type: 'ip', label: ip, title: `IP Address: ${ip}`, color: { background: '#f87171' }, ip: ip, size: 20 });
                            const edgeId = `${domainNodeId}-${ipId}-ResolvesTo`;
                            if (!edges.get(edgeId)) edges.add({ id: edgeId, from: domainNodeId, to: ipId, label: 'Resolves to' });
                        }
                    });
                }
                updateNodeSizes();
                updateSelectOptions();
                await stabilizeNetwork();
                if (!isBulk) showToast(`Domain ${domain} enrichment completed using Google DNS`, 'success');
            } catch (error) {
                console.error(`Error enriching domain ${domain} with Google DNS: ${error.message}`);
                showToast(`Error enriching domain ${domain} with Google DNS: ${error.message}`, 'error');
                await stabilizeNetwork();
            }
        });

        async function enrichAllIpinfo() {
    if (!ipinfoApiKey) { 
        showToast('Please set your IPinfo API key in the "API Keys" tab first.', 'error'); 
        return; 
    }
    
    network.setOptions({ physics: { enabled: false } });
    const ipNodes = nodes.get({ filter: n => n.type === 'ip' && n.ip });
    let successfulEnrichments = 0;
    
    console.log(`Found ${ipNodes.length} IP nodes to enrich`); // Debug log
    
    for (const node of ipNodes) {
        try {
            console.log(`Enriching IP: ${node.ip}`); // Debug log
            await throttledEnrichIP(node.ip, node.id, true);
            successfulEnrichments++;
        } catch (error) {
            console.error(`Failed to enrich IP ${node.ip}: ${error.message}`);
            showToast(`Failed to enrich IP ${node.ip}: ${error.message}`, 'error');
        }
    }
    
    await stabilizeNetwork();
    showToast(`IPinfo enrichment completed: ${successfulEnrichments}/${ipNodes.length} IPs enriched`, 'success');
}

async function enrichAllShodan() {
    if (!shodanApiKey) { 
        showToast('Please set your Shodan API key in the "API Keys" tab first.', 'error'); 
        return; 
    }
    
    network.setOptions({ physics: { enabled: false } });
    const ipNodes = nodes.get({ filter: n => n.type === 'ip' && n.ip });
    let successfulEnrichments = 0;
    
    console.log(`Found ${ipNodes.length} IP nodes to enrich`); // Debug log
    
    for (const node of ipNodes) {
        try {
            console.log(`Enriching IP: ${node.ip}`); // Debug log
            await throttledEnrichShodan(node.ip, node.id, true);
            successfulEnrichments++;
        } catch (error) {
            console.error(`Failed to enrich IP ${node.ip}: ${error.message}`);
            showToast(`Failed to enrich IP ${node.ip}: ${error.message}`, 'error');
        }
    }
    
    await stabilizeNetwork();
    showToast(`Shodan enrichment completed: ${successfulEnrichments}/${ipNodes.length} IPs enriched`, 'success');
}

function deleteNodes(nodeIds) {
    nodeIds.forEach(nodeId => {
        const node = nodes.get(nodeId);
        if (node) {
            edges.remove(edges.get({ filter: edge => edge.from === nodeId || edge.to === nodeId }));
            nodes.remove({ id: nodeId });
        }
    });
    selectedNodes.clear();
    network.selectNodes([]);
    updateSelectOptions();
    updateNodeSizes();
    stabilizeNetwork();
    saveStateAfterOperation();
    showToast(`${nodeIds.length} node${nodeIds.length > 1 ? 's' : ''} deleted`, 'success');
    hideContextMenu();
}

const throttledEnrichIPMultiple = throttleRequest(async function(ipValues, nodeIds) {
    for (let i = 0; i < ipValues.length; i++) {
        await throttledEnrichIP(ipValues[i], nodeIds[i], true);
    }
    showToast(`Enriched ${ipValues.length} IPs with IPinfo`, 'success');
});

const throttledEnrichShodanMultiple = throttleRequest(async function(ipValues, nodeIds) {
    for (let i = 0; i < ipValues.length; i++) {
        await throttledEnrichShodan(ipValues[i], nodeIds[i], true);
    }
    showToast(`Enriched ${ipValues.length} IPs with Shodan`, 'success');
});

const throttledEnrichInternetDBMultiple = throttleRequest(async function(ipValues, nodeIds) {
    for (let i = 0; i < ipValues.length; i++) {
        await throttledEnrichInternetDB(ipValues[i], nodeIds[i], true);
    }
    showToast(`Enriched ${ipValues.length} IPs with InternetDB`, 'success');
});

const throttledEnrichGoogleDNSMultiple = throttleRequest(async function(domainValues, nodeIds) {
    for (let i = 0; i < domainValues.length; i++) {
        await throttledEnrichGoogleDNS(domainValues[i], nodeIds[i], true);
    }
    showToast(`Enriched ${domainValues.length} domains with Google DNS`, 'success');
});

const throttledSendHttpsRequestMultiple = throttleRequest(async function(targets, type, protocol) {
    for (const target of targets) {
        await throttledSendHttpsRequest(target, type, protocol);
    }
    showToast(`Sent ${protocol.toUpperCase()} requests to ${targets.length} targets`, 'success');
});

async function enrichAllGoogleDNS() {
    network.setOptions({ physics: { enabled: false } });
    const domainNodes = nodes.get({ filter: n => n.type === 'domain' && n.domain });
    let successfulEnrichments = 0;
    
    console.log(`Found ${domainNodes.length} domain nodes to enrich`); // Debug log
    
    for (const node of domainNodes) {
        try {
            console.log(`Enriching domain: ${node.domain}`); // Debug log
            await throttledEnrichGoogleDNS(node.domain, node.id, true);
            successfulEnrichments++;
        } catch (error) {
            console.error(`Failed to enrich domain ${node.domain}: ${error.message}`);
            showToast(`Failed to enrich domain ${node.domain}: ${error.message}`, 'error');
        }
    }
    
    await stabilizeNetwork();
    showToast(`Google DNS enrichment completed: ${successfulEnrichments}/${domainNodes.length} domains enriched`, 'success');
}

        function importIOCsFromText() {
            const text = document.getElementById('iocText').value.trim();
            if (!text) { showToast('Please enter some text containing IOCs', 'error'); return; }
            processIOCs(text);
            document.getElementById('iocText').value = '';
            stabilizeNetwork();
        }

        function importIOCsFromFile() {
            const fileInput = document.getElementById('iocFile');
            const file = fileInput.files[0];
            if (!file) { showToast('Please select a text file containing IOCs', 'error'); return; }
            const reader = new FileReader();
            reader.onload = function(event) { 
                processIOCs(event.target.result); 
                fileInput.value = ''; 
                stabilizeNetwork();
            };
            reader.readAsText(file);
        }

        function processIOCs(text) {
            const ipMatches = text.match(/(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)|(?:[0-9a-fA-F]{0,4}:){7}[0-9a-fA-F]{0,4}/g) || [];
            ipMatches.forEach(ip => {
                if ((ipRegex.ipv4.test(ip) || ipRegex.ipv6.test(ip)) && !nodes.get({ filter: n => n.type === 'ip' && n.ip === ip }).length) 
                    nodes.add({ id: nextId++, type: 'ip', label: ip, title: `IP Address: ${ip}`, color: { background: '#f87171' }, ip: ip, size: 20 });
            });
            const domainMatches = text.match(/(?!:\/\/)([a-zA-Z0-9-_]+\.)*[a-zA-Z0-9][a-zA-Z0-9-_]+\.[a-zA-Z]{2,}/g) || [];
            domainMatches.forEach(domain => {
                if (domainRegex.test(domain) && !nodes.get({ filter: n => n.type === 'domain' && n.domain === domain }).length) 
                    nodes.add({ id: nextId++, type: 'domain', label: domain, title: `Domain: ${domain}`, color: { background: '#60a5fa' }, domain: domain, size: 20 });
            });
            updateNodeSizes();
            updateSelectOptions();
        }

        function saveIpinfoApiKey() {
            ipinfoApiKey = document.getElementById('ipinfoApiKey').value.trim();
            const storeKey = document.getElementById('storeIpinfoKey').checked;
            if (ipinfoApiKey) {
                if (storeKey) localStorage.setItem('ipinfoApiKey', ipinfoApiKey); else localStorage.removeItem('ipinfoApiKey');
                showToast('IPinfo API key saved successfully!', 'success');
            } else {
                localStorage.removeItem('ipinfoApiKey');
                showToast('Please enter a valid IPinfo API key.', 'error');
            }
        }

        function saveShodanApiKey() {
            shodanApiKey = document.getElementById('shodanApiKey').value.trim();
            const storeKey = document.getElementById('storeShodanKey').checked;
            if (shodanApiKey) {
                if (storeKey) localStorage.setItem('shodanApiKey', shodanApiKey); else localStorage.removeItem('shodanApiKey');
                showToast('Shodan API key saved successfully!', 'success');
            } else {
                localStorage.removeItem('shodanApiKey');
                showToast('Please enter a valid Shodan API key.', 'error');
            }
        }

        function updateTheme() {
    if (isDarkMode) {
        document.body.classList.remove('light-mode');
        document.body.classList.add('dark-mode');
        options.nodes.font = {
            size: 12,
            color: '#e2e8f0',
            multi: true,
            strokeWidth: 0,
            strokeColor: 'transparent'
        };
        options.nodes.color = {
            border: '#94a3b8',  // Added base border color
            background: '#4b5563',  // Added base background color
            hover: {
                border: '#60a5fa',
                background: '#4b5563'
            },
            highlight: {
                border: '#60a5fa',
                background: '#4b5563'
            }
        };
        options.edges.font = {
            size: 12,
            color: '#e2e8f0',
            strokeWidth: 0,
            strokeColor: 'transparent'
        };
        options.edges.color = { 
            color: '#94a3b8', 
            highlight: '#60a5fa' 
        };
    } else {
        document.body.classList.remove('dark-mode');
        document.body.classList.add('light-mode');
        options.nodes.font = {
            size: 12,
            color: '#1f2a44',
            multi: true,
            strokeWidth: 0,
            strokeColor: 'transparent'
        };
        options.nodes.color = {
            border: '#6b7280',  // Added base border color
            background: '#ffffff',  // Added base background color
            hover: {
                border: '#3b82f6',
                background: '#e5e7eb'
            },
            highlight: {
                border: '#3b82f6',
                background: '#e5e7eb'
            }
        };
        options.edges.font = {
            size: 12,
            color: '#1f2a44',
            strokeWidth: 0,
            strokeColor: 'transparent'
        };
        options.edges.color = { 
            color: '#6b7280', 
            highlight: '#3b82f6' 
        };
    }
    document.getElementById('mode-toggle').textContent = isDarkMode ? 'Switch to Light Mode' : 'Switch to Dark Mode';
    network.setOptions(options);
    ensureInteractionSettings();
}

        function toggleMode() { 
            isDarkMode = !isDarkMode; 
            updateTheme(); 
        }

        function togglePhysics() {
    isPhysicsPaused = !isPhysicsPaused;
    const pauseButton = document.getElementById('pause-toggle');
    network.setOptions({ 
        physics: { 
            enabled: !isPhysicsPaused,
            barnesHut: {
                // Ensure consistent physics settings
                gravitationalConstant: -8000,
                centralGravity: 0.1,
                springLength: 200,
                springConstant: 0.04,
                damping: 0.9,
                avoidOverlap: 0.5
            },
            maxVelocity: 25,
            minVelocity: 0.1
        },
        interaction: { ...baseInteractionOptions }
    });
    pauseButton.textContent = isPhysicsPaused ? 'Resume Physics' : 'Pause Physics';
    pauseButton.classList.toggle('paused', isPhysicsPaused);
    if (!isPhysicsPaused) {
        // Trigger stabilization when resuming physics
        stabilizeNetwork();
    }
    ensureInteractionSettings();
}

        function resetLayout() {
            nodes.forEach(node => nodes.update({ id: node.id, x: undefined, y: undefined }));
            stabilizeNetwork(false);
        }

        function setOrganicLayout() {
    network.setOptions({
        physics: {
            enabled: true,
            stabilization: {
                enabled: true,
                iterations: 200
            },
            barnesHut: {
                gravitationalConstant: -8000,
                centralGravity: 0.3,
                springLength: 150,
                springConstant: 0.05,
                damping: 0.9,
                avoidOverlap: 1.0
            },
            maxVelocity: 50,
            minVelocity: 0.1
        },
        layout: { 
            hierarchical: false,
            improvedLayout: true 
        },
        interaction: { ...baseInteractionOptions }
    });

    // Reset node positions
    nodes.forEach(node => {
        nodes.update({ 
            id: node.id, 
            x: undefined, 
            y: undefined,
            fixed: { x: false, y: false }
        });
    });

    stabilizeNetwork().then(() => {
        isPhysicsPaused = true;
        network.setOptions({ physics: { enabled: false } });
        const pauseButton = document.getElementById('pause-toggle');
        pauseButton.textContent = 'Resume Physics';
        pauseButton.classList.add('paused');
    });
}

function setCircularLayout() {
    network.setOptions({
        physics: { enabled: false },
        layout: { hierarchical: false },
        interaction: { ...baseInteractionOptions }
    });

    const containerRect = container.getBoundingClientRect();
    const radius = Math.min(containerRect.width, containerRect.height) / 2 - 100;
    const nodeCount = nodes.length;
    const angleStep = (2 * Math.PI) / nodeCount;
    const centerX = containerRect.width / 2;
    const centerY = containerRect.height / 2;

    nodes.forEach((node, i) => {
        const x = centerX + radius * Math.cos(angleStep * i);
        const y = centerY + radius * Math.sin(angleStep * i);
        nodes.update({
            id: node.id,
            x: x,
            y: y,
            fixed: { x: true, y: true }
        });
    });

    network.fit({
        animation: {
            duration: 500,
            easingFunction: 'easeInOutQuad'
        }
    });
}

function setOrthogonalLayout() {
    network.setOptions({
        physics: { enabled: false },
        layout: { hierarchical: false },
        interaction: { ...baseInteractionOptions }
    });

    const containerRect = container.getBoundingClientRect();
    const gridSize = Math.ceil(Math.sqrt(nodes.length));
    const stepX = containerRect.width / (gridSize + 1);
    const stepY = containerRect.height / (gridSize + 1);
    let i = 0;

    nodes.forEach(node => {
        const x = (i % gridSize + 0.5) * stepX;
        const y = (Math.floor(i / gridSize) + 0.5) * stepY;
        nodes.update({
            id: node.id,
            x: x,
            y: y,
            fixed: { x: true, y: true }
        });
        i++;
    });

    network.fit({
        animation: {
            duration: 500,
            easingFunction: 'easeInOutQuad'
        }
    });
}

function setTreeLayout() {
    network.setOptions({
        physics: { enabled: false },
        layout: {
            hierarchical: {
                enabled: true,
                levelSeparation: 200,
                nodeSpacing: 150,
                treeSpacing: 200,
                direction: 'UD',
                sortMethod: 'hubsize',
                shakeTowards: 'leaves'
            }
        },
        edges: {
            smooth: {
                enabled: true,
                type: 'cubicBezier'
            }
        },
        interaction: { ...baseInteractionOptions }
    });

    // Reset positions before applying layout
    nodes.forEach(node => {
        nodes.update({
            id: node.id,
            x: undefined,
            y: undefined,
            fixed: { x: false, y: false }
        });
    });

    network.fit({
        animation: {
            duration: 500,
            easingFunction: 'easeInOutQuad'
        }
    });
}

function setHierarchicalLayout() {
    network.setOptions({
        physics: { enabled: false },
        layout: {
            hierarchical: {
                enabled: true,
                levelSeparation: 200,
                nodeSpacing: 150,
                treeSpacing: 200,
                direction: 'UD',
                sortMethod: 'directed',
                shakeTowards: 'roots'
            }
        },
        edges: {
            smooth: {
                enabled: true,
                type: 'cubicBezier'
            }
        },
        interaction: { ...baseInteractionOptions }
    });

    // Reset positions before applying layout
    nodes.forEach(node => {
        nodes.update({
            id: node.id,
            x: undefined,
            y: undefined,
            fixed: { x: false, y: false }
        });
    });

    network.fit({
        animation: {
            duration: 500,
            easingFunction: 'easeInOutQuad'
        }
    });
}

        function showTab(tabId) {
            document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
            document.getElementById(tabId).classList.add('active');
            document.querySelector(`.tab-button[onclick="showTab('${tabId}')"]`).classList.add('active');
        }

        document.getElementById('addEntityType').addEventListener('change', function() {
            let type = this.value;
            document.getElementById('addNameInput').style.display = type === 'contact' ? 'block' : 'none';
            document.getElementById('addEmailInput').style.display = type === 'contact' ? 'block' : 'none';
            document.getElementById('addIpInput').style.display = type === 'ip' ? 'block' : 'none';
            document.getElementById('addDomainInput').style.display = type === 'domain' ? 'block' : 'none';
            document.getElementById('addOrgInput').style.display = type === 'organization' ? 'block' : 'none';
            document.getElementById('addPortNumInput').style.display = type === 'port' ? 'block' : 'none';
            document.getElementById('addPortType').style.display = type === 'port' ? 'block' : 'none';
            document.getElementById('addWalletAddressInput').style.display = type === 'wallet' ? 'block' : 'none';
            document.getElementById('addAccountNumberInput').style.display = type === 'bank' ? 'block' : 'none';
            document.getElementById('addSortCodeInput').style.display = type === 'bank' ? 'block' : 'none';
            document.getElementById('addTechNameInput').style.display = type === 'technology' ? 'block' : 'none';
            document.getElementById('addTechVersionInput').style.display = type === 'technology' ? 'block' : 'none';
            document.getElementById('addDeviceCategory').style.display = type === 'device' ? 'block' : 'none';
            document.getElementById('addDeviceNameInput').style.display = type === 'device' ? 'block' : 'none';
            document.getElementById('addMalwareNameInput').style.display = type === 'malware' ? 'block' : 'none';
            document.getElementById('addMalwareType').style.display = type === 'malware' ? 'block' : 'none';
        });

        function createNodeData(type, values) {
    const nodeData = { 
        id: nextId++, 
        size: 20, // Consistent starting size
        type,
        // Ensure no size constraints from label
        widthConstraint: false,
        heightConstraint: false
    };
            const configs = {
                contact: { fields: ['name'], optionalFields: ['email'], color: '#4ade80', label: v => v.email ? `${v.name}\n${v.email}` : v.name, title: v => v.email ? `Contact\nName: ${v.name}\nEmail: ${v.email}` : `Contact\nName: ${v.name}` },
                ip: { fields: ['ip'], color: '#f87171', label: v => v.ip, title: v => `IP Address: ${v.ip}`, validate: v => ipRegex.ipv4.test(v.ip) || ipRegex.ipv6.test(v.ip) },
                domain: { fields: ['domain'], color: '#60a5fa', label: v => v.domain, title: v => `Domain: ${v.domain}` },
                organization: { fields: ['organization'], color: '#facc15', label: v => v.organization, title: v => `Organization: ${v.organization}` },
                port: { fields: ['portNumber', 'portType'], color: '#a78bfa', label: v => `${v.portType}/${v.portNumber}`, title: v => `Port\nType: ${v.portType}\nNumber: ${v.portNumber}` },
                wallet: { fields: ['address'], color: '#fb923c', label: v => v.address, title: v => `Wallet\nAddress: ${v.address}` },
                bank: { fields: ['accountNumber', 'sortCode'], color: '#10b981', label: v => `${v.accountNumber}\n${v.sortCode}`, title: v => `Bank Account\nAccount Number: ${v.accountNumber}\nSort Code: ${v.sortCode}` },
                technology: { fields: ['techName', 'techVersion'], color: '#ec4899', label: v => `${v.techName}\n${v.techVersion}`, title: v => `Technology\nName: ${v.techName}\nVersion: ${v.techVersion}` },
                device: { fields: ['deviceCategory', 'deviceName'], color: '#14b8a6', label: v => `${v.deviceName}\n${v.deviceCategory}`, title: v => `Device\nName: ${v.deviceName}\nCategory: ${v.deviceCategory}` },
                malware: { fields: ['malwareName', 'malwareType'], color: '#ef4444', label: v => `${v.malwareName}\n${v.malwareType}`, title: v => `Malware\nName: ${v.malwareName}\nType: ${v.malwareType}` }
            };
            const config = configs[type];
            if (!config || config.fields.some(f => !values[f])) { showToast(`Please enter all required fields for ${type}`, 'error'); return null; }
            if (config.validate && !config.validate(values)) { showToast(`Invalid ${type} format`, 'error'); return null; }
            const allValues = { ...values };
            if (config.optionalFields) config.optionalFields.forEach(f => { if (values[f]) allValues[f] = values[f]; });
            Object.assign(nodeData, { label: config.label(allValues), title: config.title(allValues), color: { background: config.color }, ...allValues });
            return nodeData;
        }

        function addNode() {
    const type = document.getElementById('addEntityType').value;
    
    // Collect inputs based on entity type
    const inputs = {
        contact: { 
            name: document.getElementById('addNameInput').value.trim(),
            email: document.getElementById('addEmailInput').value.trim()
        },
        ip: { 
            ip: document.getElementById('addIpInput').value.trim()
        },
        domain: { 
            domain: document.getElementById('addDomainInput').value.trim()
        },
        organization: { 
            organization: document.getElementById('addOrgInput').value.trim()
        },
        port: { 
            portNumber: document.getElementById('addPortNumInput').value.trim(),
            portType: document.getElementById('addPortType').value
        },
        wallet: { 
            address: document.getElementById('addWalletAddressInput').value.trim()
        },
        bank: { 
            accountNumber: document.getElementById('addAccountNumberInput').value.trim(),
            sortCode: document.getElementById('addSortCodeInput').value.trim()
        },
        technology: { 
            techName: document.getElementById('addTechNameInput').value.trim(),
            techVersion: document.getElementById('addTechVersionInput').value.trim()
        },
        device: { 
            deviceCategory: document.getElementById('addDeviceCategory').value,
            deviceName: document.getElementById('addDeviceNameInput').value.trim()
        },
        malware: { 
            malwareName: document.getElementById('addMalwareNameInput').value.trim(),
            malwareType: document.getElementById('addMalwareType').value
        }
    };

    // Get the node data using the inputs for the selected type
    const nodeData = createNodeData(type, inputs[type]);
    if (!nodeData) {
        // createNodeData already shows a toast for validation errors
        return;
    }

    // Check for duplicates based on key fields
    const existingNodes = nodes.get({
        filter: n => n.type === type && (
            (type === 'contact' && n.name === inputs[type].name && (!inputs[type].email || n.email === inputs[type].email)) ||
            (type === 'ip' && n.ip === inputs[type].ip) ||
            (type === 'domain' && n.domain === inputs[type].domain) ||
            (type === 'organization' && n.organization === inputs[type].organization) ||
            (type === 'port' && n.portNumber === inputs[type].portNumber && n.portType === inputs[type].portType) ||
            (type === 'wallet' && n.address === inputs[type].address) ||
            (type === 'bank' && n.accountNumber === inputs[type].accountNumber && n.sortCode === inputs[type].sortCode) ||
            (type === 'technology' && n.techName === inputs[type].techName && n.techVersion === inputs[type].techVersion) ||
            (type === 'device' && n.deviceCategory === inputs[type].deviceCategory && n.deviceName === inputs[type].deviceName) ||
            (type === 'malware' && n.malwareName === inputs[type].malwareName && n.malwareType === inputs[type].malwareType)
        )
    });

    if (existingNodes.length > 0) {
        showToast(`${type} already exists`, 'error');
        return;
    }

    // Add the node
    nodes.add({
        ...nodeData,
        size: 20, // Fixed initial size
        widthConstraint: false,
        heightConstraint: false
    });

    // Update UI and network
    updateSelectOptions();
    clearAddInputs();
    updateNodeSizes();
    stabilizeNetwork();
    saveStateAfterOperation();
    showToast(`${type} added successfully`, 'success');
}

        function editNode() {
            const nodeId = document.getElementById('editNodeSelect').value;
            if (!nodeId) { showToast('Please select a node to edit', 'error'); return; }
            const node = nodes.get(parseInt(nodeId));
            if (!node) { showToast('Selected node not found', 'error'); return; }

            const type = node.type;
            const inputs = {
                contact: { name: document.getElementById('editNameInput').value, email: document.getElementById('editEmailInput').value },
                ip: { ip: document.getElementById('editIpInput').value.trim() },
                domain: { domain: document.getElementById('editDomainInput').value },
                organization: { organization: document.getElementById('editOrgInput').value },
                port: { portNumber: document.getElementById('editPortNumInput').value, portType: document.getElementById('editPortType').value },
                wallet: { address: document.getElementById('editWalletAddressInput').value },
                bank: { accountNumber: document.getElementById('editAccountNumberInput').value, sortCode: document.getElementById('editSortCodeInput').value },
                technology: { techName: document.getElementById('editTechNameInput').value, techVersion: document.getElementById('editTechVersionInput').value },
                device: { deviceCategory: document.getElementById('editDeviceCategory').value, deviceName: document.getElementById('editDeviceNameInput').value },
                malware: { malwareName: document.getElementById('editMalwareNameInput').value, malwareType: document.getElementById('editMalwareType').value }
            };
            const updatedNodeData = createNodeData(type, inputs[type]);
            if (updatedNodeData) {
                const existingNode = nodes.get({ filter: n => n.id !== parseInt(nodeId) && n.type === type && Object.keys(inputs[type]).every(key => n[key] === inputs[type][key]) });
                if (existingNode) { showToast(`Another ${type} with these values already exists`, 'error'); return; }
                updatedNodeData.id = node.id;
                nodes.update(updatedNodeData);
                updateSelectOptions();
                clearEditInputs();
                stabilizeNetwork();
                saveStateAfterOperation(); 
            }
        }

        function loadNodeForEdit() {
            const nodeId = document.getElementById('editNodeSelect').value;
            clearEditInputs();
            if (!nodeId) return;

            const node = nodes.get(parseInt(nodeId));
            if (!node) return;

            document.getElementById('editEntityType').value = node.type;
            switch (node.type) {
                case 'contact':
                    document.getElementById('editNameInput').value = node.name || '';
                    document.getElementById('editEmailInput').value = node.email || '';
                    break;
                case 'ip':
                    document.getElementById('editIpInput').value = node.ip || '';
                    break;
                case 'domain':
                    document.getElementById('editDomainInput').value = node.domain || '';
                    break;
                case 'organization':
                    document.getElementById('editOrgInput').value = node.organization || '';
                    break;
                case 'port':
                    document.getElementById('editPortNumInput').value = node.portNumber || '';
                    document.getElementById('editPortType').value = node.portType || 'TCP';
                    break;
                case 'wallet':
                    document.getElementById('editWalletAddressInput').value = node.address || '';
                    break;
                case 'bank':
                    document.getElementById('editAccountNumberInput').value = node.accountNumber || '';
                    document.getElementById('editSortCodeInput').value = node.sortCode || '';
                    break;
                case 'technology':
                    document.getElementById('editTechNameInput').value = node.techName || '';
                    document.getElementById('editTechVersionInput').value = node.techVersion || '';
                    break;
                case 'device':
                    document.getElementById('editDeviceCategory').value = node.deviceCategory || 'Server';
                    document.getElementById('editDeviceNameInput').value = node.deviceName || '';
                    break;
                case 'malware':
                    document.getElementById('editMalwareNameInput').value = node.malwareName || '';
                    document.getElementById('editMalwareType').value = node.malwareType || 'Wiper';
                    break;
            }
            document.getElementById('editNameInput').style.display = node.type === 'contact' ? 'block' : 'none';
            document.getElementById('editEmailInput').style.display = node.type === 'contact' ? 'block' : 'none';
            document.getElementById('editIpInput').style.display = node.type === 'ip' ? 'block' : 'none';
            document.getElementById('editDomainInput').style.display = node.type === 'domain' ? 'block' : 'none';
            document.getElementById('editOrgInput').style.display = node.type === 'organization' ? 'block' : 'none';
            document.getElementById('editPortNumInput').style.display = node.type === 'port' ? 'block' : 'none';
            document.getElementById('editPortType').style.display = node.type === 'port' ? 'block' : 'none';
            document.getElementById('editWalletAddressInput').style.display = node.type === 'wallet' ? 'block' : 'none';
            document.getElementById('editAccountNumberInput').style.display = node.type === 'bank' ? 'block' : 'none';
            document.getElementById('editSortCodeInput').style.display = node.type === 'bank' ? 'block' : 'none';
            document.getElementById('editTechNameInput').style.display = node.type === 'technology' ? 'block' : 'none';
            document.getElementById('editTechVersionInput').style.display = node.type === 'technology' ? 'block' : 'none';
            document.getElementById('editDeviceCategory').style.display = node.type === 'device' ? 'block' : 'none';
            document.getElementById('editDeviceNameInput').style.display = node.type === 'device' ? 'block' : 'none';
            document.getElementById('editMalwareNameInput').style.display = node.type === 'malware' ? 'block' : 'none';
            document.getElementById('editMalwareType').style.display = node.type === 'malware' ? 'block' : 'none';
        }

        function clearAddInputs() {
            document.querySelectorAll('#object-management .input-group:first-child input').forEach(input => input.value = '');
            document.getElementById('addDeviceCategory').value = 'Server';
            document.getElementById('addMalwareType').value = 'Wiper';
            document.getElementById('addPortType').value = 'TCP';
        }

        function clearEditInputs() {
            document.querySelectorAll('#object-management .input-group:nth-child(2) input').forEach(input => input.value = '');
            document.getElementById('editDeviceCategory').value = 'Server';
            document.getElementById('editMalwareType').value = 'Wiper';
            document.getElementById('editPortType').value = 'TCP';
        }

        function addEdge() {
            let from = document.getElementById('fromNode').value; 
            let to = document.getElementById('toNode').value; 
            let label = document.getElementById('edgeLabel').value;
            if (!from || !to || from === to) return showToast('Please select different nodes', 'error');
            edges.add({ id: `edge_${from}_${to}_${Date.now()}`, from: parseInt(from), to: parseInt(to), label: label || undefined });
            updateNodeSizes(); 
            updateEdgeSelectOptions(); 
            document.getElementById('edgeLabel').value = ''; 
            stabilizeNetwork();
            saveStateAfterOperation();
        }

        function removeNode() {
            let nodeId = document.getElementById('removeNode').value;
            if (!nodeId) return showToast('Please select a node', 'error');
            edges.remove(edges.get({ filter: edge => edge.from === parseInt(nodeId) || edge.to === parseInt(nodeId) }));
            nodes.remove({ id: parseInt(nodeId) });
            updateNodeSizes(); 
            updateSelectOptions(); 
            stabilizeNetwork();
            saveStateAfterOperation();
        }

        function removeEdge() {
            let edgeId = document.getElementById('removeEdge').value;
            if (!edgeId) return showToast('Please select an edge', 'error');
            edges.remove({ id: edgeId });
            updateNodeSizes(); 
            updateEdgeSelectOptions(); 
            document.getElementById('removeEdge').value = ''; 
            stabilizeNetwork();
            saveStateAfterOperation();
        }

        function clearGraph() {
            if (!confirm('Are you sure you want to clear the graph?')) return;
            nodes.clear(); 
            edges.clear(); 
            nextId = 1; 
            updateSelectOptions(); 
            updateEdgeSelectOptions(); 
            clearAddInputs(); 
            clearEditInputs(); 
            stabilizeNetwork();
            saveStateAfterOperation();
        }

        function updateNodeSizes() {
    nodes.forEach(node => { 
        // Count connections
        const connections = edges.get({ 
            filter: edge => edge.from === node.id || edge.to === node.id 
        }).length; 
        
        // Base size 20, add 5 per connection, max 60
        const newSize = Math.min(20 + connections * 5, 60);
        
        nodes.update({ 
            id: node.id, 
            size: newSize,
            // Ensure label doesn't affect size
            widthConstraint: false,
            heightConstraint: false
        }); 
    });
}

        function updateSelectOptions() {
            ['editNodeSelect', 'fromNode', 'toNode', 'removeNode'].forEach(id => {
                let select = document.getElementById(id);
                select.innerHTML = '<option value="">Select</option>';
                nodes.forEach(node => { 
                    let option = document.createElement('option'); 
                    option.value = node.id; 
                    option.text = node.label.split('\n')[0]; 
                    select.appendChild(option); 
                });
            });
            updateEdgeSelectOptions();
        }

        function updateEdgeSelectOptions() {
            let select = document.getElementById('removeEdge');
            select.innerHTML = '<option value="">Select Edge</option>';
            edges.forEach(edge => {
                let fromNode = nodes.get(edge.from); 
                let toNode = nodes.get(edge.to);
                if (fromNode && toNode) {
                    let option = document.createElement('option');
                    option.value = edge.id; 
                    option.text = `${fromNode.label.split('\n')[0]} -> ${toNode.label.split('\n')[0]}${edge.label ? ' (' + edge.label + ')' : ''}`;
                    select.appendChild(option);
                }
            });
        }

        function exportGraph() {
            const exportData = { 
                nodes: nodes.get().map(node => ({ 
                    id: node.id, type: node.type, name: node.name, email: node.email, ip: node.ip, domain: node.domain, 
                    organization: node.organization, portType: node.portType, portNumber: node.portNumber, address: node.address, 
                    accountNumber: node.accountNumber, sortCode: node.sortCode, techName: node.techName, techVersion: node.techVersion, 
                    deviceCategory: node.deviceCategory, deviceName: node.deviceName, malwareName: node.malwareName, malwareType: node.malwareType, 
                    country: node.country, asn: node.asn, city: node.city, value: node.value 
                })), 
                edges: edges.get().map(edge => ({ id: edge.id, from: edge.from, to: edge.to, label: edge.label })) 
            };
            const json = JSON.stringify(exportData, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); 
            a.href = url; 
            a.download = 'network_graph.json'; 
            a.click(); 
            URL.revokeObjectURL(url);
        }

        function importGraph() {
            let fileInput = document.getElementById('importFile');
            let file = fileInput.files[0];
            if (!file) return showToast('Please select a JSON file', 'error');
            let reader = new FileReader();
            reader.onload = function(event) {
                try {
                    let importedData = JSON.parse(event.target.result);
                    nodes.clear(); 
                    edges.clear();
                    importedData.nodes.forEach(node => {
                        let nodeData = { id: node.id, size: 20, type: node.type, label: '', title: '', color: { background: '' } };
                        if (node.type === 'contact') {
                            if (!node.name) return;
                            nodeData.label = node.email ? `${node.name}\n${node.email}` : node.name;
                            nodeData.title = node.email ? `Contact\nName: ${node.name}\nEmail: ${node.email}` : `Contact\nName: ${node.name}`;
                            nodeData.color.background = '#4ade80';
                            nodeData.name = node.name;
                            if (node.email) nodeData.email = node.email;
                        } else if (node.type === 'ip') {
                            if (!node.ip) return;
                            nodeData.label = node.ip; nodeData.title = `IP Address: ${node.ip}`; nodeData.color.background = '#f87171'; nodeData.ip = node.ip;
                        } else if (node.type === 'domain') {
                            if (!node.domain) return;
                            nodeData.label = node.domain; nodeData.title = `Domain: ${node.domain}`; nodeData.color.background = '#60a5fa'; nodeData.domain = node.domain;
                        } else if (node.type === 'organization') {
                            if (!node.organization) return;
                            nodeData.label = node.organization; nodeData.title = `Organization: ${node.organization}`; nodeData.color.background = '#facc15'; nodeData.organization = node.organization;
                        } else if (node.type === 'port') {
                            if (!node.portNumber || !node.portType) return;
                            nodeData.label = `${node.portType}/${node.portNumber}`; nodeData.title = `Port\nType: ${node.portType}\nNumber: ${node.portNumber}`; nodeData.color.background = '#a78bfa'; nodeData.portType = node.portType; nodeData.portNumber = node.portNumber;
                        } else if (node.type === 'wallet') {
                            if (!node.address) return;
                            nodeData.label = node.address; nodeData.title = `Wallet\nAddress: ${node.address}`; nodeData.color.background = '#fb923c'; nodeData.address = node.address;
                        } else if (node.type === 'bank') {
                            if (!node.accountNumber || !node.sortCode) return;
                            nodeData.label = `${node.accountNumber}\n${node.sortCode}`; nodeData.title = `Bank Account\nAccount Number: ${node.accountNumber}\nSort Code: ${node.sortCode}`; nodeData.color.background = '#10b981'; nodeData.accountNumber = node.accountNumber; nodeData.sortCode = node.sortCode;
                        } else if (node.type === 'technology') {
                            if (!node.techName || !node.techVersion) return;
                            nodeData.label = `${node.techName}\n${node.techVersion}`; nodeData.title = `Technology\nName: ${node.techName}\nVersion: ${node.techVersion}`; nodeData.color.background = '#ec4899'; nodeData.techName = node.techName; nodeData.techVersion = node.techVersion;
                        } else if (node.type === 'device') {
                            if (!node.deviceCategory || !node.deviceName) return;
                            nodeData.label = `${node.deviceName}\n${node.deviceCategory}`; nodeData.title = `Device\nName: ${node.deviceName}\nCategory: ${node.deviceCategory}`; nodeData.color.background = '#14b8a6'; nodeData.deviceCategory = node.deviceCategory; nodeData.deviceName = node.deviceName;
                        } else if (node.type === 'malware') {
                            if (!node.malwareName || !node.malwareType) return;
                            nodeData.label = `${node.malwareName}\n${node.malwareType}`; nodeData.title = `Malware\nName: ${node.malwareName}\nType: ${node.malwareType}`; nodeData.color.background = '#ef4444'; nodeData.malwareName = node.malwareName; nodeData.malwareType = node.malwareType;
                        } else if (node.type === 'country') {
                            if (!node.country) return;
                            nodeData.label = node.country; nodeData.title = `Country: ${node.country}`; nodeData.color.background = '#34d399'; nodeData.country = node.country;
                        } else if (node.type === 'asn') {
                            if (!node.asn) return;
                            nodeData.label = node.asn; nodeData.title = `ASN: ${node.asn}`; nodeData.color.background = '#a3e635'; nodeData.asn = node.asn;
                        } else if (node.type === 'city') {
                            if (!node.city) return;
                            nodeData.label = node.city; nodeData.title = `City: ${node.city}`; nodeData.color.background = '#f97316'; nodeData.city = node.city;
                        } else if (node.type === 'vpn' || node.type === 'proxy' || node.type === 'tor' || node.type === 'relay' || node.type === 'hosting') {
                            if (!node.value) return;
                            nodeData.label = node.type.charAt(0).toUpperCase() + node.type.slice(1); 
                            nodeData.title = `${nodeData.label} for IP: ${node.value}`;
                            nodeData.color.background = { vpn: '#9333ea', proxy: '#f43f5e', tor: '#64748b', relay: '#eab308', hosting: '#14b8a6' }[node.type]; 
                            nodeData.value = node.value;
                        }
                        if (!nodes.get({ filter: n => n.type === nodeData.type && ((nodeData.ip && n.ip === nodeData.ip) || (nodeData.domain && n.domain === nodeData.domain) || (nodeData.organization && n.organization === nodeData.organization) || (nodeData.country && n.country === nodeData.country) || (nodeData.asn && n.asn === nodeData.asn) || (nodeData.city && n.city === nodeData.city) || (nodeData.value && n.value === nodeData.value) || (nodeData.name && n.name === nodeData.name && (!nodeData.email || n.email === nodeData.email)) || (nodeData.portNumber && nodeData.portType && n.portNumber === nodeData.portNumber && n.portType === nodeData.portType) || (nodeData.address && n.address === nodeData.address) || (nodeData.accountNumber && nodeData.sortCode && n.accountNumber === nodeData.accountNumber && n.sortCode === nodeData.sortCode) || (nodeData.techName && nodeData.techVersion && n.techName === nodeData.techName && n.techVersion === nodeData.techVersion) || (nodeData.deviceCategory && nodeData.deviceName && n.deviceCategory === nodeData.deviceCategory && n.deviceName === nodeData.deviceName) || (nodeData.malwareName && nodeData.malwareType && n.malwareName === nodeData.malwareName && n.malwareType === nodeData.malwareType)) }).length) nodes.add(nodeData);
                    });
                    importedData.edges.forEach(edge => { 
                        if (edge.from && edge.to && !edges.get({ filter: e => e.from === edge.from && e.to === edge.to && e.label === (edge.label || undefined) }).length) 
                            edges.add({ id: edge.id || `edge_${edge.from}_${edge.to}_${Date.now()}`, from: edge.from, to: edge.to, label: edge.label || undefined }); 
                    });
                    updateNodeSizes(); 
                    updateSelectOptions(); 
                    nextId = Math.max(...importedData.nodes.map(n => n.id)) + 1 || 1; 
                    fileInput.value = ''; 
                    stabilizeNetwork();
                    saveStateAfterOperation();
                } catch (e) { 
                    console.error('Error importing JSON:', e); 
                    showToast('Error importing JSON: ' + e.message, 'error'); 
                }
            };
            reader.readAsText(file);
        }

        document.addEventListener('keypress', event => {
            if (event.key === 'Enter') {
                event.preventDefault();
                const activeElement = document.activeElement;
                if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA')) {
                    const start = activeElement.selectionStart; 
                    const end = activeElement.selectionEnd; 
                    const value = activeElement.value;
                    activeElement.value = value.substring(0, start) + '\r\n' + value.substring(end);
                    activeElement.selectionStart = activeElement.selectionEnd = start + 2;
                }
            }
        });

        function toggleNodeLabels() {
    const showLabels = document.getElementById('showNodeLabels').checked;
    network.setOptions({
        nodes: {
            font: {
                size: showLabels ? 12 : 0  // Show labels with size 12 or hide by setting to 0
            },
            labelHighlightBold: showLabels
        }
    });
}

function toggleEdgeLabels() {
    const showLabels = document.getElementById('showEdgeLabels').checked;
    network.setOptions({
        edges: {
            font: {
                size: showLabels ? 12 : 0  // Show labels with size 12 or hide by setting to 0
            }
        }
    });
}

function toggleIsolatedNodes() {
    const hideIsolated = document.getElementById('hideIsolatedNodes').checked;
    
    // Get all nodes and their connections
    nodes.forEach(node => {
        const connections = edges.get({
            filter: edge => edge.from === node.id || edge.to === node.id
        });
        
        // Update node visibility based on whether it has connections
        nodes.update({
            id: node.id,
            hidden: hideIsolated && connections.length === 0
        });
    });
    
    // Stabilize network after visibility changes
    stabilizeNetwork().then(() => {
        network.fit({
            animation: {
                duration: 300,
                easingFunction: 'easeInOutQuad'
            }
        });
    });
    
    saveStateAfterOperation();
}

// Add this at the end of the script section
window.addEventListener('beforeunload', function() {
    saveState();
});
    </script>
</body>
</html>
