<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crime Mapper - Experimental</title>
    <style>

/* Properties Panel */
#properties-panel {
    position: fixed;
    right: -310px; /* Start offscreen on the right */
    top: 0;
    width: 300px;
    height: 100vh;
    background-color: #fff;
    box-shadow: -2px 0 10px rgba(0, 0, 0, 0.2); /* Shadow on left side */
    z-index: 2000; /* Ensure it’s above other elements */
    padding: 20px;
    overflow-y: auto;
    transition: right 0.3s ease-in-out; /* Transition right property */
    box-sizing: border-box;
}

.dark-mode #properties-panel {
    background-color: #2d3748;
    box-shadow: -2px 0 10px rgba(0, 0, 0, 0.4); /* Adjusted shadow direction */
    color: #e2e8f0;
}

#properties-panel.active {
    right: 0; /* Slide to the right edge */
}

/* Adjust close button positioning */
#properties-panel .close-button {
    position: absolute;
    top: 10px;
    right: 10px; /* Keep it on the right side */
    background: none;
    border: none;
    font-size: 18px;
    cursor: pointer;
    color: #1f2a44;
    transition: color 0.3s;
}

/* Remove or adjust conflicting layout rules */
#properties-panel.active ~ #controls:not(.collapsed) {
    left: 0; /* Don’t shift controls left; keep them in place */
}

#properties-panel.active ~ #controls.collapsed {
    left: 0; /* Don’t shift collapsed controls */
}

#properties-panel.active ~ #myNetwork {
    margin-right: 300px; /* Reduce right margin to make space */
    margin-left: 0; /* Reset left margin adjustment */
}

#properties-panel.active ~ #controls.collapsed ~ #myNetwork {
    margin-right: 300px; /* Adjust for collapsed controls */
    margin-left: 50px; /* Maintain left margin for collapsed controls */
}

/* Ensure controls panel adjusts when properties panel is open */
#controls {
    transition: left 0.3s ease-in-out, width 0.3s ease-in-out;
}

#controls.collapsed ~ #myNetwork {
    margin-left: 50px;
}

#controls:not(.collapsed) ~ #myNetwork {
    margin-left: 300px;
}

#properties-panel.active ~ #controls:not(.collapsed) {
    left: 300px; /* Shift controls right when properties panel is open */
}

#properties-panel.active ~ #controls.collapsed {
    left: 300px; /* Keep collapsed controls aligned */
}

#properties-panel.active ~ #myNetwork {
    margin-left: 350px; /* Account for both panels when expanded */
}

#properties-panel.active ~ #controls.collapsed ~ #myNetwork {
    margin-left: 350px; /* Adjust network margin when controls are collapsed */
}


#menu-toggle {
    padding: 6px 12px;
    background-color: #3b82f6;
    color: white;
    border: none;
    border-radius: 4px;
    font-size: 12px;
    cursor: pointer;
    transition: background-color var(--transition), transform var(--transition);
    width: 100%; /* Match other buttons */
    box-sizing: border-box;
    margin: 0;
}

#controls-footer { /* Adjusted selector */
    text-align: center;
    padding: 10px;
    font-size: 10px;
    margin-top: auto;
    transition: color var(--transition);
}

#controls.collapsed #menu-toggle {
    width: 100%; /* Ensure it fits the collapsed width */
    display: block; /* Always visible when collapsed */
}

.light-mode #menu-toggle {
    background-color: #3b82f6; /* Ensure light mode is blue */
}

#menu-toggle:hover {
    background-color: #2563eb; /* Darker blue for hover in light mode */
}

.dark-mode #menu-toggle:hover {
    background-color: #3b82f6; /* Slightly darker blue for hover in dark mode */
}
/* Specific styling for summary button to match other buttons */
#summary-button {
    padding: 6px 12px;
    background-color: #6b7280;
    color: white;
    border: none;
    border-radius: 4px;
    font-size: 12px;
    cursor: pointer;
    transition: background-color var(--transition);
    width: 100%; /* Makes it match the width of other buttons */
    box-sizing: border-box; /* Ensures padding doesn't affect width */
    margin: 0; /* Resets any unwanted margins */
}



/* Match dark mode styling with other buttons */
.dark-mode #summary-button {
    background-color: #9ca3af;
}

/* When controls are collapsed, hide summary button consistently */
#controls.collapsed #summary-button {
    display: none;
}

.light-mode #summary-button {
    background-color: #6b7280;
}

.dark-mode #summary-button {
    background-color: #9ca3af;
}



/* Modal styles */
#summary-modal {
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: #fff;
    padding: 20px;
    border-radius: 8px;
    box-shadow: var(--shadow-light);
    z-index: 2000;
    max-width: 500px;
    width: 90%;
    max-height: 80vh;
    overflow-y: auto;
}

.dark-mode #summary-modal {
    background-color: #2d3748;
    box-shadow: var(--shadow-dark);
    color: #e2e8f0;
}

#summary-modal table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 10px;
}

#summary-modal th, #summary-modal td {
    padding: 8px;
    text-align: left;
    border-bottom: 1px solid var(--border-light);
}

.dark-mode #summary-modal th, .dark-mode #summary-modal td {
    border-bottom: 1px solid var(--border-dark);
}

#summary-modal th {
    background-color: #f9fafb;
}

.dark-mode #summary-modal th {
    background-color: #374151;
}

#summary-modal .close-button {
    float: right;
    background: none;
    border: none;
    font-size: 16px;
    cursor: pointer;
    color: #1f2a44;
}

.dark-mode #summary-modal .close-button {
    color: #e2e8f0;
}

/* Ensure nodes maintain consistent size regardless of label */
#myNetwork .vis-network canvas {
    overflow: hidden; /* Prevent clipping issues */
}



.vis-network .vis-label {
    display: flex;
    justify-content: center;
    align-items: center;
    text-align: center;
    padding: 0;
    margin: 0;
    overflow: hidden;
    white-space: normal; /* Allow multi-line labels */
    max-width: 100%;     /* Keep within node bounds */
}

/* Optional: Adjust node appearance */
.vis-network .vis-node {
    min-width: 40px;    /* Minimum size to accommodate label */
    min-height: 40px;
    display: flex;
    justify-content: center;
    align-items: center;
}
.password-container {
    position: relative;
    width: 100%;
    margin-bottom: 8px;
}

.password-container input {
    padding-right: 60px; /* Make room for the toggle button */
}

.toggle-password {
    position: absolute;
    right: 5px;
    top: 50%;
    transform: translateY(-50%);
    padding: 2px 8px;
    background-color: #6b7280;
    color: white;
    border: none;
    border-radius: 4px;
    font-size: 10px;
    cursor: pointer;
    width: auto;
}

.light-mode .toggle-password {
    background-color: #6b7280;
}

.dark-mode .toggle-password {
    background-color: #9ca3af;
}

.toggle-password:hover {
    background-color: #4b5563;
}

#stop-task {
    padding: 6px 12px;
    background-color: #dc2626; /* Red color */
    color: white;
    border: none;
    border-radius: 4px;
    font-size: 12px;
    cursor: pointer;
    transition: background-color var(--transition);
    width: auto;
    margin: 0 auto;
    display: inline-block;
}

#stop-task:hover {
    background-color: #b91c1c; /* Darker red on hover */
}

#stop-task:disabled {
    background-color: #9ca3af;
    cursor: not-allowed;
}

        :root {
            --transition: 0.3s;
            --shadow-light: 0 2px 10px rgba(0, 0, 0, 0.1);
            --shadow-dark: 0 2px 10px rgba(0, 0, 0, 0.3);
            --border-light: #d1d5db;
            --border-dark: #4b5563;
        }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 0; display: flex; height: 100vh; font-size: 12px; transition: background-color var(--transition), color var(--transition); }
        body.light-mode { background-color: #f0f2f5; color: #1f2a44; }
        body.dark-mode { background-color: #1e293b; color: #e2e8f0; }
       

/* Controls container */
#controls {
    transition: width var(--transition);
    position: fixed;
    left: 0;
    top: 0;
    height: 100vh;
    z-index: 1000;
    display: flex;
    flex-direction: column;
    overflow-y: auto; /* Allow scrolling if content overflows */
}

#controls.collapsed {
    width: 50px;
}

#controls:not(.collapsed) {
    width: 300px;
}

#controls-header {
    padding: 10px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    align-items: stretch;
}



/* Menu toggle button */
#menu-toggle {
  
    transition: transform var(--transition);
}



/* Top buttons - no absolute positioning */
#mode-toggle, #pause-toggle, #reset-layout, #summary-button {
    padding: 6px 12px;
    background-color: #6b7280;
    color: white;
    border: none;
    border-radius: 4px;
    font-size: 12px;
    cursor: pointer;
    transition: background-color var(--transition);
    width: 100%; /* Full width for consistency */
    box-sizing: border-box;
    margin: 0; /* Prevent unwanted margins */
}
/* Hover states */
#mode-toggle:hover, #pause-toggle:hover, #reset-layout:hover, #summary-button:hover {
    background-color: #4b5563;
}

/* Dark mode states */
.dark-mode #mode-toggle,
.dark-mode #pause-toggle,
.dark-mode #reset-layout,
.dark-mode #summary-button {
    background-color: #9ca3af;
}

/* Paused state for pause-toggle */
#pause-toggle.paused {
    background-color: #ef4444;
}

/* Hide all but menu-toggle when collapsed */
#controls.collapsed #mode-toggle,
#controls.collapsed #pause-toggle,
#controls.collapsed #reset-layout,
#controls.collapsed #summary-button,
#controls.collapsed .tab-buttons,
#controls.collapsed .tab-content,
#controls.collapsed #footer {
    display: none;
}
.light-mode #pause-toggle, .light-mode #reset-layout {
    background-color: #6b7280;
}

.dark-mode #pause-toggle, .dark-mode #reset-layout {
    background-color: #9ca3af;
}

#pause-toggle.paused {
    background-color: #ef4444;
}

/* Hide buttons when collapsed, except menu toggle */
#controls.collapsed #mode-toggle,
#controls.collapsed #pause-toggle,
#controls.collapsed #reset-layout,
#controls.collapsed .tab-buttons,
#controls.collapsed .tab-content,
#controls.collapsed #footer {
    display: none;
}

/* Tab buttons and content */
.tab-buttons {
    display: flex;
    flex-wrap: wrap;
    border-bottom: 1px solid var(--border-light);
    transition: border-color var(--transition);
    margin-top: 10px; /* Small margin after header */
}

.tab-content {
    padding: 15px;
    display: none;
    flex-grow: 1;
}

.tab-content.active {
    display: block;
}

/* Network margin */
#myNetwork {
    transition: margin-left var(--transition);
}

#controls.collapsed ~ #myNetwork {
    margin-left: 50px;
}

#controls:not(.collapsed) ~ #myNetwork {
    margin-left: 300px;
}

/* Media query for mobile */
@media (max-width: 768px) {
    #controls:not(.collapsed) {
        width: 100%;
    }
    
    #controls:not(.collapsed) ~ #myNetwork {
        margin-left: 0;
        display: none;
    }
    
    #controls.collapsed ~ #myNetwork {
        margin-left: 50px;
        display: block;
    }
}


/* Hide content when collapsed except for toggle button */
#controls.collapsed > *:not(#menu-toggle) {
    display: none;
}

/* Adjust button positions when expanded */
#controls:not(.collapsed) #mode-toggle {
    top: 50px;
}

#controls:not(.collapsed) #pause-toggle {
    top: 80px;
}

#controls:not(.collapsed) #reset-layout {
    top: 110px;
}


        #myNetwork { flex-grow: 1; height: 100%; border-radius: 0 8px 8px 0; box-shadow: var(--shadow-light); transition: background-color var(--transition); }
        .light-mode #myNetwork { background-color: #fff; }
        .dark-mode #myNetwork { background-color: #334155; box-shadow: var(--shadow-dark); }
        .tab-buttons { display: flex; flex-wrap: wrap; border-bottom: 1px solid var(--border-light); transition: border-color var(--transition); padding-top: 100px; }
        .dark-mode .tab-buttons { border-bottom: 1px solid var(--border-dark); }
        .tab-button { flex: 1 0 14.28%; padding: 10px; text-align: center; border: none; cursor: pointer; transition: background-color var(--transition), color var(--transition); font-size: 10px; }
        .light-mode .tab-button { background-color: #f9fafb; color: #1f2a44; }
        .dark-mode .tab-button { background-color: #374151; color: #e2e8f0; }
        .tab-button.active { font-weight: bold; }
        .light-mode .tab-button.active { background-color: #fff; border-bottom: 2px solid #3b82f6; }
        .dark-mode .tab-button.active { background-color: #2d3748; border-bottom: 2px solid #60a5fa; }
        .light-mode .tab-button:hover:not(.active) { background-color: #e5e7eb; }
        .dark-mode .tab-button:hover:not(.active) { background-color: #4b5563; }
        .tab-content { padding: 15px; display: none; flex-grow: 1; }
        .tab-content.active { display: block; }
        .input-group { margin: 15px 0; padding: 10px; border-radius: 6px; transition: background-color var(--transition); }
        .light-mode .input-group { background-color: #f9fafb; }
        .dark-mode .input-group { background-color: #374151; }
        .input-group h3 { margin: 0 0 8px 0; font-size: 14px; }
        .light-mode .input-group h3 { color: #1f2a44; }
        .dark-mode .input-group h3 { color: #e2e8f0; }
        input, select, textarea { margin: 4px 0; padding: 6px 10px; border-radius: 4px; font-size: 12px; transition: border-color var(--transition), background-color var(--transition), color var(--transition); width: 100%; box-sizing: border-box; }
        .light-mode input, .light-mode select, .light-mode textarea { border: 1px solid var(--border-light); background-color: #fff; color: #1f2a44; }
        .dark-mode input, .dark-mode select, .dark-mode textarea { border: 1px solid var(--border-dark); background-color: #4b5563; color: #e2e8f0; }
        textarea { height: 100px; resize: vertical; }
        button { padding: 6px 12px; border: none; border-radius: 4px; font-size: 12px; cursor: pointer; transition: background-color var(--transition), color var(--transition); width: 100%; margin: 4px 0; }
        .light-mode button { background-color: #3b82f6; color: white; }
        .dark-mode button { background-color: #60a5fa; color: #1e293b; }
        #mode-toggle { position: absolute; top: 10px; right: 10px; padding: 6px 12px; background-color: #6b7280; color: white; border: none; border-radius: 4px; font-size: 12px; cursor: pointer; }
        #pause-toggle { position: absolute; top: 40px; right: 10px; padding: 6px 12px; background-color: #6b7280; color: white; border: none; border-radius: 4px; font-size: 12px; cursor: pointer; transition: background-color var(--transition); }
        .light-mode #pause-toggle { background-color: #6b7280; }
        .dark-mode #pause-toggle { background-color: #9ca3af; }
        #pause-toggle.paused { background-color: #ef4444; }
        #reset-layout { position: absolute; top: 70px; right: 10px; padding: 6px 12px; background-color: #6b7280; color: white; border: none; border-radius: 4px; font-size: 12px; cursor: pointer; transition: background-color var(--transition); }
        .light-mode #reset-layout { background-color: #6b7280; }
        .dark-mode #reset-layout { background-color: #9ca3af; }
        #footer { text-align: center; padding: 10px; font-size: 10px; margin-top: auto; transition: color var(--transition); }
        .light-mode #footer { color: #6b7280; }
        .dark-mode #footer { color: #94a3b8; }
        #contextMenu { position: absolute; background-color: #fff; border: 1px solid #ccc; box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2); z-index: 1000; padding: 5px 0; }
        #contextMenu button { display: block; width: 100%; text-align: left; padding: 5px 10px; background: none; border: none; cursor: pointer; }
        #contextMenu button:hover { background-color: #f0f0f0; }
        .light-mode #contextMenu button { 
    color: #1f2a44 !important; 
}
.light-mode #contextMenu button:hover { 
    color: #1f2a44 !important; 
    background-color: #f0f0f0; 
}
        .dark-mode #contextMenu { background-color: #2d3748; border: 1px solid var(--border-dark); }
        .dark-mode #contextMenu button { color: #e2e8f0; }
        .dark-mode #contextMenu button:hover { background-color: #4b5563; }
        .checkbox-label { display: flex; align-items: center; margin: 4px 0; font-size: 12px; }
        .light-mode .checkbox-label { color: #1f2a44; }
        .dark-mode .checkbox-label { color: #e2e8f0; }
        input[type="checkbox"] { margin-right: 8px; width: auto; }
        #edgeContextMenu {
    position: absolute;
    background-color: #fff;
    border: 1px solid #ccc;
    box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2);
    z-index: 1000;
    padding: 5px 0;
}

#edgeContextMenu button {
    display: block;
    width: 100%;
    text-align: left;
    padding: 5px 10px;
    background: none;
    border: none;
    cursor: pointer;
}

#edgeContextMenu button:hover {
    background-color: #f0f0f0;
}

.light-mode #edgeContextMenu {
    background-color: #fff;
}

.light-mode #edgeContextMenu button {
    color: #1f2a44 !important;
}

.light-mode #edgeContextMenu button:hover {
    color: #1f2a44 !important;
    background-color: #f0f0f0;
}

.dark-mode #edgeContextMenu {
    background-color: #2d3748;
    border: 1px solid var(--border-dark);
}

.dark-mode #edgeContextMenu button {
    color: #e2e8f0;
}

.dark-mode #edgeContextMenu button:hover {
    background-color: #4b5563;
}

#search-input {
    padding: 6px 10px;
    border-radius: 4px;
    border: 1px solid var(--border-light);
    background-color: #fff;
    color: #1f2a44;
    transition: border-color var(--transition);
}

.dark-mode #search-input {
    border: 1px solid var(--border-dark);
    background-color: #4b5563;
    color: #e2e8f0;
}

#search-input:focus {
    outline: none;
    border-color: #3b82f6;
}

/* Progress Bar Styles */
#progress-bar {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    padding: 10px;
    text-align: center;
    color: white;
    font-size: 14px;
    font-weight: bold;
    z-index: 2000;
    transition: opacity 0.5s ease-in-out;
}

.progress-active {
    background-color: #dc2626; /* Red for in progress */
}

.progress-complete {
    background-color: #22c55e; /* Green for complete */
}

.progress-hidden {
    opacity: 0;
    pointer-events: none;
}
</style>

    <script src="https://cdn.jsdelivr.net/npm/vis-network@9.1.9/dist/vis-network.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/toastify-js/1.12.0/toastify.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/toastify-js/1.12.0/toastify.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
</head>
<body class="dark-mode">
        <div id="progress-bar" class="progress-hidden">Task in progress...</div>
        <!-- Rest of your HTML -->

    <div id="controls">
        <button id="menu-toggle" onclick="toggleMenu()" title="Toggle Menu">></button>
        <button id="mode-toggle" onclick="toggleMode()">Switch to Light Mode</button>
        <button id="pause-toggle" onclick="togglePhysics()">Pause Physics</button>
        <button id="reset-layout" onclick="resetLayout()">Reset Layout</button>
        <div class="tab-buttons">
            <button class="tab-button" onclick="showTab('object-management')">Object Management</button>
            <button class="tab-button" onclick="showTab('link-management')">Link Management</button>
            <button class="tab-button" onclick="showTab('import-export')">Import/Export</button>
            <button class="tab-button" onclick="showTab('api-keys')">Config</button>
            <button class="tab-button" onclick="showTab('enrichment')">Enrichment</button>
            <button class="tab-button active" onclick="showTab('import-iocs')">Import IOCs</button>
            <button class="tab-button" onclick="showTab('layouts')">Layouts</button>
            <button class="tab-button" onclick="showTab('search')">Search</button>
        </div>
        <div id="object-management" class="tab-content">
            <div class="input-group">
                <h3>Add Entity</h3>
                <select id="addEntityType">
                    <option value="contact">Contact</option>
                    <option value="ip">IP Address</option>
                    <option value="domain">Domain</option>
                    <option value="organization">Organization</option>
                    <option value="port">Port</option>
                    <option value="wallet">Wallet</option>
                    <option value="bank">Bank Account</option>
                    <option value="technology">Technology</option>
                    <option value="device">Device</option>
                    <option value="malware">Malware</option>
                    <option value="vulnerability">Vulnerability</option>
                </select>
                <input type="text" id="addVulnNameInput" placeholder="Vulnerability Name" style="display: none;">
                <input type="text" id="addVulnCVEInput" placeholder="CVE (optional)" style="display: none;">
                <input type="text" id="addVulnUrlInput" placeholder="URL (optional)" style="display: none;">
                <input type="text" id="addNameInput" placeholder="Name">
                <input type="email" id="addEmailInput" placeholder="Email (optional)">
                <input type="text" id="addIpInput" placeholder="IP Address" style="display: none;">
                <input type="text" id="addDomainInput" placeholder="Domain" style="display: none;">
                <input type="text" id="addOrgInput" placeholder="Organization Name" style="display: none;">
                <input type="text" id="addPortNumInput" placeholder="Port Number" style="display: none;">
                <select id="addPortType" style="display: none;">
                    <option value="TCP">TCP</option>
                    <option value="UDP">UDP</option>
                </select>
                <input type="text" id="addWalletAddressInput" placeholder="Wallet Address" style="display: none;">
                <input type="text" id="addAccountNumberInput" placeholder="Account Number" style="display: none;">
                <input type="text" id="addSortCodeInput" placeholder="Sort Code" style="display: none;">
                <input type="text" id="addTechNameInput" placeholder="Technology Name" style="display: none;">
                <input type="text" id="addTechVersionInput" placeholder="Version" style="display: none;">
                <select id="addDeviceCategory" style="display: none;">
                    <option value="Server">Server</option>
                    <option value="PC">PC</option>
                    <option value="Laptop">Laptop</option>
                    <option value="MAC">MAC</option>
                    <option value="SmartPhone">SmartPhone</option>
                    <option value="IOT">IOT</option>
                    <option value="Router">Router</option>
                    <option value="Switch">Switch</option>
                    <option value="Wireless Access Point">Wireless Access Point</option>
                    <option value="Other">Other</option>
                </select>
                <input type="text" id="addDeviceNameInput" placeholder="Device Name" style="display: none;">
                <input type="text" id="addMalwareNameInput" placeholder="Malware Name" style="display: none;">
                <select id="addMalwareType" style="display: none;">
                    <option value="Wiper">Wiper</option>
                    <option value="RAT">RAT</option>
                    <option value="Encryptor">Encryptor</option>
                    <option value="Stealer">Stealer</option>
                    <option value="Other">Other</option>
                </select>
                <button onclick="addNode()">Add Entity</button>
            </div>
            <div class="input-group">
                <h3>Edit Entity</h3>
                <select id="editNodeSelect" onchange="loadNodeForEdit()"></select>
                <select id="editEntityType" disabled>
                    <option value="contact">Contact</option>
                    <option value="ip">IP Address</option>
                    <option value="domain">Domain</option>
                    <option value="organization">Organization</option>
                    <option value="port">Port</option>
                    <option value="wallet">Wallet</option>
                    <option value="bank">Bank Account</option>
                    <option value="technology">Technology</option>
                    <option value="device">Device</option>
                    <option value="malware">Malware</option>
                    <option value="vulnerability">Vulnerability</option>
                </select>
                <input type="text" id="editVulnNameInput" placeholder="Vulnerability Name" style="display: none;">
                <input type="text" id="editVulnCVEInput" placeholder="CVE (optional)" style="display: none;">
                <input type="text" id="editVulnUrlInput" placeholder="URL (optional)" style="display: none;">
                <input type="text" id="editNameInput" placeholder="Name">
                <input type="email" id="editEmailInput" placeholder="Email (optional)">
                <input type="text" id="editIpInput" placeholder="IP Address" style="display: none;">
                <input type="text" id="editDomainInput" placeholder="Domain" style="display: none;">
                <input type="text" id="editOrgInput" placeholder="Organization Name" style="display: none;">
                <input type="text" id="editPortNumInput" placeholder="Port Number" style="display: none;">
                <select id="editPortType" style="display: none;">
                    <option value="TCP">TCP</option>
                    <option value="UDP">UDP</option>
                </select>
                <input type="text" id="editWalletAddressInput" placeholder="Wallet Address" style="display: none;">
                <input type="text" id="editAccountNumberInput" placeholder="Account Number" style="display: none;">
                <input type="text" id="editSortCodeInput" placeholder="Sort Code" style="display: none;">
                <input type="text" id="editTechNameInput" placeholder="Technology Name" style="display: none;">
                <input type="text" id="editTechVersionInput" placeholder="Version" style="display: none;">
                <select id="editDeviceCategory" style="display: none;">
                    <option value="Server">Server</option>
                    <option value="PC">PC</option>
                    <option value="Laptop">Laptop</option>
                    <option value="MAC">MAC</option>
                    <option value="SmartPhone">SmartPhone</option>
                    <option value="IOT">IOT</option>
                    <option value="Router">Router</option>
                    <option value="Switch">Switch</option>
                    <option value="Wireless Access Point">Wireless Access Point</option>
                    <option value="Other">Other</option>
                </select>
                <input type="text" id="editDeviceNameInput" placeholder="Device Name" style="display: none;">
                <input type="text" id="editMalwareNameInput" placeholder="Malware Name" style="display: none;">
                <select id="editMalwareType" style="display: none;">
                    <option value="Wiper">Wiper</option>
                    <option value="RAT">RAT</option>
                    <option value="Encryptor">Encryptor</option>
                    <option value="Stealer">Stealer</option>
                    <option value="Other">Other</option>
                </select>
                <button onclick="editNode()">Save Changes</button>
            </div>
            <div class="input-group">
                <h3>Remove Entity</h3>
                <select id="removeNode"></select>
                <button onclick="removeNode()">Remove Entity</button>
            </div>
        </div>
        <div id="link-management" class="tab-content">
            <div class="input-group">
                <h3>Create Link</h3>
                <select id="fromNode"></select>
                <select id="toNode"></select>
                <input type="text" id="edgeLabel" placeholder="Link Label">
                <button onclick="addEdge()">Add Link</button>
            </div>
            <div class="input-group">
                <h3>Remove Link</h3>
                <select id="removeEdge"></select>
                <button onclick="removeEdge()">Remove Link</button>
            </div>
        </div>
        <div id="import-export" class="tab-content">
            <div class="input-group">
                <h3>Export/Import</h3>
                <button onclick="exportGraph()">Export to JSON</button>
                <input type="file" id="importFile" accept=".json">
                <button onclick="importGraph()">Import from JSON</button>
                <button onclick="clearGraph()">Clear Graph</button>
                <button id="summary-button" onclick="showGraphSummary()">Graph Summary</button>
                <button onclick="exportToPNG()">Export to PNG</button>
                <button onclick="exportToPDF()">Export to PDF</button>
            </div>
        </div>
        <div id="api-keys" class="tab-content">
            <div class="input-group">
                <h3>IPINFO API Key</h3>
                <div class="password-container">
                    <input type="password" id="ipinfoApiKey" placeholder="Enter IPinfo API Key">
                    <button type="button" class="toggle-password" data-target="ipinfoApiKey">Show</button>
                </div>
                <label class="checkbox-label">
                    <input type="checkbox" id="storeIpinfoKey"> Store in local storage
                </label>
                <button onclick="saveIpinfoApiKey()">Save IPinfo API Key</button>
            </div>
            <div class="input-group">
                <h3>Shodan API Key</h3>
                <div class="password-container">
                    <input type="password" id="shodanApiKey" placeholder="Enter Shodan API Key">
                    <button type="button" class="toggle-password" data-target="shodanApiKey">Show</button>
                </div>
                <label class="checkbox-label">
                    <input type="checkbox" id="storeShodanKey"> Store in local storage
                </label>
                <button onclick="saveShodanApiKey()">Save Shodan API Key</button>
            </div>
            <div class="input-group">
                <h3>CORS Proxy URL</h3>
                <div class="password-container">
                    <input type="password" id="corsProxyUrl" placeholder="Enter CORS Proxy URL" value="https://cors-anywhere.herokuapp.com/">
                    <button type="button" class="toggle-password" data-target="corsProxyUrl">Show</button>
                </div>
                <label class="checkbox-label">
                    <input type="checkbox" id="storeCorsProxy" checked> Store in local storage
                </label>
                <label class="checkbox-label">
                    <input type="checkbox" id="routeViaProxy"> Route all traffic via proxy
                </label>
                <label class="checkbox-label">
                    <input type="checkbox" id="ignoreApiKeysViaProxy"> Ignore API keys when using proxy
                </label>
                <button onclick="saveCorsProxyUrl()">Save CORS Proxy URL</button>
            </div>
            <div class="input-group">
                <h3>Test Functions</h3>
                <button onclick="runAllTests()">Run Test Functions</button>
            </div>
        </div>
        <div id="enrichment" class="tab-content">
            <div class="input-group">
                <h3>Bulk Enrichment</h3>
                <button onclick="enrichAllIpinfo()">Enrich All IPs with IPinfo</button>
                <button onclick="enrichAllShodan()">Enrich All IPs with Shodan</button>
                <button onclick="enrichAllInternetDB()">Enrich All IPs with InternetDB</button>
                <button onclick="enrichAllGoogleDNS()">Enrich All Domains with Google DNS</button>
            </div>
        </div>
        <div id="import-iocs" class="tab-content active">
            <div class="input-group">
                <h3>Import IOCs</h3>
                <textarea id="iocText" placeholder="Paste IOC text here (IPs, domains, emails)"></textarea>
                <button onclick="importIOCsFromText()">Import from Text</button>
                <input type="file" id="iocFile" accept=".txt">
                <button onclick="importIOCsFromFile()">Import from File</button>
            </div>
        </div>
        <div id="search" class="tab-content">
            
            <div class="input-group" style="margin: 10px 0;">
                <input type="text" id="search-input" placeholder="Search graph..." style="width: 100%; margin-bottom: 5px;">
                <button onclick="searchGraph()" style="background-color: #10b981;">Search</button>
            </div>
        
        </div>
        <div id="layouts" class="tab-content">
            <div class="input-group">
                <h3>Graph Layouts</h3>
                <!-- Existing layout buttons remain here -->
                <button onclick="setOrganicLayout()">Organic</button>
                <button onclick="setCircularLayout()">Circular</button>
                <button onclick="setOrthogonalLayout()">Orthogonal</button>
                <button onclick="setTreeLayout()">Tree</button>
                <button onclick="setHierarchicalLayout()">Hierarchical</button>
            </div>
            <!-- New section for label visibility -->
            <div class="input-group">
                <h3>Label Visibility</h3>
                <label class="checkbox-label">
                    <input type="checkbox" id="showNodeLabels" checked onchange="toggleNodeLabels()">
                    Show Node Labels
                </label>
                <label class="checkbox-label">
                    <input type="checkbox" id="showEdgeLabels" checked onchange="toggleEdgeLabels()">
                    Show Edge Labels
                </label>
                <label class="checkbox-label">
                    <input type="checkbox" id="hideIsolatedNodes" onchange="toggleIsolatedNodes()">
                    Hide Nodes Without Links
                </label>
            </div>
            <div class="input-group">
                <h3>Node Size Layouts</h3>
                <button onclick="setNodeSizeLayout('incoming')">Size by Incoming Links</button>
                <button onclick="setNodeSizeLayout('outgoing')">Size by Outgoing Links</button>
                <button onclick="setNodeSizeLayout('both')">Size by All Links</button>
            </div>
            <div class="input-group">
                <h3>Filter Display</h3>
                <button onclick="filterIpAndDomains()">Show Only IPs & Domains</button>
                <button onclick="showAllNodes()">Show All Nodes</button>
            </div>
        </div>
         <!-- Buy Me a Coffee Button -->
         <div style="text-align: center; padding: 10px;">
            <script type="text/javascript" src="https://cdnjs.buymeacoffee.com/1.0.0/button.prod.min.js" 
                data-name="bmc-button" 
                data-slug="mrr3b00t" 
                data-color="#FFDD00" 
                data-emoji=""  
                data-font="Cookie" 
                data-text="Buy me a coffee" 
                data-outline-color="#000000" 
                data-font-color="#000000" 
                data-coffee-color="#ffffff">
            </script>
        </div>

        <button id="manual-save" onclick="saveStateAfterOperation()">Save Now</button>

        <div style="text-align: center; padding: 10px;">
            <button id="stop-task" onclick="stopActiveTask()">Stop Active Task</button>
        </div>

        <!-- Suggested -->
        <footer id="controls-footer"> 
    <p>Created by mrr3b00t (@UK_Daniel_Card)</p>
    <p>© Xservus Limited - v0.266 experimental</p>
</footer>
    </div>
    <div id="myNetwork"></div>
    <div id="summary-modal">
        <button class="close-button" onclick="hideGraphSummary()">×</button>
        <h3>Graph Summary</h3>
        <table id="summary-table">
            <thead>
                <tr>
                    <th>Type</th>
                    <th>Count</th>
                </tr>
            </thead>
            <tbody></tbody>
        </table>
    </div>
    <div id="properties-panel">
        <button class="close-button" onclick="hidePropertiesPanel()">×</button>
        <h3>Node Properties</h3>
        <table id="properties-table">
            <thead>
                <tr>
                    <th>Property</th>
                    <th>Value</th>
                </tr>
            </thead>
            <tbody></tbody>
        </table>
    </div>
    <div id="contextMenu" style="display: none;"></div>
    <div id="edgeContextMenu" style="display: none;"></div>

<script>
        let routeViaProxy = false;
        let ignoreApiKeysViaProxy = false;
        let nodes = new vis.DataSet([]);
        let edges = new vis.DataSet([]);
        let nextId = 1;
        let isDarkMode = true;
        let ipinfoApiKey = '';
        let shodanApiKey = '';
        let corsProxyUrl = 'https://cors-anywhere.herokuapp.com/'; // Default value
        let isPhysicsPaused = false;
        let lastRequestTime = 0;
        let activeTaskController = null;
        let nodeLabelsVisible = true;
        let edgeLabelsVisible = true;
        const RATE_LIMIT_MS = 500;
        const SHODAN_RATE_LIMIT_MS = 1000; // Specific 1-second delay for Shodan
        const ipRegex = { ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/, ipv6: /^([0-9a-fA-F]{0,4}:){7}[0-9a-fA-F]{0,4}$/ };
        const domainRegex = /^(?!:\/\/)([a-zA-Z0-9-_]+\.)*[a-zA-Z0-9][a-zA-Z0-9-_]+\.[a-zA-Z]{2,}$/;
        const emailRegex = /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g;

        let selectedNodes = new Set(); // To track multiple selected nodes


        function searchGraph() {
    const searchTerm = document.getElementById('search-input').value.trim().toLowerCase();
    if (!searchTerm) {
        showToast('Please enter a search term', 'error');
        resetNodeHighlights();
        return;
    }

    // Reset previous highlights
    resetNodeHighlights();

    // Find matching nodes
    const matchingNodes = nodes.get().filter(node => {
        // Search in label, and type-specific fields
        const searchableText = [
            node.label || '',
            node.ip || '',
            node.domain || '',
            node.email || '',
            node.name || '',
            node.organization || '',
            node.portNumber || '',
            node.address || '',
            node.accountNumber || '',
            node.techName || '',
            node.deviceName || '',
            node.malwareName || '',
            node.vulnName || '',
            node.cve || '',
            node.hash || '',
            node.asn || '',
            node.city || '',
            node.country || '',
            node.os || '',
            node.product || ''
        ].join(' ').toLowerCase();

        return searchableText.includes(searchTerm);
    });

    if (matchingNodes.length === 0) {
        showToast('No matches found', 'info');
        return;
    }

    // Highlight matching nodes
    matchingNodes.forEach(node => {
        nodes.update({
            id: node.id,
            color: {
                background: '#ffeb3b', // Bright yellow for highlight
                border: '#f44336',     // Red border for visibility
                highlight: {
                    background: '#ffeb3b',
                    border: '#f44336'
                }
            },
            font: {
                size: 14,  // Slightly larger font for visibility
                color: '#000000'  // Black text for contrast
            }
        });
    });

    // Zoom to the first matching node
    const firstMatchId = matchingNodes[0].id;
    network.focus(firstMatchId, {
        scale: 1.5,  // Zoom in
        animation: {
            duration: 1000,
            easingFunction: 'easeInOutQuad'
        }
    });

    showToast(`Found ${matchingNodes.length} matching nodes`, 'success');
}

function resetNodeHighlights() {
    nodes.forEach(node => {
        // Restore original colors based on node type
        const originalColor = getNodeColorByType(node.type);
        nodes.update({
            id: node.id,
            color: {
                background: originalColor.background,
                border: isDarkMode ? '#94a3b8' : '#6b7280',
                highlight: {
                    background: originalColor.background,
                    border: '#60a5fa'
                }
            },
            font: {
                size: nodeLabelsVisible ? 12 : 0,
                color: isDarkMode ? '#e2e8f0' : '#1f2a44'
            }
        });
    });
    network.fit({
        animation: {
            duration: 500,
            easingFunction: 'easeInOutQuad'
        }
    });
}

function exportToPNG() {
    network.setOptions({ physics: { enabled: false } });
    network.stabilize(100);
    network.fit(); // Zoom to fit all nodes
    
    setTimeout(() => {
        try {
            const canvas = document.querySelector('#myNetwork .vis-network canvas');
            if (!canvas) throw new Error('Canvas not found');
            
            const dataURL = canvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.href = dataURL;
            link.download = `network_graph_${new Date().toISOString().replace(/[:.]/g, '-')}.png`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            showToast('Graph exported as PNG', 'success');
        } catch (error) {
            console.error('Error exporting to PNG:', error);
            showToast('Failed to export graph as PNG: ' + error.message, 'error');
        } finally {
            network.setOptions({ physics: { enabled: !isPhysicsPaused } });
        }
    }, 500);
}


function filterIpAndDomains() {
    // Disable physics during filtering
    network.setOptions({ physics: { enabled: false } });
    
    // Update each node's hidden property based on type
    nodes.forEach(node => {
        const shouldHide = node.type !== 'ip' && node.type !== 'domain';
        nodes.update({
            id: node.id,
            hidden: shouldHide
        });
    });
    
    // Hide edges connected to hidden nodes
    edges.forEach(edge => {
        const fromNode = nodes.get(edge.from);
        const toNode = nodes.get(edge.to);
        const shouldHide = fromNode.hidden || toNode.hidden;
        edges.update({
            id: edge.id,
            hidden: shouldHide
        });
    });
    
    // Stabilize and fit the network
    stabilizeNetwork().then(() => {
        network.fit({
            animation: {
                duration: 300,
                easingFunction: 'easeInOutQuad'
            }
        });
        showToast('Showing only IP addresses and domains', 'success');
        saveStateAfterOperation();
    });
}

function showAllNodes() {
    // Disable physics during filtering
    network.setOptions({ physics: { enabled: false } });
    
    // Show all nodes and edges
    nodes.forEach(node => {
        nodes.update({
            id: node.id,
            hidden: false
        });
    });
    
    edges.forEach(edge => {
        edges.update({
            id: edge.id,
            hidden: false
        });
    });
    
    // Stabilize and fit the network
    stabilizeNetwork().then(() => {
        network.fit({
            animation: {
                duration: 300,
                easingFunction: 'easeInOutQuad'
            }
        });
        showToast('Showing all nodes and edges', 'success');
        saveStateAfterOperation();
    });
}

// Helper function to get original colors by node type
function getNodeColorByType(type) {
    const colorMap = {
        'ip': '#f87171',
        'domain': '#60a5fa',
        'contact': '#4ade80',
        'organization': '#facc15',
        'port': '#a78bfa',
        'wallet': '#fb923c',
        'bank': '#10b981',
        'technology': '#ec4899',
        'device': '#14b8a6',
        'malware': '#ef4444',
        'vulnerability': '#dc2626',
        'favicon': '#22d3ee',
        'http_hash': '#f97316',
        'html_hash': '#f59e0b',
        'ssl_hash': '#8b5cf6',
        'asn': '#a3e635',
        'city': '#f97316',
        'country': '#34d399',
        'os': '#10b981',
        'product': '#ec4899',
        'http_title': '#3b82f6',
        'vpn': '#9333ea',
        'proxy': '#f43f5e',
        'tor': '#64748b',
        'relay': '#eab308',
        'hosting': '#14b8a6',
        'tag': '#6d28d9',
        'cpe': '#0d9488'
    };
    return { background: colorMap[type] || '#ffffff' };
}

// Add this with your other event listeners
document.getElementById('search-input').addEventListener('keypress', function(event) {
    if (event.key === 'Enter') {
        event.preventDefault();
        searchGraph();
    }
});


        async function enrichAllIpinfo() {
    if (!ipinfoApiKey && !ignoreApiKeysViaProxy) { 
        showToast('Please set your IPinfo API key in the "API Keys" tab first.', 'error'); 
        return; 
    }
    
    showProgressBar();
    network.setOptions({ physics: { enabled: false } });
    const ipNodes = nodes.get({ filter: n => n.type === 'ip' && n.ip });
    const totalIPs = ipNodes.length;
    let successfulEnrichments = 0;
    
    const batchSize = 50;
    const delayBetweenBatches = 200;
    const totalBatches = Math.ceil(totalIPs / batchSize);
    const assumedRequestTimeMs = 100;
    const timePerBatchMs = assumedRequestTimeMs;
    const totalBatchDelays = (totalBatches - 1) * delayBetweenBatches;
    const estimatedTimeMs = (timePerBatchMs * totalBatches) + totalBatchDelays + 1000;
    
    const estimatedSeconds = Math.ceil(estimatedTimeMs / 1000);
    const estimatedMinutes = Math.floor(estimatedSeconds / 60);
    const remainingSeconds = estimatedSeconds % 60;
    const timeEstimateStr = estimatedMinutes > 0 
        ? `${estimatedMinutes}m ${remainingSeconds}s` 
        : `${estimatedSeconds}s`;
    
    showToast(`Estimated time for IPinfo enrichment: ~${timeEstimateStr}`, 'info');
    document.getElementById('progress-bar').textContent = `IPinfo Enrichment: 0/${totalIPs} IPs (0%) - Est. ${timeEstimateStr}`;
    
    const newNodes = [];
    const newEdges = [];
    let existingAsns = new Map(nodes.get({ filter: n => n.type === 'asn' }).map(n => [n.asn, n.id]));
    let existingCities = new Map(nodes.get({ filter: n => n.type === 'city' }).map(n => [n.city, n.id]));
    let existingOrgs = new Map(nodes.get({ filter: n => n.type === 'organization' }).map(n => [n.organization, n.id]));
    let existingCountries = new Map(nodes.get({ filter: n => n.type === 'country' }).map(n => [n.country, n.id]));
    let existingPrivacyTypes = new Map([
        ['vpn', null], ['proxy', null], ['tor', null], ['relay', null], ['hosting', null]
    ].map(([type]) => {
        const existing = nodes.get({ filter: n => n.type === type })[0];
        return [type, existing ? existing.id : null];
    }));

    const privacyTypes = [
        { key: 'vpn', label: 'VPN', color: '#9333ea' },
        { key: 'proxy', label: 'Proxy', color: '#f43f5e' },
        { key: 'tor', label: 'Tor', color: '#64748b' },
        { key: 'relay', label: 'Relay', color: '#eab308' },
        { key: 'hosting', label: 'Hosting', color: '#14b8a6' }
    ];

    async function processBatch(batch) {
        const promises = batch.map(node => {
            if (activeTaskController && activeTaskController.signal.aborted) {
                return Promise.resolve(null);
            }
            const baseUrl = ignoreApiKeysViaProxy ? 
                `https://ipinfo.io/${node.ip}/json` : 
                `https://ipinfo.io/${node.ip}/json?token=${ipinfoApiKey}`;
            const url = constructUrl(baseUrl, !ignoreApiKeysViaProxy);
            return fetch(url)
                .then(response => {
                    if (!response.ok) throw new Error('Failed to fetch IPinfo data');
                    return response.json();
                })
                .then(data => {
                    const ipNodeId = node.id;
                    const asn = data.asn?.asn || 'Unknown ASN';
                    const city = data.city || 'Unknown City';
                    const companyName = data.company?.name || 'Unknown Company';
                    const country = data.country || 'Unknown Country';
                    const privacy = data.privacy || { vpn: false, proxy: false, tor: false, relay: false, hosting: false };

                    // ASN
                    let asnId = existingAsns.get(asn);
                    if (!asnId) {
                        asnId = nextId++;
                        newNodes.push({ 
                            id: asnId, 
                            type: 'asn', 
                            label: `ASN: ${asn}`, 
                            title: `ASN: ${asn}`, 
                            color: { background: '#a3e635' }, 
                            asn 
                        });
                        existingAsns.set(asn, asnId);
                    }
                    const asnEdgeId = `${ipNodeId}-${asnId}-AssignedTo`;
                    if (!edges.get(asnEdgeId) && !newEdges.some(e => e.id === asnEdgeId)) {
                        newEdges.push({ id: asnEdgeId, from: ipNodeId, to: asnId, label: 'Assigned to' });
                    }

                    // City
                    let cityId = existingCities.get(city);
                    if (!cityId) {
                        cityId = nextId++;
                        newNodes.push({ 
                            id: cityId, 
                            type: 'city', 
                            label: `City: ${city}`, 
                            title: `City: ${city}`, 
                            color: { background: '#f97316' }, 
                            city 
                        });
                        existingCities.set(city, cityId);
                    }
                    const cityEdgeId = `${ipNodeId}-${cityId}-LocatedIn`;
                    if (!edges.get(cityEdgeId) && !newEdges.some(e => e.id === cityEdgeId)) {
                        newEdges.push({ id: cityEdgeId, from: ipNodeId, to: cityId, label: 'Located in' });
                    }

                    // Organization
                    let orgId = existingOrgs.get(companyName);
                    if (!orgId) {
                        orgId = nextId++;
                        newNodes.push({ 
                            id: orgId, 
                            type: 'organization', 
                            label: `Organization: ${companyName}`, 
                            title: `Company: ${companyName}`, 
                            color: { background: '#facc15' }, 
                            organization: companyName 
                        });
                        existingOrgs.set(companyName, orgId);
                    }
                    const orgEdgeId = `${ipNodeId}-${orgId}-BelongsTo`;
                    if (!edges.get(orgEdgeId) && !newEdges.some(e => e.id === orgEdgeId)) {
                        newEdges.push({ id: orgEdgeId, from: ipNodeId, to: orgId, label: 'Belongs to' });
                    }

                    // Country
                    let countryId = existingCountries.get(country);
                    if (!countryId) {
                        countryId = nextId++;
                        newNodes.push({ 
                            id: countryId, 
                            type: 'country', 
                            label: `Country: ${country}`, 
                            title: `Country: ${country}`, 
                            color: { background: '#34d399' }, 
                            country 
                        });
                        existingCountries.set(country, countryId);
                    }
                    const countryEdgeId = `${ipNodeId}-${countryId}-LocatedIn`;
                    if (!edges.get(countryEdgeId) && !newEdges.some(e => e.id === countryEdgeId)) {
                        newEdges.push({ id: countryEdgeId, from: ipNodeId, to: countryId, label: 'Located in' });
                    }

                    // Privacy Types
                    privacyTypes.forEach(privacyType => {
                        if (privacy[privacyType.key]) {
                            let privacyNodeId = existingPrivacyTypes.get(privacyType.key);
                            if (!privacyNodeId) {
                                privacyNodeId = nextId++;
                                newNodes.push({ 
                                    id: privacyNodeId, 
                                    type: privacyType.key, 
                                    label: privacyType.label, 
                                    title: privacyType.label, 
                                    color: { background: privacyType.color }
                                });
                                existingPrivacyTypes.set(privacyType.key, privacyNodeId);
                            }
                            const privacyEdgeId = `${ipNodeId}-${privacyNodeId}-Uses`;
                            if (!edges.get(privacyEdgeId) && !newEdges.some(e => e.id === privacyEdgeId)) {
                                newEdges.push({ id: privacyEdgeId, from: ipNodeId, to: privacyNodeId, label: 'Uses' });
                            }
                        }
                    });

                    successfulEnrichments++;
                })
                .catch(error => {
                    console.error(`Failed to enrich IP ${node.ip}: ${error.message}`);
                    showToast(`Failed to enrich IP ${node.ip}: ${error.message}`, 'error');
                    return null;
                });
        });
        await Promise.all(promises);
    }
    
    let lastProgressUpdate = 0;
    const progressUpdateInterval = 1000;
    const startTime = Date.now();
    
    for (let i = 0; i < totalIPs; i += batchSize) {
        if (activeTaskController && activeTaskController.signal.aborted) {
            showToast('IPinfo enrichment stopped', 'info');
            break;
        }
        
        const batch = ipNodes.slice(i, Math.min(i + batchSize, totalIPs));
        await processBatch(batch);
        
        if (newNodes.length > 0) {
            nodes.add(newNodes);
            newNodes.length = 0;
        }
        if (newEdges.length > 0) {
            edges.add(newEdges);
            newEdges.length = 0;
        }
        
        const currentTime = Date.now();
        if (currentTime - lastProgressUpdate >= progressUpdateInterval) {
            const processedIPs = Math.min(i + batchSize, totalIPs);
            const progress = ((processedIPs / totalIPs) * 100).toFixed(1);
            const remainingIPs = totalIPs - processedIPs;
            const remainingTimeMs = Math.max(0, remainingIPs * assumedRequestTimeMs);
            const remainingSeconds = Math.ceil(remainingTimeMs / 1000);
            const remainingMinutes = Math.floor(remainingSeconds / 60);
            const remainingSecondsPart = remainingSeconds % 60;
            const remainingTimeStr = remainingMinutes > 0 
                ? `${remainingMinutes}m ${remainingSecondsPart}s` 
                : `${remainingSeconds}s`;
            
            document.getElementById('progress-bar').textContent = 
                `IPinfo Enrichment: ${successfulEnrichments}/${totalIPs} IPs (${progress}%) - Est. ${remainingTimeStr} remaining`;
            lastProgressUpdate = currentTime;
            updateSelectOptions();
        }
        
        await new Promise(resolve => setTimeout(resolve, delayBetweenBatches));
    }
    
    if (newNodes.length > 0) nodes.add(newNodes);
    if (newEdges.length > 0) edges.add(newEdges);
    updateNodeSizes();
    updateSelectOptions();
    await stabilizeNetwork();
    ensureInteractionSettings();
    completeProgressBar();
    showToast(`IPinfo enrichment completed: ${successfulEnrichments}/${totalIPs} IPs enriched`, 'success');
    
    if (window.innerWidth <= 768) {
        const controls = document.getElementById('controls');
        controls.classList.add('collapsed');
        document.getElementById('myNetwork').style.display = 'block';
        network.fit({ animation: { duration: 300, easingFunction: 'easeInOutQuad' } });
    }
}

async function enrichAllGoogleDNS() {
    showProgressBar();
    network.setOptions({ physics: { enabled: false } });
    const domainNodes = nodes.get({ filter: n => n.type === 'domain' && n.domain });
    const totalDomains = domainNodes.length;
    let successfulEnrichments = 0;

    if (totalDomains === 0) {
        showToast('No domains found to enrich', 'info');
        completeProgressBar();
        return;
    }

    console.log(`Found ${totalDomains} domain nodes to enrich with Google DNS`);
    showToast(`Starting Google DNS enrichment for ${totalDomains} domains`, 'info');

    const batchSize = 50; // Consistent with other bulk enrichment functions
    const delayBetweenBatches = 200; // Consistent with other bulk functions
    const totalBatches = Math.ceil(totalDomains / batchSize);
    const assumedRequestTimeMs = 100; // Estimated time per request
    const timePerBatchMs = assumedRequestTimeMs * batchSize;
    const totalBatchDelays = (totalBatches - 1) * delayBetweenBatches;
    const estimatedTimeMs = (timePerBatchMs * totalBatches) + totalBatchDelays + 1000;

    const estimatedSeconds = Math.ceil(estimatedTimeMs / 1000);
    const estimatedMinutes = Math.floor(estimatedSeconds / 60);
    const remainingSeconds = estimatedSeconds % 60;
    const timeEstimateStr = estimatedMinutes > 0 
        ? `${estimatedMinutes}m ${remainingSeconds}s` 
        : `${estimatedSeconds}s`;

    showToast(`Estimated time for Google DNS enrichment: ~${timeEstimateStr}`, 'info');
    document.getElementById('progress-bar').textContent = `Google DNS Enrichment: 0/${totalDomains} Domains (0%) - Est. ${timeEstimateStr}`;

    async function processBatch(batch) {
        const promises = batch.map(node => {
            if (activeTaskController && activeTaskController.signal.aborted) {
                return Promise.resolve(null);
            }
            return throttledEnrichGoogleDNS(node.domain, node.id, true) // isBulk = true
                .then(() => successfulEnrichments++)
                .catch(error => {
                    console.error(`Failed to enrich domain ${node.domain}: ${error.message}`);
                    showToast(`Failed to enrich domain ${node.domain}: ${error.message}`, 'error');
                    return null;
                });
        });
        await Promise.all(promises);
    }

    let lastProgressUpdate = 0;
    const progressUpdateInterval = 1000;
    const startTime = Date.now();

    for (let i = 0; i < totalDomains; i += batchSize) {
        if (activeTaskController && activeTaskController.signal.aborted) {
            showToast('Google DNS enrichment stopped', 'info');
            document.getElementById('progress-bar').textContent = `Google DNS Enrichment: Stopped at ${successfulEnrichments}/${totalDomains} Domains`;
            break;
        }

        const batch = domainNodes.slice(i, Math.min(i + batchSize, totalDomains));
        console.log(`Processing batch ${Math.floor(i / batchSize) + 1} of ${totalBatches}, Domains ${i} to ${Math.min(i + batchSize - 1, totalDomains - 1)}`);

        await processBatch(batch);

        const currentTime = Date.now();
        if (currentTime - lastProgressUpdate >= progressUpdateInterval || i + batchSize >= totalDomains) {
            const processedDomains = Math.min(i + batchSize, totalDomains);
            const progress = ((processedDomains / totalDomains) * 100).toFixed(1);
            const remainingDomains = totalDomains - processedDomains;
            const remainingTimeMs = Math.max(0, remainingDomains * assumedRequestTimeMs);
            const remainingSeconds = Math.ceil(remainingTimeMs / 1000);
            const remainingMinutes = Math.floor(remainingSeconds / 60);
            const remainingSecondsPart = remainingSeconds % 60;
            const remainingTimeStr = remainingMinutes > 0 
                ? `${remainingMinutes}m ${remainingSecondsPart}s` 
                : `${remainingSeconds}s`;

            document.getElementById('progress-bar').textContent = 
                `Google DNS Enrichment: ${successfulEnrichments}/${totalDomains} Domains (${progress}%) - Est. ${remainingTimeStr} remaining`;
            lastProgressUpdate = currentTime;
            updateSelectOptions();
        }

        await new Promise(resolve => setTimeout(resolve, delayBetweenBatches));
    }

    updateNodeSizes();
    updateSelectOptions();
    await stabilizeNetwork();
    ensureInteractionSettings();

    if (!(activeTaskController && activeTaskController.signal.aborted)) {
        completeProgressBar();
        showToast(`Google DNS enrichment completed: ${successfulEnrichments}/${totalDomains} domains enriched`, 'success');
    } else {
        showToast(`Google DNS enrichment stopped: ${successfulEnrichments}/${totalDomains} domains processed`, 'info');
    }

    if (window.innerWidth <= 768) {
        const controls = document.getElementById('controls');
        controls.classList.add('collapsed');
        document.getElementById('myNetwork').style.display = 'block';
        network.fit({ animation: { duration: 300, easingFunction: 'easeInOutQuad' } });
    }
}


function exportToPDF() {
    network.setOptions({ physics: { enabled: false } });
    network.stabilize(100);
    network.fit();
    
    setTimeout(() => {
        try {
            const canvas = document.querySelector('#myNetwork .vis-network canvas');
            if (!canvas) throw new Error('Canvas not found');

            const { jsPDF } = window.jspdf;
            const pdf = new jsPDF({
                orientation: 'landscape',
                unit: 'px',
                format: [canvas.width, canvas.height]
            });

            // Add title
            pdf.setFontSize(16);
            pdf.text('Network Graph Export', 40, 20);
            
            const imgData = canvas.toDataURL('image/png');
            pdf.addImage(imgData, 'PNG', 0, 40, canvas.width, canvas.height - 40); // Offset for title
            pdf.save(`network_graph_${new Date().toISOString().replace(/[:.]/g, '-')}.pdf`);
            
            showToast('Graph exported as PDF', 'success');
        } catch (error) {
            console.error('Error exporting to PDF:', error);
            showToast('Failed to export graph as PDF: ' + error.message, 'error');
        } finally {
            network.setOptions({ physics: { enabled: !isPhysicsPaused } });
        }
    }, 500);
}

// Function to trigger save after key operations
function saveStateAfterOperation() {
    saveState();
    showToast('Progress saved', 'success');
}

window.onload = function() {
    const stateLoaded = loadState();
    if (!stateLoaded) {
        nodes = new vis.DataSet([]);
        edges = new vis.DataSet([]);
        nextId = 1;
    }

    updateSelectOptions();
    updateTheme();
    
    // Ensure interaction settings with dragView
    network.setOptions({
        interaction: {
            ...baseInteractionOptions,
            dragView: true,  // Explicitly enable dragging
            zoomView: true,
            zoomSpeed: 0.5
        }
    });
    ensureInteractionSettings();
    
    container.removeEventListener('mousedown', handleMouseDown);
    container.removeEventListener('mousemove', handleMouseMove);
    container.removeEventListener('mouseup', handleMouseUp);
    container.addEventListener('wheel', handleWheel, { passive: false });

    if (window.innerWidth <= 768) {
        document.getElementById('controls').classList.add('collapsed');
    }

    stabilizeNetwork().then(() => {
        network.fit({ animation: { duration: 300 } });
    });

    let hasChanges = false;
    nodes.on('*', () => hasChanges = true);
    edges.on('*', () => hasChanges = true);
    setInterval(() => {
        if (hasChanges) {
            saveState();
            hasChanges = false;
            showToast('Auto-saved', 'info');
        }
    }, 60 * 1000);
};

function loadState() {
    const savedState = localStorage.getItem('networkGraphState');
    if (!savedState) {
        console.log('No saved state found in localStorage');
        return false;
    }

    try {
        const state = JSON.parse(savedState);
        if (!state.nodes || !state.edges) return false;

        nodes.clear();
        edges.clear();
        
        state.nodes.forEach(node => nodes.add(node));
        state.edges.forEach(edge => edges.add(edge));
        
        nextId = state.nextId || 1;
        isDarkMode = state.isDarkMode !== undefined ? state.isDarkMode : true;
        isPhysicsPaused = state.isPhysicsPaused || false;
        nodeLabelsVisible = state.nodeLabelsVisible !== undefined ? state.nodeLabelsVisible : true;
        edgeLabelsVisible = state.edgeLabelsVisible !== undefined ? state.edgeLabelsVisible : true;
        
        document.getElementById('showNodeLabels').checked = nodeLabelsVisible;
        document.getElementById('showEdgeLabels').checked = edgeLabelsVisible;
        
        updateTheme();
        const pauseButton = document.getElementById('pause-toggle');
        pauseButton.textContent = isPhysicsPaused ? 'Resume Physics' : 'Pause Physics';
        pauseButton.classList.toggle('paused', isPhysicsPaused);
        
        // Explicitly set all interaction options including dragView
        network.setOptions({
            physics: { enabled: !isPhysicsPaused },
            interaction: {
                ...baseInteractionOptions,
                dragView: true,  // Ensure dragView is enabled
                zoomView: true,
                dragNodes: true,
                zoomSpeed: 0.5,
                multiselect: true,
                hover: true
            }
        });
        
        // Re-apply wheel event listener (from previous zoom fix)
        container.removeEventListener('wheel', handleWheel);
        container.addEventListener('wheel', handleWheel, { passive: false });
        
        console.log('Loaded state with dragView enabled');
        return true;
    } catch (e) {
        console.error('Error loading state:', e);
        showToast('Failed to load saved state: ' + e.message, 'error');
        localStorage.removeItem('networkGraphState');
        return false;
    }
}


// Separate wheel handler function for reusability
function handleWheel(event) {
    event.preventDefault();
    const scale = event.deltaY > 0 ? 0.9 : 1.1;
    const currentScale = network.getScale();
    network.moveTo({
        scale: currentScale * scale,
        animation: { duration: 100 }
    });
}

        function showToast(message, type = 'info') {
            const toastOptions = {
                text: message,
                duration: 6500,
                position: "center",
                style: {
                    background: isDarkMode ? '#2d3748' : '#fff',
                    color: isDarkMode ? '#e2e8f0' : '#1f2a44',
                    border: `1px solid ${isDarkMode ? '#4b5563' : '#d1d5db'}`,
                    boxShadow: isDarkMode ? '0 2px 10px rgba(0, 0, 0, 0.3)' : '0 2px 10px rgba(0, 0, 0, 0.1)',
                    position: 'fixed',
                    top: '50px',
                    left: '50%',
                    transform: 'translateX(-50%)',
                    width: 'auto',
                    maxWidth: '80%',
                    zIndex: 1000
                }
            };
            switch (type) {
                case 'success': toastOptions.style.background = isDarkMode ? '#166534' : '#22c55e'; toastOptions.style.color = '#fff'; break;
                case 'error': toastOptions.style.background = isDarkMode ? '#991b1b' : '#ef4444'; toastOptions.style.color = '#fff'; break;
            }
            Toastify(toastOptions).showToast();
        }

        function throttleRequest(fn, rateLimit = RATE_LIMIT_MS) {
    return async function(...args) {
        if (activeTaskController) {
            throw new Error('Another task is already running');
        }
        
        activeTaskController = new AbortController();
        const stopButton = document.getElementById('stop-task');
        stopButton.disabled = false;
        
        const now = Date.now();
        const timeSinceLast = now - lastRequestTime;
        const delay = rateLimit; // Use the provided rate limit (1000ms for Shodan)
        if (timeSinceLast < delay) await new Promise(resolve => setTimeout(resolve, delay - timeSinceLast));
        lastRequestTime = now;
        
        try {
            const result = await fn(...args, activeTaskController.signal);
            activeTaskController = null;
            stopButton.disabled = true;
            return result;
        } catch (error) {
            if (error.name === 'AbortError') {
                console.log('Task aborted');
            } else {
                throw error;
            }
        } finally {
            if (activeTaskController === null) {
                stopButton.disabled = true;
            }
        }
    };
}

        const baseInteractionOptions = {
    dragView: true,
    zoomView: true,
    dragNodes: true,
    zoomSpeed: 0.5,
    navigationButtons: false,
    multiselect: true, // Changed from false to true
    hover: true
};

        let container = document.getElementById('myNetwork');
        let data = { nodes: nodes, edges: edges };

        let options = {
    nodes: {
        shape: 'dot',
        size: 10,
        font: { 
            size: nodeLabelsVisible ? 12 : 0,
            color: '#e2e8f0',
            multi: true,
            align: 'center',
            vadjust: 0
        },
        scaling: {
            min: 10,
            max: 125,
            label: { enabled: false }
        },
        fixed: {
            x: false,
            y: false
        },
        shapeProperties: {
            useBorderWithImage: false
        },
        chosen: {
            label: function(values, id, selected, hovering) {
                values.size = nodeLabelsVisible ? 12 : 0;
            }
        },
        color: {
            hover: {
                border: '#60a5fa',
                background: '#4b5563'
            },
            highlight: {
                border: '#60a5fa',
                background: '#4b5563'
            }
        }
    },
    edges: { 
        arrows: { to: { enabled: true, scaleFactor: 0.5 } },
        font: { 
            size: edgeLabelsVisible ? 12 : 0,
            color: '#e2e8f0',
            strokeWidth: 0,
            strokeColor: 'transparent'
        },
        smooth: true,
        width: 1,
        chosen: {
            label: function(values, id, selected, hovering) {
                values.size = edgeLabelsVisible ? 12 : 0;
            }
        },
        color: { 
            color: '#94a3b8',
            highlight: '#60a5fa'
        }
    },
    physics: { 
        enabled: true,
        stabilization: {
            enabled: true,
            iterations: 100,
            updateInterval: 25
        },
        barnesHut: { 
            gravitationalConstant: -8000,
            centralGravity: 0.1,
            springLength: 200,
            springConstant: 0.04,
            damping: 0.9,
            avoidOverlap: 0.5
        },
        maxVelocity: 25,
        minVelocity: 0.1,
        solver: 'barnesHut'
    },
    interaction: {
        dragNodes: true,
        dragView: true,    // Enable view dragging (panning)
        zoomView: true,    // Enable zooming
        hover: true,
        multiselect: true,
        selectable: true,
        zoomSpeed: 0.5
    },
    layout: { improvedLayout: true }
};
        
        let network = new vis.Network(container, data, options);

network.on('selectNode', function(params) {
    selectedNodes = new Set(params.nodes); // Sync with vis.js selection
    console.log('Nodes selected:', [...selectedNodes]);
});

network.on('deselectNode', function(params) {
    selectedNodes = new Set(params.nodes); // Sync with vis.js selection
    console.log('Nodes deselected, remaining:', [...selectedNodes]);
});



function ensureInteractionSettings() {
    network.setOptions({
        interaction: { 
            dragNodes: true,
            dragView: true,    // Explicitly enable panning
            zoomView: true,
            selectable: true,
            multiselect: true,
            hover: true,
            zoomSpeed: 0.5
        },
        physics: {
            enabled: !isPhysicsPaused,
            stabilization: { enabled: false },
            barnesHut: {
                gravitationalConstant: -8000,
                centralGravity: 0.1,
                springLength: 200,
                springConstant: 0.04,
                damping: 0.9,
                avoidOverlap: 0.5
            },
            maxVelocity: 25,
            minVelocity: 0.1
        },
        nodes: {
            fixed: { x: false, y: false } // Ensure nodes remain movable unless layout specifies otherwise
        }
    });
    console.log('Interaction settings reapplied:', network.getOptionsFromConfigurator().interaction);
}


network.on('dragStart', function(params) {
    if (params.nodes.length) {
        // Dragging a node
        console.log('Dragging node:', params.nodes);
    } else {
        // Dragging background (panning)
        console.log('Starting pan');
        network.setOptions({
            interaction: { dragView: true }
        });
    }
});

network.on('dragEnd', function(params) {
    if (params.nodes.length) {
        // After dragging a node, ensure it's not fixed unless intended
        params.nodes.forEach(nodeId => {
            nodes.update({
                id: nodeId,
                fixed: { x: false, y: false }
            });
        });
        console.log('Node drag ended, position updated');
    }
    // Reapply interaction settings to ensure panning works
    ensureInteractionSettings();
    saveStateAfterOperation(); // Save new node positions
});

function stabilizeNetwork(skipFit = false) {
    return new Promise(resolve => {
        network.setOptions({
            physics: {
                enabled: true,
                stabilization: { enabled: true, iterations: 200, updateInterval: 50 }
            }
        });
        network.stabilize(200);
        let resolved = false;
        network.once('stabilizationIterationsDone', () => {
            if (!resolved) {
                resolved = true;
                finishStabilization(resolve, skipFit);
            }
        });
        setTimeout(() => {
            if (!resolved) {
                resolved = true;
                finishStabilization(resolve, skipFit);
            }
        }, 5000);
    });
}

function finishStabilization(resolve, skipFit) {
    network.setOptions({ 
        physics: { enabled: !isPhysicsPaused, stabilization: { enabled: false } },
        interaction: { 
            dragNodes: true,
            dragView: true,    // Ensure panning remains enabled
            zoomView: true,
            selectable: true,
            multiselect: true,
            hover: true,
            zoomSpeed: 0.5
        }
    });
    if (!skipFit) network.fit({ animation: { duration: 500, easingFunction: 'easeInOutQuad' } });
    resolve();
}


       

        network.on('init', function() {
            container.addEventListener('wheel', function(event) {
                event.preventDefault();
                const scale = event.deltaY > 0 ? 0.9 : 1.1;
                const currentScale = network.getScale();
                network.moveTo({
                    scale: currentScale * scale,
                    animation: { duration: 100 }
                });
            }, { passive: false });
        });

        network.on('oncontext', function(params) {
    params.event.preventDefault();
    const nodeId = this.getNodeAt(params.pointer.DOM);
    const edgeId = this.getEdgeAt(params.pointer.DOM);

    // Don't modify selectedNodes here unless it's a deliberate action
    if (selectedNodes.size > 0) {
        const firstNode = nodes.get([...selectedNodes][0]);
        let value;
        switch (firstNode.type) {
            case 'ip': value = firstNode.ip; break;
            case 'domain': value = firstNode.domain; break;
            default: value = firstNode.label;
        }
        showContextMenu(params.pointer.DOM.x, params.pointer.DOM.y, value, [...selectedNodes], firstNode.type);
    } else if (nodeId) {
        // Fallback for single node if no prior selection
        const node = nodes.get(nodeId);
        let value;
        switch (node.type) {
            case 'ip': value = node.ip; break;
            case 'domain': value = node.domain; break;
            default: value = node.label;
        }
        showContextMenu(params.pointer.DOM.x, params.pointer.DOM.y, value, [nodeId], node.type);
    } else if (edgeId) {
        showEdgeContextMenu(params.pointer.DOM.x, params.pointer.DOM.y, edgeId);
    }
});

network.on('click', function(params) {
 // Only proceed if exactly one node is selected and not dragging
 if (params.nodes.length !== 1 || params.event.type === 'drag') {
        console.log('Click event ignored:', params);
        return;
    }

    const nodeId = params.nodes[0];
    const node = nodes.get(nodeId);

    // Verify node exists
    if (!node) {
        console.error('Node not found for ID:', nodeId);
        showToast('Node not found', 'error');
        return;
    }

    // Log the node for debugging
    console.log('Clicked node:', JSON.stringify(node, null, 2));

    // Determine the value to copy based on node type
    let valueToCopy;
    switch (node.type) {
        case 'ip':
            valueToCopy = node.ip;
            break;
        case 'domain':
            valueToCopy = node.domain;
            break;
        case 'contact':
            valueToCopy = node.email || node.name;
            break;
        case 'organization':
            valueToCopy = node.organization;
            break;
        case 'port':
            valueToCopy = `${node.portType}/${node.portNumber}`;
            break;
        case 'wallet':
            valueToCopy = node.address;
            break;
        case 'bank':
            valueToCopy = node.accountNumber;
            break;
        case 'technology':
            valueToCopy = node.techName;
            break;
        case 'device':
            valueToCopy = node.deviceName;
            break;
        case 'malware':
            valueToCopy = node.malwareName;
            break;
        case 'vulnerability':
            valueToCopy = node.cve || node.vulnName; // Prefer CVE if available, else vulnName
            break;
        case 'favicon':
        case 'http_hash':
        case 'html_hash':
        case 'ssl_hash':
            valueToCopy = node.hash; // Standardized hash property
            break;
        case 'asn':
            valueToCopy = node.asn;
            break;
        case 'city':
            valueToCopy = node.city;
            break;
        case 'country':
            valueToCopy = node.country;
            break;
        case 'os':
            valueToCopy = node.os;
            break;
        case 'product':
            valueToCopy = node.product;
            break;
        case 'http_title':
            valueToCopy = node.title; // Use the title property for http_title
            break;
        case 'vpn':
        case 'proxy':
        case 'tor':
        case 'relay':
        case 'hosting':
            valueToCopy = node.value;
            break;
        default:
            // Fallback: Extract value after prefix or use full label
            valueToCopy = node.label.split('\n')[0].split(': ')[1] || node.label.split('\n')[0];
            console.warn(`Unhandled node type "${node.type}", using fallback value:`, valueToCopy);
    }

    // Check if a valid value was found
    if (!valueToCopy) {
        console.warn('No valid value to copy for node:', node);
        showToast(`No value available to copy for ${node.type}`, 'warning');
        return;
    }

    // Log the value being copied for debugging
    console.log('Value to copy:', valueToCopy);

    // Attempt to copy to clipboard
    navigator.clipboard.writeText(valueToCopy)
        .then(() => {
            showToast(`Copied "${valueToCopy}" to clipboard`, 'success');
        })
        .catch(err => {
            console.error('Failed to copy to clipboard:', err);
            showToast(`Failed to copy: ${err.message}`, 'error');
        });
});

function showEdgeContextMenu(x, y, edgeId) {
    const menu = document.getElementById('edgeContextMenu');
    const edge = edges.get(edgeId);
    if (!edge) return;
    
    const menuHtml = `
        <button onclick="editEdgeLabel('${edgeId}')">Edit Label</button>
        <button onclick="removeEdgeDirect('${edgeId}')">Delete Edge</button>
    `;
    
    menu.innerHTML = menuHtml;
    const canvasOffset = container.getBoundingClientRect();
    menu.style.left = `${x + canvasOffset.left}px`;
    menu.style.top = `${y + canvasOffset.top}px`;
    menu.style.display = 'block';
    document.addEventListener('click', hideEdgeContextMenu);
}

function hideEdgeContextMenu() {
    document.getElementById('edgeContextMenu').style.display = 'none';
    document.removeEventListener('click', hideEdgeContextMenu);
}

function editEdgeLabel(edgeId) {
    const edge = edges.get(edgeId);
    if (!edge) {
        showToast('Edge not found', 'error');
        return;
    }
    
    const currentLabel = edge.label || '';
    const newLabel = prompt('Enter new edge label (leave empty to remove):', currentLabel);
    
    if (newLabel !== null) { // null means user cancelled
        edges.update({
            id: edgeId,
            label: newLabel.trim() === '' ? undefined : newLabel.trim()
            
        });
        updateEdgeSelectOptions();
        stabilizeNetwork();
        saveStateAfterOperation();
        showToast('Edge label updated', 'success');
    }
    
    hideEdgeContextMenu();
}

function removeEdgeDirect(edgeId) {
    const edge = edges.get(edgeId);
    if (!edge) {
        showToast('Edge not found', 'error');
        return;
    }
    
    edges.remove({ id: edgeId });
    updateNodeSizes();
    updateEdgeSelectOptions();
    stabilizeNetwork();
    saveStateAfterOperation();
    showToast('Edge removed', 'success');
    hideEdgeContextMenu();
}

// Update the showContextMenu function to include the new option
function showContextMenu(x, y, value, nodeIds, type) {
    const nodesArray = Array.isArray(nodeIds) ? nodeIds : [nodeIds];
    const menu = document.getElementById('contextMenu');
    const isMultiple = nodesArray.length > 1;
    
    let menuHtml = `
        <button onclick="deleteNodes([${nodesArray.join(',')}])">Delete ${isMultiple ? 'Selected Nodes' : 'Node'}</button>
        ${isMultiple ? '' : `<button onclick="startLinkCreation(${nodesArray[0]})">Create Link From Here</button>`}
        ${isMultiple ? '' : `<button onclick="showPropertiesPanel(${nodesArray[0]}); hideContextMenu();">View Node Properties</button>`}
    `;
    
    // Check if all selected nodes are of the same type
    const allSameType = nodesArray.every(id => {
        const node = nodes.get(id);
        return node && node.type === type;
    });
    
    if (allSameType) {
        if (type === 'ip') {
            menuHtml += `
                <button onclick="throttledEnrichIPMultiple([${nodesArray.map(id => `'${nodes.get(id).ip}'`).join(',')}], [${nodesArray.map(id => `'${id}'`).join(',')}])">Enrich via IPINFO</button>
                <button onclick="throttledEnrichShodanMultiple([${nodesArray.map(id => `'${nodes.get(id).ip}'`).join(',')}], [${nodesArray.map(id => `'${id}'`).join(',')}])">Enrich via Shodan</button>
                <button onclick="throttledEnrichInternetDBMultiple([${nodesArray.map(id => `'${nodes.get(id).ip}'`).join(',')}], [${nodesArray.map(id => `'${id}'`).join(',')}])">Enrich via InternetDB</button>
                <button onclick="throttledSendHttpsRequestMultiple([${nodesArray.map(id => `'${nodes.get(id).ip}'`).join(',')}], 'ip', 'https')">Send HTTPS Request</button>
                <button onclick="throttledSendHttpsRequestMultiple([${nodesArray.map(id => `'${nodes.get(id).ip}'`).join(',')}], 'ip', 'http')">Send HTTP Request</button>
            `;
        } else if (type === 'domain') {
            menuHtml += `
                <button onclick="throttledEnrichGoogleDNSMultiple([${nodesArray.map(id => `'${nodes.get(id).domain}'`).join(',')}], [${nodesArray.map(id => `'${id}'`).join(',')}])">Enrich via Google DNS</button>
                <button onclick="throttledEnrichShodanMultiple([${nodesArray.map(id => `'${nodes.get(id).domain}'`).join(',')}], [${nodesArray.map(id => `'${id}'`).join(',')}])">Enrich via Shodan</button>
                <button onclick="throttledEnrichHudsonRockDomainMultiple([${nodesArray.map(id => `'${nodes.get(id).domain}'`).join(',')}], [${nodesArray.map(id => `'${id}'`).join(',')}])">Enrich via Hudson Rock</button>
                <button onclick="throttledSendHttpsRequestMultiple([${nodesArray.map(id => `'${nodes.get(id).domain}'`).join(',')}], 'domain', 'https')">Send HTTPS Request</button>
                <button onclick="throttledSendHttpsRequestMultiple([${nodesArray.map(id => `'${nodes.get(id).domain}'`).join(',')}], 'domain', 'http')">Send HTTP Request</button>
            `;
        } else if (type === 'html_hash') {
            menuHtml += `
                <button onclick="throttledSearchShodanHtmlHash('${nodesArray[0]}', '${nodes.get(nodesArray[0]).hash}')">Search Shodan for IPs with this HTML Hash</button>
            `;
        } else if (type === 'contact') {
            menuHtml += `
                <button onclick="throttledEnrichHudsonRockMultiple([${nodesArray.map(id => `'${nodes.get(id).email}'`).join(',')}], [${nodesArray.map(id => `'${id}'`).join(',')}])">Enrich via Hudson Rock</button>
            `;
        }
    }

    menu.innerHTML = menuHtml;
    const canvasOffset = container.getBoundingClientRect();
    menu.style.left = `${x + canvasOffset.left}px`;
    menu.style.top = `${y + canvasOffset.top}px`;
    menu.style.display = 'block';
    document.addEventListener('click', hideContextMenu);
}



let linkFromNode = null;

function saveState() {
    try {
        const state = {
            nodes: nodes.get().map(node => {
                // Base properties common to all nodes
                const nodeData = {
                    id: node.id,
                    type: node.type,
                    label: node.label,
                    title: node.title,
                    color: node.color,
                    x: node.x,
                    y: node.y,
                    size: node.size,
                    originalLabel: node.originalLabel // Preserve original label for toggling visibility
                };

                // Add type-specific properties
                switch (node.type) {
                    case 'contact':
                        nodeData.name = node.name;
                        nodeData.email = node.email;
                        break;
                    case 'ip':
                        nodeData.ip = node.ip;
                        break;
                    case 'domain':
                        nodeData.domain = node.domain;
                        break;
                    case 'organization':
                        nodeData.organization = node.organization;
                        break;
                    case 'port':
                        nodeData.portType = node.portType;
                        nodeData.portNumber = node.portNumber;
                        break;
                    case 'wallet':
                        nodeData.address = node.address;
                        break;
                    case 'bank':
                        nodeData.accountNumber = node.accountNumber;
                        nodeData.sortCode = node.sortCode;
                        break;
                    case 'technology':
                        nodeData.techName = node.techName;
                        nodeData.techVersion = node.techVersion;
                        break;
                    case 'device':
                        nodeData.deviceCategory = node.deviceCategory;
                        nodeData.deviceName = node.deviceName;
                        break;
                    case 'malware':
                        nodeData.malwareName = node.malwareName;
                        nodeData.malwareType = node.malwareType;
                        break;
                    case 'vulnerability':
                        nodeData.vulnName = node.vulnName;
                        nodeData.cve = node.cve;
                        nodeData.url = node.url;
                        break;
                    case 'favicon':
                    case 'http_hash':
                    case 'html_hash':
                    case 'ssl_hash':
                        nodeData.hash = node.hash; // Standardized hash property
                        if (node.type === 'favicon') nodeData.location = node.location; // Favicon-specific
                        break;
                    case 'asn':
                        nodeData.asn = node.asn;
                        break;
                    case 'city':
                        nodeData.city = node.city;
                        break;
                    case 'country':
                        nodeData.country = node.country;
                        break;
                    case 'os':
                        nodeData.os = node.os;
                        break;
                    case 'product':
                        nodeData.product = node.product;
                        break;
                    case 'http_title':
                        nodeData.title = node.title; // Already in base properties, but explicit for clarity
                        break;
                    case 'vpn':
                    case 'proxy':
                    case 'tor':
                    case 'relay':
                    case 'hosting':
                        nodeData.value = node.value;
                        break;
                    default:
                        console.warn(`Unhandled node type in saveState: ${node.type}`);
                }

                return nodeData;
            }),
            edges: edges.get().map(edge => ({
                id: edge.id,
                from: edge.from,
                to: edge.to,
                label: edge.label,
                originalLabel: edge.originalLabel // Preserve original label for toggling visibility
            })),
            nextId: nextId,
            isDarkMode: isDarkMode,
            isPhysicsPaused: isPhysicsPaused,
            nodeLabelsVisible: nodeLabelsVisible,
            edgeLabelsVisible: edgeLabelsVisible
        };

        localStorage.setItem('networkGraphState', JSON.stringify(state));
        console.log('State saved successfully');
    } catch (e) {
        console.error('Failed to save state:', e);
        showToast('Failed to save state: ' + e.message, 'error');
    }
}

function deleteNodes(nodeIds) {
    const idsToDelete = Array.isArray(nodeIds) ? nodeIds.map(id => parseInt(id)) : [parseInt(nodeIds)];

    idsToDelete.forEach(nodeId => {
        const node = nodes.get(nodeId);
        if (!node) {
            showToast(`Node ${nodeId} not found`, 'error');
            return;
        }

        const connectedEdges = edges.get({
            filter: edge => edge.from === nodeId || edge.to === nodeId
        });
        edges.remove(connectedEdges.map(edge => edge.id));
        nodes.remove({ id: nodeId });
    });

    updateSelectOptions();
    updateNodeSizes();
    stabilizeNetwork();
    saveStateAfterOperation();
    showToast(`${idsToDelete.length > 1 ? 'Nodes' : 'Node'} deleted`, 'success');
}




const throttledSearchShodanHtmlHash = throttleRequest(async function searchShodanHtmlHash(htmlHashNodeId, htmlHash, signal) {
    if (!shodanApiKey) {
        showToast('Please set your Shodan API key in the "API Keys" tab first.', 'error');
        return;
    }

    // Validate htmlHash
    const hashNum = parseInt(htmlHash);
    if (!Number.isInteger(hashNum)) {
        showToast(`Invalid HTML Hash: ${htmlHash}. Must be an integer.`, 'error');
        return;
    }

    network.setOptions({ physics: { enabled: false } });
    showProgressBar();
    document.getElementById('progress-bar').textContent = `Searching Shodan for IPs with HTML Hash ${htmlHash.substring(0, 8)}...`;

    try {
        // Construct the URL to match the Bash script exactly
        const query = `http.html_hash:${hashNum}`; // No encoding here yet
        const baseUrl = `https://api.shodan.io/shodan/host/search?key=${shodanApiKey}&query=${query}`;
        const url = routeViaProxy ? `${corsProxyUrl}/${baseUrl}` : baseUrl;

        console.log('Search Shodan Base URL (before proxy):', baseUrl);
        console.log('Search Shodan Final URL:', url);
        console.log('routeViaProxy:', routeViaProxy, 'corsProxyUrl:', corsProxyUrl);

        const response = await fetch(url, {
            method: 'GET',
            signal: signal,
            headers: {
                'Accept': 'application/json' // Ensure JSON response
            }
        });

        if (!response.ok) {
            const errorText = await response.text();
            console.log('Search Shodan Status:', response.status, response.statusText);
            console.log('Search Shodan Response Body:', errorText);
            console.log('Request Headers:', Object.fromEntries(response.headers.entries()));
            throw new Error(`Failed to fetch Shodan data: ${response.statusText} - ${errorText}`);
        }

        const data = await response.json();
        console.log('Shodan Response:', data);

        if (!data.matches || data.matches.length === 0) {
            showToast(`No IPs found on Shodan with HTML Hash ${htmlHash}`, 'info');
            completeProgressBar();
            await stabilizeNetwork();
            return;
        }

        // Process the matches
        const newNodes = [];
        const newEdges = [];
        let successfulAdditions = 0;
        const totalMatches = data.matches.length;

        const existingIPs = new Map(nodes.get({ filter: n => n.type === 'ip' }).map(n => [n.ip, n.id]));

        for (const match of data.matches) {
            if (activeTaskController && activeTaskController.signal.aborted) {
                showToast('Shodan HTML Hash search stopped', 'info');
                break;
            }

            const ip = match.ip_str;
            let ipId = existingIPs.get(ip);

            if (!ipId) {
                ipId = nextId++;
                newNodes.push({
                    id: ipId,
                    type: 'ip',
                    label: `IP: ${ip}`,
                    title: `IP Address: ${ip}\nFrom Shodan HTML Hash Search`,
                    color: { background: '#f87171' },
                    ip: ip,
                    size: 20
                });
                existingIPs.set(ip, ipId);
            }

            const edgeId = `${ipId}-${htmlHashNodeId}-SharesHash`;
            if (!edges.get(edgeId) && !newEdges.some(e => e.id === edgeId)) {
                newEdges.push({
                    id: edgeId,
                    from: ipId,
                    to: htmlHashNodeId,
                    label: 'Shares HTML Hash'
                });
            }

            successfulAdditions++;
            const progress = ((successfulAdditions / totalMatches) * 100).toFixed(1);
            document.getElementById('progress-bar').textContent = `Shodan HTML Hash Search: ${successfulAdditions}/${totalMatches} IPs (${progress}%)`;
        }

        if (newNodes.length > 0) nodes.add(newNodes);
        if (newEdges.length > 0) edges.add(newEdges);

        updateNodeSizes();
        updateSelectOptions();
        await stabilizeNetwork();
        ensureInteractionSettings();

        completeProgressBar();
        showToast(`Found and added ${successfulAdditions} IPs with HTML Hash ${htmlHash.substring(0, 8)}...`, 'success');
    } catch (error) {
        if (error.name === 'AbortError') {
            showToast('Shodan HTML Hash search was cancelled', 'info');
        } else {
            console.error(`Error searching Shodan for HTML Hash ${htmlHash}: ${error.message}`);
            showToast(`Error searching Shodan: ${error.message}. Check CORS proxy in Config tab.`, 'error');
        }
        completeProgressBar();
        await stabilizeNetwork();
    }
}, SHODAN_RATE_LIMIT_MS);



function cancelLinkCreation() {
    if (linkFromNode) {
        // Reset visual feedback
        const originalNode = nodes.get(linkFromNode);
        nodes.update({
            id: linkFromNode,
            color: { border: isDarkMode ? '#94a3b8' : '#6b7280', background: originalNode.color.background }
        });
        
        showToast('Link creation cancelled', 'info');
        linkFromNode = null;
        
        // Remove temporary listeners
        network.off('oncontext', handleLinkDestination);
        network.off('click', cancelLinkCreation);
    }
}


        function hideContextMenu() {
            document.getElementById('contextMenu').style.display = 'none';
            document.removeEventListener('click', hideContextMenu);
        }

        const throttledSendHttpsRequest = throttleRequest(async function sendHttpsRequest(target, type) {
    network.setOptions({ physics: { enabled: false } });
    let url = type === 'ip' ? 
        `https://${target}` : 
        `https://${target}`;
    url = constructUrl(url);
    let message;

    try {
        const response = await fetch(url, {
            method: 'GET',
            headers: {
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                'Origin': window.location.origin
            },
            mode: 'cors',
            credentials: 'omit'
        });

        const status = response.status;
        const statusText = response.statusText;
        const headers = {};
        response.headers.forEach((value, key) => {
            headers[key] = value;
        });

        let body = '';
        const contentType = headers['content-type'] || '';
        if (contentType.includes('text') || contentType.includes('html') || contentType.includes('json')) {
            body = await response.text();
            if (body.length > 500) {
                body = body.substring(0, 500) + '... (truncated)';
            }
        } else {
            body = '(Binary or unsupported content type)';
        }

        message = `
            HTTPS Request to https://${target}
            Status: ${status} ${statusText}
            Headers: ${JSON.stringify(headers, null, 2)}
            Body: ${body}
        `.trim();
        showToast(message, 'success');
    } catch (error) {
        message = `
            HTTPS Request to https://${target}
            Error: ${error.message}
            Note: Ensure the CORS proxy (${corsProxyUrl}) is active and correctly configured
        `.trim();
        showToast(message, 'error');
    } finally {
        await stabilizeNetwork();
    }
});

        function saveCorsProxyUrl() {
    corsProxyUrl = document.getElementById('corsProxyUrl').value.trim();
    const storeProxy = document.getElementById('storeCorsProxy').checked;
    routeViaProxy = document.getElementById('routeViaProxy').checked;
    ignoreApiKeysViaProxy = document.getElementById('ignoreApiKeysViaProxy').checked;

    if (corsProxyUrl) {
        if (storeProxy) {
            localStorage.setItem('corsProxyUrl', corsProxyUrl);
            localStorage.setItem('routeViaProxy', routeViaProxy);
            localStorage.setItem('ignoreApiKeysViaProxy', ignoreApiKeysViaProxy);
            showToast('CORS Proxy settings saved successfully!', 'success');
        } else {
            localStorage.removeItem('corsProxyUrl');
            localStorage.removeItem('routeViaProxy');
            localStorage.removeItem('ignoreApiKeysViaProxy');
            showToast('CORS Proxy settings set for this session only', 'success');
        }
    } else {
        corsProxyUrl = 'https://cors-anywhere.herokuapp.com/';
        routeViaProxy = false;
        ignoreApiKeysViaProxy = false;
        localStorage.removeItem('corsProxyUrl');
        localStorage.removeItem('routeViaProxy');
        localStorage.removeItem('ignoreApiKeysViaProxy');
        document.getElementById('corsProxyUrl').value = corsProxyUrl;
        document.getElementById('routeViaProxy').checked = false;
        document.getElementById('ignoreApiKeysViaProxy').checked = false;
        showToast('CORS Proxy settings reset to default', 'info');
    }
}

function constructUrl(baseUrl, useApiKey = true) {
    if (routeViaProxy) {
        // Ensure corsProxyUrl doesn't end with a slash and baseUrl doesn't start with one
        const cleanProxyUrl = corsProxyUrl.replace(/\/+$/, ''); // Remove trailing slashes
        const cleanBaseUrl = baseUrl.replace(/^\/+/, '');      // Remove leading slashes
        return `${cleanProxyUrl}/${cleanBaseUrl}`;
    }
    return useApiKey ? baseUrl : baseUrl.split('?')[0]; // Remove query params if ignoring API keys
}

        function throttleRequest(fn) {
            return async function(...args) {
                const now = Date.now();
                const timeSinceLast = now - lastRequestTime;
                if (timeSinceLast < RATE_LIMIT_MS) await new Promise(resolve => setTimeout(resolve, RATE_LIMIT_MS - timeSinceLast));
                lastRequestTime = now;
                return fn(...args);
            };
        }

        function showToast(message, type = 'info') {
            const toastOptions = {
                text: message,
                duration: 6500,
                position: "center",
                style: {
                    background: isDarkMode ? '#2d3748' : '#fff',
                    color: isDarkMode ? '#e2e8f0' : '#1f2a44',
                    border: `1px solid ${isDarkMode ? '#4b5563' : '#d1d5db'}`,
                    boxShadow: isDarkMode ? '0 2px 10px rgba(0, 0, 0, 0.3)' : '0 2px 10px rgba(0, 0, 0, 0.1)',
                    position: 'fixed',
                    top: '50px',
                    left: '50%',
                    transform: 'translateX(-50%)',
                    width: 'auto',
                    maxWidth: '80%',
                    zIndex: 1000
                }
            };
            switch (type) {
                case 'success': toastOptions.style.background = isDarkMode ? '#166534' : '#22c55e'; toastOptions.style.color = '#fff'; break;
                case 'error': toastOptions.style.background = isDarkMode ? '#991b1b' : '#ef4444'; toastOptions.style.color = '#fff'; break;
            }
            Toastify(toastOptions).showToast();
        }

        async function stabilizeNetwork(skipFit = false) {
    return new Promise(resolve => {
        network.setOptions({
            physics: {
                enabled: true,
                stabilization: {
                    enabled: true,
                    iterations: 200,
                    updateInterval: 50
                },
                barnesHut: {
                    gravitationalConstant: -8000,
                    centralGravity: 0.3,
                    springLength: 150,
                    avoidOverlap: 1.0,
                    damping: 0.9
                }
            },
            // Explicitly preserve interaction settings
            interaction: { 
                ...baseInteractionOptions,
                zoomView: true,  // Ensure zooming is enabled
                dragView: true,
                zoomSpeed: 0.5
            }
        });

        network.stabilize(200);
        network.once('stabilizationIterationsDone', () => {
            network.setOptions({
                physics: {
                    enabled: !isPhysicsPaused,
                    stabilization: { enabled: false }
                },
                interaction: { 
                    ...baseInteractionOptions,
                    zoomView: true,
                    dragView: true,
                    zoomSpeed: 0.5
                }
            });

            if (!skipFit) {
                network.fit({
                    animation: {
                        duration: 500,
                        easingFunction: 'easeInOutQuad'
                    }
                });
            }

            setTimeout(() => {
                const boundingBox = network.getBoundingBox();
                if (boundingBox && nodes.length > 0) {
                    const margin = 50;
                    nodes.forEach(node => {
                        const { x, y } = network.getPositions([node.id])[node.id] || { x: 0, y: 0 };
                        nodes.update({
                            id: node.id,
                            x: Math.max(boundingBox.left + margin, Math.min(boundingBox.right - margin, x)),
                            y: Math.max(boundingBox.top + margin, Math.min(boundingBox.bottom - margin, y))
                        });
                    });
                }
                resolve();
            }, skipFit ? 0 : 550);
        });
    });
}

        function throttleRequest(fn) {
            return async function(...args) {
                const now = Date.now();
                const timeSinceLast = now - lastRequestTime;
                if (timeSinceLast < RATE_LIMIT_MS) await new Promise(resolve => setTimeout(resolve, RATE_LIMIT_MS - timeSinceLast));
                lastRequestTime = now;
                return fn(...args);
            };
        }

        function showToast(message, type = 'info') {
            const toastOptions = {
                text: message,
                duration: 6500,
                position: "center",
                style: {
                    background: isDarkMode ? '#2d3748' : '#fff',
                    color: isDarkMode ? '#e2e8f0' : '#1f2a44',
                    border: `1px solid ${isDarkMode ? '#4b5563' : '#d1d5db'}`,
                    boxShadow: isDarkMode ? '0 2px 10px rgba(0, 0, 0, 0.3)' : '0 2px 10px rgba(0, 0, 0, 0.1)',
                    position: 'fixed',
                    top: '50px',
                    left: '50%',
                    transform: 'translateX(-50%)',
                    width: 'auto',
                    maxWidth: '80%',
                    zIndex: 1000
                }
            };
            switch (type) {
                case 'success': toastOptions.style.background = isDarkMode ? '#166534' : '#22c55e'; toastOptions.style.color = '#fff'; break;
                case 'error': toastOptions.style.background = isDarkMode ? '#991b1b' : '#ef4444'; toastOptions.style.color = '#fff'; break;
            }
            Toastify(toastOptions).showToast();
        }

        async function stabilizeNetwork(skipFit = false) {
    return new Promise(resolve => {
        network.setOptions({
            physics: {
                enabled: true,
                stabilization: {
                    enabled: true,
                    iterations: 200,
                    updateInterval: 50
                },
                barnesHut: {
                    gravitationalConstant: -8000,
                    centralGravity: 0.3,
                    springLength: 150,
                    avoidOverlap: 1.0,
                    damping: 0.9
                }
            },
            interaction: { ...baseInteractionOptions, zoomView: true } // Preserve zoom
        });

        network.stabilize(200);
        network.once('stabilizationIterationsDone', () => {
            network.setOptions({
                physics: {
                    enabled: !isPhysicsPaused,
                    stabilization: { enabled: false }
                },
                interaction: { ...baseInteractionOptions, zoomView: true } // Re-ensure zoom
            });

            if (!skipFit) {
                network.fit({
                    animation: {
                        duration: 500,
                        easingFunction: 'easeInOutQuad'
                    }
                });
            }

            setTimeout(() => {
                const boundingBox = network.getBoundingBox();
                if (boundingBox && nodes.length > 0) {
                    const margin = 50;
                    nodes.forEach(node => {
                        const { x, y } = network.getPositions([node.id])[node.id] || { x: 0, y: 0 };
                        nodes.update({
                            id: node.id,
                            x: Math.max(boundingBox.left + margin, Math.min(boundingBox.right - margin, x)),
                            y: Math.max(boundingBox.top + margin, Math.min(boundingBox.bottom - margin, y))
                        });
                    });
                }
                ensureInteractionSettings(); // Final check
                resolve();
            }, skipFit ? 0 : 550);
        });
    });
}

const throttledEnrichInternetDB = throttleRequest(async function enrichInternetDB(ip, ipNodeId, isBulk = false) {
    network.setOptions({ physics: { enabled: false } });
    try {
        const url = constructUrl(`https://internetdb.shodan.io/${ip}`);
        const response = await fetch(url);
        if (!response.ok) throw new Error('Failed to fetch InternetDB data');
        const data = await response.json();

        // Deduplication maps
        const existingPorts = new Map(nodes.get({ filter: n => n.type === 'port' }).map(n => [`${n.portType}/${n.portNumber}`, n.id]));
        const existingDomains = new Map(nodes.get({ filter: n => n.type === 'domain' }).map(n => [n.domain, n.id]));
        const existingVulns = new Map(nodes.get({ filter: n => n.type === 'vulnerability' }).map(n => [n.cve, n.id]));
        const existingTags = new Map(nodes.get({ filter: n => n.type === 'tag' }).map(n => [n.tag, n.id]));
        const existingCPEs = new Map(nodes.get({ filter: n => n.type === 'cpe' }).map(n => [n.cpe, n.id]));

        const newNodes = [];
        const newEdges = [];

        // Ports (existing logic with deduplication)
        if (data.ports && data.ports.length > 0) {
            data.ports.forEach(port => {
                const portKey = `TCP/${port}`;
                let portId = existingPorts.get(portKey);
                if (!portId) {
                    portId = nextId++;
                    newNodes.push({ 
                        id: portId, 
                        type: 'port', 
                        label: `TCP/${port}`, 
                        title: `Port\nType: TCP\nNumber: ${port}`, 
                        color: { background: '#a78bfa' }, 
                        portType: 'TCP', 
                        portNumber: port.toString() 
                    });
                    existingPorts.set(portKey, portId);
                }
                const edgeId = `${ipNodeId}-${portId}-Exposes`;
                if (!edges.get(edgeId) && !newEdges.some(e => e.id === edgeId)) {
                    newEdges.push({ id: edgeId, from: ipNodeId, to: portId, label: 'Exposes' });
                }
            });
        }

        // Hostnames (existing logic with deduplication)
        if (data.hostnames && data.hostnames.length > 0) {
            data.hostnames.forEach(hostname => {
                let domainId = existingDomains.get(hostname);
                if (!domainId) {
                    domainId = nextId++;
                    newNodes.push({ 
                        id: domainId, 
                        type: 'domain', 
                        label: hostname, 
                        title: `Domain: ${hostname}`, 
                        color: { background: '#60a5fa' }, 
                        domain: hostname 
                    });
                    existingDomains.set(hostname, domainId);
                }
                const edgeId = `${ipNodeId}-${domainId}-ResolvesTo`;
                if (!edges.get(edgeId) && !newEdges.some(e => e.id === edgeId)) {
                    newEdges.push({ id: edgeId, from: ipNodeId, to: domainId, label: 'Resolves to' });
                }
            });
        }

        // Vulnerabilities (existing logic with deduplication)
        if (data.cves && data.cves.length > 0) {
            data.cves.forEach(cve => {
                let cveId = existingVulns.get(cve);
                if (!cveId) {
                    cveId = nextId++;
                    newNodes.push({ 
                        id: cveId, 
                        type: 'vulnerability', 
                        label: `Vulnerability: ${cve}`, 
                        title: `Vulnerability\nName: ${cve}\nCVE: ${cve}`, 
                        color: { background: '#dc2626' }, 
                        vulnName: cve, 
                        cve: cve,
                        url: `https://nvd.nist.gov/vuln/detail/${cve}`
                    });
                    existingVulns.set(cve, cveId);
                }
                const edgeId = `${ipNodeId}-${cveId}-Has`;
                if (!edges.get(edgeId) && !newEdges.some(e => e.id === edgeId)) {
                    newEdges.push({ id: edgeId, from: ipNodeId, to: cveId, label: 'Has' });
                }
            });
        }

        // Tags (new)
        if (data.tags && data.tags.length > 0) {
            data.tags.forEach(tag => {
                let tagId = existingTags.get(tag);
                if (!tagId) {
                    tagId = nextId++;
                    newNodes.push({
                        id: tagId,
                        type: 'tag',
                        label: `Tag: ${tag}`,
                        title: `Tag: ${tag}`,
                        color: { background: '#6d28d9' },
                        tag: tag
                    });
                    existingTags.set(tag, tagId);
                }
                const edgeId = `${ipNodeId}-${tagId}-Tagged`;
                if (!edges.get(edgeId) && !newEdges.some(e => e.id === edgeId)) {
                    newEdges.push({ id: edgeId, from: ipNodeId, to: tagId, label: 'Tagged' });
                }
            });
        }

        // CPEs (new)
        if (data.cpes && data.cpes.length > 0) {
            data.cpes.forEach(cpe => {
                let cpeId = existingCPEs.get(cpe);
                if (!cpeId) {
                    cpeId = nextId++;
                    newNodes.push({
                        id: cpeId,
                        type: 'cpe',
                        label: `CPE: ${cpe.split(':')[3] || cpe}`,
                        title: `CPE: ${cpe}`,
                        color: { background: '#0d9488' },
                        cpe: cpe
                    });
                    existingCPEs.set(cpe, cpeId);
                }
                const edgeId = `${ipNodeId}-${cpeId}-Runs`;
                if (!edges.get(edgeId) && !newEdges.some(e => e.id === edgeId)) {
                    newEdges.push({ id: edgeId, from: ipNodeId, to: cpeId, label: 'Runs' });
                }
            });
        }

        // Batch update
        if (newNodes.length > 0) nodes.add(newNodes);
        if (newEdges.length > 0) edges.add(newEdges);

        updateNodeSizes();
        updateSelectOptions();
        await stabilizeNetwork();
        ensureInteractionSettings();
        if (!isBulk) showToast(`IP ${ip} enrichment completed using InternetDB`, 'success');
    } catch (error) {
        console.error(`Error enriching IP ${ip} with InternetDB: ${error.message}`);
        showToast(`Error enriching IP ${ip} with InternetDB: ${error.message}`, 'error');
        await stabilizeNetwork();
    }
});

 
async function enrichAllShodan() {
    if (!shodanApiKey && !ignoreApiKeysViaProxy) { 
        showToast('Please set your Shodan API key in the "API Keys" tab first.', 'error'); 
        return; 
    }
    
    showProgressBar();
    const progressBar = document.getElementById('progress-bar');
    network.setOptions({ physics: { enabled: false } });
    const ipNodes = nodes.get({ filter: n => n.type === 'ip' && n.ip });
    const totalIPs = ipNodes.length;
    let successfulEnrichments = 0;
    
    if (totalIPs === 0) {
        showToast('No IP nodes found to enrich', 'info');
        completeProgressBar();
        return;
    }
    
    console.log(`Found ${totalIPs} IP nodes to enrich with Shodan`);
    showToast(`Starting Shodan enrichment for ${totalIPs} IPs`, 'info');
    
    const batchSize = 5; // Smaller batch size to respect Shodan rate limits
    const delayBetweenBatches = 100; // Small delay between batches
    const shodanDelayMs = SHODAN_RATE_LIMIT_MS; // 1-second delay per request
    const totalBatches = Math.ceil(totalIPs / batchSize);
    const timePerBatchMs = shodanDelayMs * batchSize;
    const totalBatchDelays = (totalBatches - 1) * delayBetweenBatches;
    const estimatedTimeMs = (timePerBatchMs * totalBatches) + totalBatchDelays + 1000;
    
    const estimatedSeconds = Math.ceil(estimatedTimeMs / 1000);
    const estimatedMinutes = Math.floor(estimatedSeconds / 60);
    const remainingSeconds = estimatedSeconds % 60;
    const timeEstimateStr = estimatedMinutes > 0 
        ? `${estimatedMinutes}m ${remainingSeconds}s` 
        : `${estimatedSeconds}s`;
    
    showToast(`Estimated time for Shodan enrichment: ~${timeEstimateStr}`, 'info');
    progressBar.textContent = `Shodan Enrichment: 0/${totalIPs} IPs (0%) - Est. ${timeEstimateStr}`;
    
    async function processBatch(batch) {
        for (const node of batch) {
            if (activeTaskController && activeTaskController.signal.aborted) {
                return false;
            }
            try {
                const baseUrl = ignoreApiKeysViaProxy ?
                    `https://api.shodan.io/shodan/host/${node.ip}` :
                    `https://api.shodan.io/shodan/host/${node.ip}?key=${shodanApiKey}`;
                const url = constructUrl(baseUrl, !ignoreApiKeysViaProxy);
                const response = await fetch(url, { signal: activeTaskController?.signal });
                if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                const data = await response.json();
                console.log(`Shodan response for ${node.ip}:`, JSON.stringify(data, null, 2));

                // Use the same processing logic as right-click enrichment
                await processShodanData(node.id, data);
                
                successfulEnrichments++;
            } catch (error) {
                if (error.name === 'AbortError') {
                    return false;
                }
                console.error(`Failed to enrich IP ${node.ip}: ${error.message}`);
                showToast(`Failed to enrich IP ${node.ip}: ${error.message}`, 'error');
            }
            await new Promise(resolve => setTimeout(resolve, shodanDelayMs)); // Respect Shodan rate limit
        }
        return true;
    }
    
    let lastProgressUpdate = 0;
    const progressUpdateInterval = 500;
    const startTime = Date.now();

    try {
        for (let i = 0; i < totalIPs; i += batchSize) {
            if (activeTaskController && activeTaskController.signal.aborted) {
                showToast('Shodan enrichment stopped', 'info');
                progressBar.textContent = `Shodan Enrichment: Stopped at ${successfulEnrichments}/${totalIPs} IPs`;
                break;
            }
            
            const batch = ipNodes.slice(i, Math.min(i + batchSize, totalIPs));
            console.log(`Processing batch ${Math.floor(i / batchSize) + 1} of ${totalBatches}, IPs ${i} to ${Math.min(i + batchSize - 1, totalIPs - 1)}`);
            
            const batchSuccess = await processBatch(batch);
            
            if (batchSuccess) {
                updateNodeSizes();
                updateSelectOptions();
            }
            
            const currentTime = Date.now();
            const processedIPs = Math.min(i + batchSize, totalIPs);
            const progress = ((processedIPs / totalIPs) * 100).toFixed(1);
            
            if (currentTime - lastProgressUpdate >= progressUpdateInterval || processedIPs === totalIPs) {
                const elapsedTimeMs = currentTime - startTime;
                const timePerIp = successfulEnrichments > 0 ? elapsedTimeMs / successfulEnrichments : shodanDelayMs;
                const remainingIPs = totalIPs - successfulEnrichments;
                const remainingTimeMs = remainingIPs * timePerIp;
                const remainingSeconds = Math.ceil(remainingTimeMs / 1000);
                const remainingMinutes = Math.floor(remainingSeconds / 60);
                const remainingSecondsPart = remainingSeconds % 60;
                const remainingTimeStr = remainingMinutes > 0 
                    ? `${remainingMinutes}m ${remainingSecondsPart}s` 
                    : `${remainingSeconds}s`;
                
                progressBar.textContent = `Shodan Enrichment: ${successfulEnrichments}/${totalIPs} IPs (${progress}%) - Est. ${remainingTimeStr} remaining`;
                lastProgressUpdate = currentTime;
            }
            
            await new Promise(resolve => setTimeout(resolve, delayBetweenBatches));
        }
    } finally {
        updateNodeSizes();
        updateSelectOptions();
        updateTheme();
        
        await stabilizeNetwork();
        ensureInteractionSettings();

        if (!(activeTaskController && activeTaskController.signal.aborted)) {
            completeProgressBar();
            showToast(`Shodan enrichment completed: ${successfulEnrichments}/${totalIPs} IPs enriched`, 'success');
        } else {
            showToast(`Shodan enrichment stopped: ${successfulEnrichments}/${totalIPs} IPs processed`, 'info');
        }
        
        if (window.innerWidth <= 768) {
            const controls = document.getElementById('controls');
            controls.classList.add('collapsed');
            document.getElementById('myNetwork').style.display = 'block';
            network.fit({ animation: { duration: 300, easingFunction: 'easeInOutQuad' } });
        }
    }
}

async function enrichAllInternetDB() {
    showProgressBar();
    network.setOptions({ physics: { enabled: false } });
    const ipNodes = nodes.get({ filter: n => n.type === 'ip' && n.ip });
    const totalIPs = ipNodes.length;
    let successfulEnrichments = 0;
    
    console.log(`Found ${totalIPs} IP nodes to enrich with InternetDB`);
    showToast(`Starting InternetDB enrichment for ${totalIPs} IPs`, 'info');
    
    const batchSize = 50;
    const delayBetweenBatches = 200;
    const totalBatches = Math.ceil(totalIPs / batchSize);
    const assumedRequestTimeMs = 100;
    const timePerBatchMs = assumedRequestTimeMs;
    const totalBatchDelays = (totalBatches - 1) * delayBetweenBatches;
    const estimatedTimeMs = (timePerBatchMs * totalBatches) + totalBatchDelays + 1000;
    
    const estimatedSeconds = Math.ceil(estimatedTimeMs / 1000);
    const estimatedMinutes = Math.floor(estimatedSeconds / 60);
    const remainingSeconds = estimatedSeconds % 60;
    const timeEstimateStr = estimatedMinutes > 0 
        ? `${estimatedMinutes}m ${remainingSeconds}s` 
        : `${estimatedSeconds}s`;
    
    showToast(`Estimated time for InternetDB enrichment: ~${timeEstimateStr}`, 'info');
    document.getElementById('progress-bar').textContent = `InternetDB Enrichment: 0/${totalIPs} IPs (0%) - Est. ${timeEstimateStr}`;
    
    // Deduplication maps
    const existingPorts = new Map(nodes.get({ filter: n => n.type === 'port' }).map(n => [`${n.portType}/${n.portNumber}`, n.id]));
    const existingDomains = new Map(nodes.get({ filter: n => n.type === 'domain' }).map(n => [n.domain, n.id]));
    const existingVulns = new Map(nodes.get({ filter: n => n.type === 'vulnerability' }).map(n => [n.cve, n.id]));
    const existingTags = new Map(nodes.get({ filter: n => n.type === 'tag' }).map(n => [n.tag, n.id]));
    const existingCPEs = new Map(nodes.get({ filter: n => n.type === 'cpe' }).map(n => [n.cpe, n.id]));
    
    const newNodes = [];
    const newEdges = [];
    
    async function processBatch(batch) {
        const promises = batch.map(node => {
            if (activeTaskController && activeTaskController.signal.aborted) {
                return Promise.resolve(null);
            }
            const url = constructUrl(`https://internetdb.shodan.io/${node.ip}`);
            return fetch(url)
                .then(response => {
                    if (!response.ok) throw new Error('Failed to fetch InternetDB data');
                    return response.json();
                })
                .then(data => {
                    // Ports
                    if (data.ports && data.ports.length > 0) {
                        data.ports.forEach(port => {
                            const portKey = `TCP/${port}`;
                            let portId = existingPorts.get(portKey);
                            if (!portId) {
                                portId = nextId++;
                                newNodes.push({
                                    id: portId,
                                    type: 'port',
                                    label: `TCP/${port}`,
                                    title: `Port\nType: TCP\nNumber: ${port}`,
                                    color: { background: '#a78bfa' },
                                    portType: 'TCP',
                                    portNumber: port.toString()
                                });
                                existingPorts.set(portKey, portId);
                            }
                            const edgeId = `${node.id}-${portId}-Exposes`;
                            if (!newEdges.some(e => e.id === edgeId) && !edges.get(edgeId)) {
                                newEdges.push({ id: edgeId, from: node.id, to: portId, label: 'Exposes' });
                            }
                        });
                    }

                    // Hostnames
                    if (data.hostnames && data.hostnames.length > 0) {
                        data.hostnames.forEach(hostname => {
                            let domainId = existingDomains.get(hostname);
                            if (!domainId) {
                                domainId = nextId++;
                                newNodes.push({
                                    id: domainId,
                                    type: 'domain',
                                    label: `Domain: ${hostname}`,
                                    title: `Domain: ${hostname}`,
                                    color: { background: '#60a5fa' },
                                    domain: hostname
                                });
                                existingDomains.set(hostname, domainId);
                            }
                            const edgeId = `${node.id}-${domainId}-ResolvesTo`;
                            if (!newEdges.some(e => e.id === edgeId) && !edges.get(edgeId)) {
                                newEdges.push({ id: edgeId, from: node.id, to: domainId, label: 'Resolves to' });
                            }
                        });
                    }

                    // Vulnerabilities
                    if (data.cves && data.cves.length > 0) {
                        data.cves.forEach(cve => {
                            let cveId = existingVulns.get(cve);
                            if (!cveId) {
                                cveId = nextId++;
                                newNodes.push({
                                    id: cveId,
                                    type: 'vulnerability',
                                    label: `Vulnerability: ${cve}`,
                                    title: `Vulnerability\nName: ${cve}\nCVE: ${cve}`,
                                    color: { background: '#dc2626' },
                                    vulnName: cve,
                                    cve: cve,
                                    url: `https://nvd.nist.gov/vuln/detail/${cve}`
                                });
                                existingVulns.set(cve, cveId);
                            }
                            const edgeId = `${node.id}-${cveId}-Has`;
                            if (!newEdges.some(e => e.id === edgeId) && !edges.get(edgeId)) {
                                newEdges.push({ id: edgeId, from: node.id, to: cveId, label: 'Has' });
                            }
                        });
                    }

                    // Tags
                    if (data.tags && data.tags.length > 0) {
                        data.tags.forEach(tag => {
                            let tagId = existingTags.get(tag);
                            if (!tagId) {
                                tagId = nextId++;
                                newNodes.push({
                                    id: tagId,
                                    type: 'tag',
                                    label: `Tag: ${tag}`,
                                    title: `Tag: ${tag}`,
                                    color: { background: '#6d28d9' },
                                    tag: tag
                                });
                                existingTags.set(tag, tagId);
                            }
                            const edgeId = `${node.id}-${tagId}-Tagged`;
                            if (!newEdges.some(e => e.id === edgeId) && !edges.get(edgeId)) {
                                newEdges.push({ id: edgeId, from: node.id, to: tagId, label: 'Tagged' });
                            }
                        });
                    }

                    // CPEs
                    if (data.cpes && data.cpes.length > 0) {
                        data.cpes.forEach(cpe => {
                            let cpeId = existingCPEs.get(cpe);
                            if (!cpeId) {
                                cpeId = nextId++;
                                newNodes.push({
                                    id: cpeId,
                                    type: 'cpe',
                                    label: `CPE: ${cpe.split(':')[3] || cpe}`,
                                    title: `CPE: ${cpe}`,
                                    color: { background: '#0d9488' },
                                    cpe: cpe
                                });
                                existingCPEs.set(cpe, cpeId);
                            }
                            const edgeId = `${node.id}-${cpeId}-Runs`;
                            if (!newEdges.some(e => e.id === edgeId) && !edges.get(edgeId)) {
                                newEdges.push({ id: edgeId, from: node.id, to: cpeId, label: 'Runs' });
                            }
                        });
                    }

                    successfulEnrichments++;
                })
                .catch(error => {
                    console.error(`Failed to enrich IP ${node.ip}: ${error.message}`);
                    showToast(`Failed to enrich IP ${node.ip}: ${error.message}`, 'error');
                    return null;
                });
        });
        await Promise.all(promises);
    }
    
    let lastProgressUpdate = 0;
    const progressUpdateInterval = 1000;
    const startTime = Date.now();
    
    for (let i = 0; i < totalIPs; i += batchSize) {
        if (activeTaskController && activeTaskController.signal.aborted) {
            showToast('InternetDB enrichment stopped', 'info');
            break;
        }
        
        const batch = ipNodes.slice(i, Math.min(i + batchSize, totalIPs));
        console.log(`Processing batch ${Math.floor(i / batchSize) + 1} of ${totalBatches}, IPs ${i} to ${Math.min(i + batchSize - 1, totalIPs - 1)}`);
        
        await processBatch(batch);
        
        if (newNodes.length > 0) {
            nodes.add(newNodes);
            newNodes.length = 0;
        }
        if (newEdges.length > 0) {
            edges.add(newEdges);
            newEdges.length = 0;
        }
        
        const currentTime = Date.now();
        if (currentTime - lastProgressUpdate >= progressUpdateInterval) {
            const processedIPs = Math.min(i + batchSize, totalIPs);
            const progress = ((processedIPs / totalIPs) * 100).toFixed(1);
            const remainingIPs = totalIPs - processedIPs;
            const remainingTimeMs = Math.max(0, remainingIPs * assumedRequestTimeMs);
            const remainingSeconds = Math.ceil(remainingTimeMs / 1000);
            const remainingMinutes = Math.floor(remainingSeconds / 60);
            const remainingSecondsPart = remainingSeconds % 60;
            const remainingTimeStr = remainingMinutes > 0 
                ? `${remainingMinutes}m ${remainingSecondsPart}s` 
                : `${remainingSeconds}s`;
            
            document.getElementById('progress-bar').textContent = 
                `InternetDB Enrichment: ${successfulEnrichments}/${totalIPs} IPs (${progress}%) - Est. ${remainingTimeStr} remaining`;
            lastProgressUpdate = currentTime;
            updateSelectOptions();
        }
        
        await new Promise(resolve => setTimeout(resolve, delayBetweenBatches));
    }
    
    if (newNodes.length > 0) nodes.add(newNodes);
    if (newEdges.length > 0) edges.add(newEdges);
    updateNodeSizes();
    updateSelectOptions();
    await stabilizeNetwork();
    ensureInteractionSettings();
    completeProgressBar();
    showToast(`InternetDB enrichment completed: ${successfulEnrichments}/${totalIPs} IPs enriched`, 'success');
    
    if (window.innerWidth <= 768) {
        const controls = document.getElementById('controls');
        controls.classList.add('collapsed');
        document.getElementById('myNetwork').style.display = 'block';
        network.fit({ animation: { duration: 300, easingFunction: 'easeInOutQuad' } });
    }
}

const throttledEnrichIP = throttleRequest(async function enrichIP(ip, ipNodeId, isBulk = false, signal) {
    if (!ipinfoApiKey && !ignoreApiKeysViaProxy) { 
        showToast('Please set your IPinfo API key in the "API Keys" tab first.', 'error'); 
        return; 
    }
    network.setOptions({ physics: { enabled: false } });
    try {
        const baseUrl = ignoreApiKeysViaProxy ? 
            `https://ipinfo.io/${ip}/json` : 
            `https://ipinfo.io/${ip}/json?token=${ipinfoApiKey}`;
        const url = constructUrl(baseUrl, !ignoreApiKeysViaProxy);
        const response = await fetch(url, { signal });
        if (!response.ok) throw new Error('Failed to fetch IP info');
        const data = await response.json();
        
        const asn = data.asn?.asn || 'Unknown ASN';
        const city = data.city || 'Unknown City';
        const companyName = data.company?.name || 'Unknown Company';
        const country = data.country || 'Unknown Country';
        const privacy = data.privacy || { vpn: false, proxy: false, tor: false, relay: false, hosting: false };

        const newNodes = [];
        const newEdges = [];
        
        // Pre-collect existing nodes for deduplication
        let existingAsns = new Map(nodes.get({ filter: n => n.type === 'asn' }).map(n => [n.asn, n.id]));
        let existingCities = new Map(nodes.get({ filter: n => n.type === 'city' }).map(n => [n.city, n.id]));
        let existingOrgs = new Map(nodes.get({ filter: n => n.type === 'organization' }).map(n => [n.organization, n.id]));
        let existingCountries = new Map(nodes.get({ filter: n => n.type === 'country' }).map(n => [n.country, n.id]));
        let existingPrivacyTypes = new Map([
            ['vpn', null], ['proxy', null], ['tor', null], ['relay', null], ['hosting', null]
        ].map(([type]) => {
            const existing = nodes.get({ filter: n => n.type === type })[0];
            return [type, existing ? existing.id : null];
        }));

        const privacyTypes = [
            { key: 'vpn', label: 'VPN', color: '#9333ea' },
            { key: 'proxy', label: 'Proxy', color: '#f43f5e' },
            { key: 'tor', label: 'Tor', color: '#64748b' },
            { key: 'relay', label: 'Relay', color: '#eab308' },
            { key: 'hosting', label: 'Hosting', color: '#14b8a6' }
        ];

        // Helper function to add node and edge with unique ID
        const addNodeAndEdge = (type, key, value, labelPrefix, title, color, edgeLabel) => {
            let targetId = existingAsns.get(value) || existingCities.get(value) || existingOrgs.get(value) || existingCountries.get(value);
            if (!targetId) {
                targetId = nextId++;
                newNodes.push({ 
                    id: targetId, 
                    type: type, 
                    label: `${labelPrefix}: ${value}`, 
                    title: title, 
                    color: { background: color }, 
                    [key]: value 
                });
                if (type === 'asn') existingAsns.set(value, targetId);
                else if (type === 'city') existingCities.set(value, targetId);
                else if (type === 'organization') existingOrgs.set(value, targetId);
                else if (type === 'country') existingCountries.set(value, targetId);
            }
            const edgeId = `${ipNodeId}-${targetId}-${edgeLabel}`;
            if (!edges.get(edgeId) && !newEdges.some(e => e.id === edgeId)) {
                newEdges.push({ id: edgeId, from: ipNodeId, to: targetId, label: edgeLabel });
            }
        };

        // Add nodes and edges
        addNodeAndEdge('asn', 'asn', asn, 'ASN', `ASN: ${asn}`, '#a3e635', 'Assigned to');
        addNodeAndEdge('city', 'city', city, 'City', `City: ${city}`, '#f97316', 'Located in');
        addNodeAndEdge('organization', 'organization', companyName, 'Organization', `Company: ${companyName}`, '#facc15', 'Belongs to');
        addNodeAndEdge('country', 'country', country, 'Country', `Country: ${country}`, '#34d399', 'Located in');

        // Privacy Types
        privacyTypes.forEach(privacyType => {
            if (privacy[privacyType.key]) {
                let privacyNodeId = existingPrivacyTypes.get(privacyType.key);
                if (!privacyNodeId) {
                    privacyNodeId = nextId++;
                    newNodes.push({ 
                        id: privacyNodeId, 
                        type: privacyType.key, 
                        label: privacyType.label, 
                        title: privacyType.label, 
                        color: { background: privacyType.color }
                    });
                    existingPrivacyTypes.set(privacyType.key, privacyNodeId);
                }
                const edgeId = `${ipNodeId}-${privacyNodeId}-Uses`;
                if (!edges.get(edgeId) && !newEdges.some(e => e.id === edgeId)) {
                    newEdges.push({ id: edgeId, from: ipNodeId, to: privacyNodeId, label: 'Uses' });
                }
            }
        });

        // Batch update
        if (newNodes.length > 0) nodes.add(newNodes);
        if (newEdges.length > 0) edges.add(newEdges);

        updateNodeSizes();
        updateSelectOptions();
        await stabilizeNetwork();
        if (!isBulk) showToast(`IP ${ip} enrichment completed using IPinfo`, 'success');
    } catch (error) {
        if (error.name === 'AbortError') {
            showToast(`Enrichment of IP ${ip} was cancelled`, 'info');
            return;
        }
        console.error(`Error enriching IP ${ip}: ${error.message}`);
        showToast(`Error enriching IP ${ip}: ${error.message}`, 'error');
        await stabilizeNetwork();
    }
}, RATE_LIMIT_MS);


const throttledEnrichShodan = throttleRequest(async function enrichShodan(ip, ipNodeId, isBulk = false, signal) {
    if (!shodanApiKey && !ignoreApiKeysViaProxy) { 
        showToast('Please set your Shodan API key in the "API Keys" tab first.', 'error'); 
        return; 
    }
    
    if (!isBulk) network.setOptions({ physics: { enabled: false } });
    
    try {
        const baseUrl = ignoreApiKeysViaProxy ? 
            `https://api.shodan.io/shodan/host/${ip}` : 
            `https://api.shodan.io/shodan/host/${ip}?key=${shodanApiKey}`;
        const url = constructUrl(baseUrl, !ignoreApiKeysViaProxy);
        const response = await fetch(url, { signal });
        if (!response.ok) throw new Error(`Failed to fetch Shodan data: ${response.statusText}`);
        const data = await response.json();

        // Process Shodan data using the shared helper
        await processShodanData(ipNodeId, data);

        updateNodeSizes();
        updateSelectOptions();
        if (!isBulk) {
            await stabilizeNetwork();
            updateTheme();
            showToast(`IP ${ip} enrichment completed using Shodan`, 'success');
        }
    } catch (error) {
        if (error.name === 'AbortError') {
            showToast(`Enrichment of IP ${ip} was cancelled`, 'info');
            return;
        }
        console.error(`Error enriching IP ${ip} with Shodan: ${error.message}`);
        showToast(`Error enriching IP ${ip} with Shodan: ${error.message}`, 'error');
        if (!isBulk) await stabilizeNetwork();
    }
}, SHODAN_RATE_LIMIT_MS);



async function importIOCsFromText() {
    const text = document.getElementById('iocText').value.trim();
    if (!text) { showToast('Please enter some text containing IOCs', 'error'); return; }
    await processIOCs(text);
    document.getElementById('iocText').value = '';
    saveStateAfterOperation();
    showToast('IOCs (including emails) import completed', 'success');
}



async function importIOCsFromFile() {
    const fileInput = document.getElementById('iocFile');
    const file = fileInput.files[0];
    if (!file) { showToast('Please select a text file containing IOCs', 'error'); return; }
    const reader = new FileReader();
    reader.onload = async function(event) { 
        await processIOCs(event.target.result); 
        fileInput.value = ''; 
        saveStateAfterOperation();
        showToast('IOCs (including emails) import completed', 'success');
    };
    reader.readAsText(file);
}



        async function processIOCs(text) {
    // Disable physics for the duration of the import
    network.setOptions({ physics: { enabled: false } });
    
    // Pre-collect all matches to avoid multiple regex passes
    const ipMatches = new Set(text.match(/(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)|(?:[0-9a-fA-F]{0,4}:){7}[0-9a-fA-F]{0,4}/g) || []);
    const domainMatches = new Set(text.match(/(?!:\/\/)([a-zA-Z0-9-_]+\.)*[a-zA-Z0-9][a-zA-Z0-9-_]+\.[a-zA-Z]{2,}/g) || []);
    const emailMatches = new Set(text.match(emailRegex) || []);

    const totalItems = ipMatches.size + domainMatches.size + emailMatches.size;
    if (totalItems === 0) {
        showToast('No IOCs found in text', 'info');
        return;
    }

    // Maps to track existing nodes and avoid lookups
    const existingNodes = new Map();
    nodes.forEach(node => {
        if (node.type === 'ip' && node.ip) existingNodes.set(`ip:${node.ip}`, node);
        if (node.type === 'domain' && node.domain) existingNodes.set(`domain:${node.domain}`, node);
        if (node.type === 'contact' && node.email) existingNodes.set(`email:${node.email}`, node);
    });

    const newNodes = [];
    const newEdges = [];
    let processedCount = 0;
    const batchSize = 50; // Process in batches of 50

    // Process IPs
    for (const ip of ipMatches) {
        if ((ipRegex.ipv4.test(ip) || ipRegex.ipv6.test(ip)) && !existingNodes.has(`ip:${ip}`)) {
            const nodeId = nextId++;
            newNodes.push({
                id: nodeId,
                type: 'ip',
                label: `IP: ${ip}`,
                title: `IP Address: ${ip}`,
                color: { background: '#f87171' },
                ip: ip,
                size: 20
            });
            existingNodes.set(`ip:${ip}`, { id: nodeId });
        }
    }

    // Process domains from domain matches
    for (const domain of domainMatches) {
        if (domainRegex.test(domain) && !existingNodes.has(`domain:${domain}`)) {
            const nodeId = nextId++;
            newNodes.push({
                id: nodeId,
                type: 'domain',
                label: `Domain: ${domain}`,
                title: `Domain: ${domain}`,
                color: { background: '#60a5fa' },
                domain: domain,
                size: 20
            });
            existingNodes.set(`domain:${domain}`, { id: nodeId });
        }
    }

    // Process emails and link to domains
    for (const email of emailMatches) {
        if (!existingNodes.has(`email:${email}`)) {
            const emailNodeId = nextId++;
            const emailDomain = email.split('@')[1];

            // Add email node
            newNodes.push({
                id: emailNodeId,
                type: 'contact',
                label: `Contact: ${email}`,
                title: `Contact\nEmail: ${email}`,
                color: { background: '#4ade80' },
                email: email,
                name: email.split('@')[0],
                size: 10
            });
            existingNodes.set(`email:${email}`, { id: emailNodeId });

            // Find or create domain node
            let domainNode = existingNodes.get(`domain:${emailDomain}`);
            if (!domainNode) {
                const domainNodeId = nextId++;
                newNodes.push({
                    id: domainNodeId,
                    type: 'domain',
                    label: `Domain: ${emailDomain}`,
                    title: `Domain: ${emailDomain}`,
                    color: { background: '#60a5fa' },
                    domain: emailDomain,
                    size: 20
                });
                domainNode = { id: domainNodeId };
                existingNodes.set(`domain:${emailDomain}`, domainNode);
            }

            // Add edge
            const edgeId = `edge_${emailNodeId}_${domainNode.id}_${Date.now()}`;
            if (!edges.get({ filter: e => e.from === emailNodeId && e.to === domainNode.id }).length) {
                newEdges.push({
                    id: edgeId,
                    from: emailNodeId,
                    to: domainNode.id,
                    label: 'Registered with'
                });
            }

            // Batch processing
            processedCount++;
            if (processedCount % batchSize === 0) {
                nodes.add(newNodes);
                edges.add(newEdges);
                newNodes.length = 0;
                newEdges.length = 0;
                await new Promise(resolve => setTimeout(resolve, 0)); // Allow UI to breathe
                showToast(`Processed ${processedCount} of ${emailMatches.size} emails`, 'info');
            }
        }
    }

    // Add remaining items
    if (newNodes.length > 0) nodes.add(newNodes);
    if (newEdges.length > 0) edges.add(newEdges);

    // Update UI once at the end
    updateNodeSizes();
    updateSelectOptions();

    // Re-enable physics and stabilize
    await stabilizeNetwork();
    showToast(`Imported ${ipMatches.size} IPs, ${domainMatches.size} domains, and ${emailMatches.size} emails`, 'success');
}

        function saveIpinfoApiKey() {
            ipinfoApiKey = document.getElementById('ipinfoApiKey').value.trim();
            const storeKey = document.getElementById('storeIpinfoKey').checked;
            if (ipinfoApiKey) {
                if (storeKey) localStorage.setItem('ipinfoApiKey', ipinfoApiKey); else localStorage.removeItem('ipinfoApiKey');
                showToast('IPinfo API key saved successfully!', 'success');
            } else {
                localStorage.removeItem('ipinfoApiKey');
                showToast('Please enter a valid IPinfo API key.', 'error');
            }
        }

        function saveShodanApiKey() {
            shodanApiKey = document.getElementById('shodanApiKey').value.trim();
            const storeKey = document.getElementById('storeShodanKey').checked;
            if (shodanApiKey) {
                if (storeKey) localStorage.setItem('shodanApiKey', shodanApiKey); else localStorage.removeItem('shodanApiKey');
                showToast('Shodan API key saved successfully!', 'success');
            } else {
                localStorage.removeItem('shodanApiKey');
                showToast('Please enter a valid Shodan API key.', 'error');
            }
        }
        
        function updateTheme() {
    if (isDarkMode) {
        document.body.classList.remove('light-mode');
        document.body.classList.add('dark-mode');
        options.nodes.font = {
            size: nodeLabelsVisible ? 12 : 0,
            color: '#e2e8f0',  // Light color for dark mode
            multi: true,
            align: 'center',
            vadjust: 0,
            strokeWidth: 0
        };
        options.edges.font = {
            size: edgeLabelsVisible ? 12 : 0,
            color: '#e2e8f0',  // Light color for dark mode
            strokeWidth: 0,
            strokeColor: 'transparent',
            align: 'middle',
            multi: true
        };
    } else {
        document.body.classList.remove('dark-mode');
        document.body.classList.add('light-mode');
        options.nodes.font = {
            size: nodeLabelsVisible ? 12 : 0,
            color: '#1f2a44',  // Dark color for light mode
            multi: true,
            align: 'center',
            vadjust: 0,
            strokeWidth: 0
        };
        options.edges.font = {
            size: edgeLabelsVisible ? 12 : 0,
            color: '#1f2a44',  // Dark color for light mode
            strokeWidth: 0,
            strokeColor: 'transparent',
            align: 'middle',
            multi: true
        };
    }

    // Update all existing nodes and edges with the new font settings
    nodes.forEach(node => {
        nodes.update({
            id: node.id,
            font: options.nodes.font
        });
    });
    
    edges.forEach(edge => {
        edges.update({
            id: edge.id,
            font: options.edges.font
        });
    });

    // Apply the options to the network and force a redraw
    network.setOptions(options);
    updateLabelVisibility();
    ensureInteractionSettings();
    network.setData({ nodes: nodes, edges: edges });  // Force data refresh
    network.redraw();
}

function toggleMode() {
    isDarkMode = !isDarkMode;
    updateTheme();
    document.getElementById('mode-toggle').textContent = isDarkMode ? 'Switch to Light Mode' : 'Switch to Dark Mode';
}

        function togglePhysics() {
    isPhysicsPaused = !isPhysicsPaused;
    const pauseButton = document.getElementById('pause-toggle');
    network.setOptions({ 
        physics: { 
            enabled: !isPhysicsPaused,
            barnesHut: {
                // Ensure consistent physics settings
                gravitationalConstant: -8000,
                centralGravity: 0.1,
                springLength: 200,
                springConstant: 0.04,
                damping: 0.9,
                avoidOverlap: 0.5
            },
            maxVelocity: 25,
            minVelocity: 0.1
        },
        interaction: { ...baseInteractionOptions }
    });
    pauseButton.textContent = isPhysicsPaused ? 'Resume Physics' : 'Pause Physics';
    pauseButton.classList.toggle('paused', isPhysicsPaused);
    if (!isPhysicsPaused) {
        // Trigger stabilization when resuming physics
        stabilizeNetwork();
    }
    ensureInteractionSettings();
    }

        function resetLayout() {
            nodes.forEach(node => nodes.update({ id: node.id, x: undefined, y: undefined }));
            stabilizeNetwork(false);
        }

        function setOrganicLayout() {
    network.setOptions({
        physics: {
            enabled: true,
            stabilization: {
                enabled: true,
                iterations: 200
            },
            barnesHut: {
                gravitationalConstant: -8000,
                centralGravity: 0.3,
                springLength: 150,
                springConstant: 0.05,
                damping: 0.9,
                avoidOverlap: 1.0
            },
            maxVelocity: 50,
            minVelocity: 0.1
        },
        layout: { 
            hierarchical: false,
            improvedLayout: true 
        },
        interaction: { ...baseInteractionOptions }
    });

    // Reset node positions
    nodes.forEach(node => {
        nodes.update({ 
            id: node.id, 
            x: undefined, 
            y: undefined,
            fixed: { x: false, y: false }
        });
    });

    stabilizeNetwork().then(() => {
        isPhysicsPaused = true;
        network.setOptions({ physics: { enabled: false } });
        const pauseButton = document.getElementById('pause-toggle');
        pauseButton.textContent = 'Resume Physics';
        pauseButton.classList.add('paused');
    });
}

function setCircularLayout() {
    network.setOptions({
        physics: { enabled: false },
        layout: { hierarchical: false },
        interaction: { ...baseInteractionOptions }
    });

    const containerRect = container.getBoundingClientRect();
    const radius = Math.min(containerRect.width, containerRect.height) / 2 - 100;
    const nodeCount = nodes.length;
    const angleStep = (2 * Math.PI) / nodeCount;
    const centerX = containerRect.width / 2;
    const centerY = containerRect.height / 2;

    nodes.forEach((node, i) => {
        const x = centerX + radius * Math.cos(angleStep * i);
        const y = centerY + radius * Math.sin(angleStep * i);
        nodes.update({
            id: node.id,
            x: x,
            y: y,
            fixed: { x: true, y: true }
        });
    });

    network.fit({
        animation: {
            duration: 500,
            easingFunction: 'easeInOutQuad'
        }
    });
}

function setOrthogonalLayout() {
    network.setOptions({
        physics: { enabled: false },
        layout: { hierarchical: false },
        interaction: { ...baseInteractionOptions }
    });

    const containerRect = container.getBoundingClientRect();
    const gridSize = Math.ceil(Math.sqrt(nodes.length));
    const stepX = containerRect.width / (gridSize + 1);
    const stepY = containerRect.height / (gridSize + 1);
    let i = 0;

    nodes.forEach(node => {
        const x = (i % gridSize + 0.5) * stepX;
        const y = (Math.floor(i / gridSize) + 0.5) * stepY;
        nodes.update({
            id: node.id,
            x: x,
            y: y,
            fixed: { x: true, y: true }
        });
        i++;
    });

    network.fit({
        animation: {
            duration: 500,
            easingFunction: 'easeInOutQuad'
        }
    });
}

function setTreeLayout() {
    network.setOptions({
        physics: { enabled: false },
        layout: {
            hierarchical: {
                enabled: true,
                levelSeparation: 200,
                nodeSpacing: 150,
                treeSpacing: 200,
                direction: 'UD',
                sortMethod: 'hubsize',
                shakeTowards: 'leaves'
            }
        },
        edges: {
            smooth: {
                enabled: true,
                type: 'cubicBezier'
            }
        },
        interaction: { ...baseInteractionOptions }
    });

    // Reset positions before applying layout
    nodes.forEach(node => {
        nodes.update({
            id: node.id,
            x: undefined,
            y: undefined,
            fixed: { x: false, y: false }
        });
    });

    network.fit({
        animation: {
            duration: 500,
            easingFunction: 'easeInOutQuad'
        }
    });
}

function setHierarchicalLayout() {
    network.setOptions({
        physics: { enabled: false },
        layout: {
            hierarchical: {
                enabled: true,
                levelSeparation: 200,
                nodeSpacing: 150,
                treeSpacing: 200,
                direction: 'UD',
                sortMethod: 'directed',
                shakeTowards: 'roots'
            }
        },
        edges: {
            smooth: {
                enabled: true,
                type: 'cubicBezier'
            }
        },
        interaction: { ...baseInteractionOptions }
    });

    // Reset positions before applying layout
    nodes.forEach(node => {
        nodes.update({
            id: node.id,
            x: undefined,
            y: undefined,
            fixed: { x: false, y: false }
        });
    });

    network.fit({
        animation: {
            duration: 500,
            easingFunction: 'easeInOutQuad'
        }
    });
}

        function showTab(tabId) {
            document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
            document.getElementById(tabId).classList.add('active');
            document.querySelector(`.tab-button[onclick="showTab('${tabId}')"]`).classList.add('active');
        }

        document.getElementById('addEntityType').addEventListener('change', function() {
            let type = this.value;
            document.getElementById('addVulnNameInput').style.display = type === 'vulnerability' ? 'block' : 'none';
            document.getElementById('addVulnCVEInput').style.display = type === 'vulnerability' ? 'block' : 'none';
            document.getElementById('addVulnUrlInput').style.display = type === 'vulnerability' ? 'block' : 'none';
            document.getElementById('addNameInput').style.display = type === 'contact' ? 'block' : 'none';
            document.getElementById('addEmailInput').style.display = type === 'contact' ? 'block' : 'none';
            document.getElementById('addIpInput').style.display = type === 'ip' ? 'block' : 'none';
            document.getElementById('addDomainInput').style.display = type === 'domain' ? 'block' : 'none';
            document.getElementById('addOrgInput').style.display = type === 'organization' ? 'block' : 'none';
            document.getElementById('addPortNumInput').style.display = type === 'port' ? 'block' : 'none';
            document.getElementById('addPortType').style.display = type === 'port' ? 'block' : 'none';
            document.getElementById('addWalletAddressInput').style.display = type === 'wallet' ? 'block' : 'none';
            document.getElementById('addAccountNumberInput').style.display = type === 'bank' ? 'block' : 'none';
            document.getElementById('addSortCodeInput').style.display = type === 'bank' ? 'block' : 'none';
            document.getElementById('addTechNameInput').style.display = type === 'technology' ? 'block' : 'none';
            document.getElementById('addTechVersionInput').style.display = type === 'technology' ? 'block' : 'none';
            document.getElementById('addDeviceCategory').style.display = type === 'device' ? 'block' : 'none';
            document.getElementById('addDeviceNameInput').style.display = type === 'device' ? 'block' : 'none';
            document.getElementById('addMalwareNameInput').style.display = type === 'malware' ? 'block' : 'none';
            document.getElementById('addMalwareType').style.display = type === 'malware' ? 'block' : 'none';
        });

function createNodeData(type, values) {
    const nodeData = { 
        id: nextId++, 
        size: 10,
        type,
        widthConstraint: false,
        heightConstraint: false
    };
    
    const configs = {
        vulnerability: { 
            fields: ['vulnName'], 
            optionalFields: ['cve', 'url'], 
            color: '#dc2626', // Red color for vulnerabilities
            label: v => {
                let label = `Vulnerability: ${v.vulnName}`;
                if (v.cve) label += `\nCVE: ${v.cve}`;
                if (v.url) label += `\nURL: ${v.url}`;
                return label;
            }, 
            title: v => {
                let title = `Vulnerability\nName: ${v.vulnName}`;
                if (v.cve) title += `\nCVE: ${v.cve}`;
                if (v.url) title += `\nURL: ${v.url}`;
                return title;
            }
        },
        contact: { 
            fields: ['name'], 
            optionalFields: ['email'], 
            color: '#4ade80', 
            label: v => `Contact: ${v.name}${v.email ? '\n' + v.email : ''}`, 
            title: v => v.email ? `Contact\nName: ${v.name}\nEmail: ${v.email}` : `Contact\nName: ${v.name}` 
        },
        ip: { 
            fields: ['ip'], 
            color: '#f87171', 
            label: v => `IP: ${v.ip}`, 
            title: v => `IP Address: ${v.ip}`,
            validate: v => ipRegex.ipv4.test(v.ip) || ipRegex.ipv6.test(v.ip) 
        },
        domain: { 
            fields: ['domain'], 
            color: '#60a5fa', 
            label: v => `Domain: ${v.domain}`, 
            title: v => `Domain: ${v.domain}` 
        },
        organization: { 
            fields: ['organization'], 
            color: '#facc15', 
            label: v => `Organization: ${v.organization}`, 
            title: v => `Organization: ${v.organization}` 
        },
        port: { 
            fields: ['portNumber', 'portType'], 
            color: '#a78bfa', 
            label: v => `Port: ${v.portType}/${v.portNumber}`, 
            title: v => `Port\nType: ${v.portType}\nNumber: ${v.portNumber}` 
        },
        wallet: { 
            fields: ['address'], 
            color: '#fb923c', 
            label: v => `Wallet: ${v.address}`, 
            title: v => `Wallet\nAddress: ${v.address}` 
        },
        bank: { 
            fields: ['accountNumber', 'sortCode'], 
            color: '#10b981', 
            label: v => `Bank: ${v.accountNumber}\nSort Code: ${v.sortCode}`, 
            title: v => `Bank Account\nAccount Number: ${v.accountNumber}\nSort Code: ${v.sortCode}` 
        },
        technology: { 
            fields: ['techName', 'techVersion'], 
            color: '#ec4899', 
            label: v => `Technology: ${v.techName}\nVersion: ${v.techVersion}`, 
            title: v => `Technology\nName: ${v.techName}\nVersion: ${v.techVersion}` 
        },
        device: { 
            fields: ['deviceCategory', 'deviceName'], 
            color: '#14b8a6', 
            label: v => `Device: ${v.deviceName}\nCategory: ${v.deviceCategory}`, 
            title: v => `Device\nName: ${v.deviceName}\nCategory: ${v.deviceCategory}` 
        },
        malware: { 
            fields: ['malwareName', 'malwareType'], 
            color: '#ef4444', 
            label: v => `Malware: ${v.malwareName}\nType: ${v.malwareType}`, 
            title: v => `Malware\nName: ${v.malwareName}\nType: ${v.malwareType}` 
        },
        favicon: { 
            fields: ['hash'], 
            optionalFields: ['location'], 
            color: '#22d3ee',
            label: v => `Favicon: ${v.hash.substring(0, 8)}...`, 
            title: v => `Favicon\nHash: ${v.hash}${v.location ? '\nPath: ' + v.location : ''}` 
        },
        http_hash: { 
            fields: ['hash'], 
            color: '#f97316', 
            label: v => `HTTP Hash: ${v.hash.substring(0, 8)}...`, 
            title: v => `HTTP Headers Hash\nSHA256: ${v.hash}` 
        },
        html_hash: { 
            fields: ['hash'], 
            color: '#f59e0b', 
            label: v => `HTML Hash: ${v.hash.substring(0, 8)}...`, 
            title: v => `HTML Hash\nSHA256: ${v.hash}` 
        },
        ssl_hash: { 
            fields: ['hash'], // Changed from 'fingerprint' to 'hash'
            color: '#8b5cf6', 
            label: v => `SSL Hash: ${v.hash.substring(0, 8)}...`, 
            title: v => `SSL Certificate Hash\nSHA256: ${v.hash}` // Updated title
        },
        // Fixed entries for privacy types
        vpn: { 
            fields: ['value'], 
            color: '#9333ea', 
            label: v => `VPN: ${v.value}`, 
            title: v => `VPN for IP: ${v.value}` 
        },
        proxy: { 
            fields: ['value'], 
            color: '#f43f5e', 
            label: v => `Proxy: ${v.value}`, 
            title: v => `Proxy for IP: ${v.value}` 
        },
        tor: { 
            fields: ['value'], 
            color: '#64748b', 
            label: v => `Tor: ${v.value}`, 
            title: v => `Tor for IP: ${v.value}` 
        },
        relay: { 
            fields: ['value'], 
            color: '#eab308', 
            label: v => `Relay: ${v.value}`, 
            title: v => `Relay for IP: ${v.value}` 
        },
        hosting: { 
            fields: ['value'], 
            color: '#14b8a6', 
            label: v => `Hosting: ${v.value}`, 
            title: v => `Hosting for IP: ${v.value}` 
        },
        tag: { 
            fields: ['tag'], 
            color: '#6d28d9', // Purple for tags
            label: v => `Tag: ${v.tag}`, 
            title: v => `Tag: ${v.tag}` 
        },
        cpe: { 
            fields: ['cpe'], 
            color: '#0d9488', // Teal for CPEs
            label: v => `CPE: ${v.cpe.split(':')[3] || v.cpe}`, // Show vendor or full CPE
            title: v => `CPE: ${v.cpe}` 
        }

    };

    configs.asn = { fields: ['asn'], color: '#a3e635', label: v => `ASN: ${v.asn}`, title: v => `ASN: ${v.asn}` };
    configs.city = { fields: ['city'], color: '#f97316', label: v => `City: ${v.city}`, title: v => `City: ${v.city}` };
    configs.country = { fields: ['country'], color: '#34d399', label: v => `Country: ${v.country}`, title: v => `Country: ${v.country}` };

    const config = configs[type];
    if (!config || config.fields.some(f => !values[f])) { 
        showToast(`Please enter all required fields for ${type}`, 'error'); 
        return null; 
    }
    if (config.validate && !config.validate(values)) { 
        showToast(`Invalid ${type} format`, 'error'); 
        return null; 
    }
    
    const allValues = { ...values };
    if (config.optionalFields) config.optionalFields.forEach(f => { if (values[f]) allValues[f] = values[f]; });
    
    Object.assign(nodeData, { 
        label: config.label(allValues), 
        title: config.title(allValues), 
        color: { background: config.color }, 
        ...allValues 
    });
    
    return nodeData;
}

function addNode() {
    const type = document.getElementById('addEntityType').value;
    
    // Collect inputs based on entity type
    const inputs = {
        vulnerability: { 
            vulnName: document.getElementById('addVulnNameInput').value.trim(),
            cve: document.getElementById('addVulnCVEInput').value.trim(),
            url: document.getElementById('addVulnUrlInput').value.trim()
        },
        contact: { 
            name: document.getElementById('addNameInput').value.trim(),
            email: document.getElementById('addEmailInput').value.trim()
        },
        ip: { 
            ip: document.getElementById('addIpInput').value.trim()
        },
        domain: { 
            domain: document.getElementById('addDomainInput').value.trim()
        },
        organization: { 
            organization: document.getElementById('addOrgInput').value.trim()
        },
        port: { 
            portNumber: document.getElementById('addPortNumInput').value.trim(),
            portType: document.getElementById('addPortType').value
        },
        wallet: { 
            address: document.getElementById('addWalletAddressInput').value.trim()
        },
        bank: { 
            accountNumber: document.getElementById('addAccountNumberInput').value.trim(),
            sortCode: document.getElementById('addSortCodeInput').value.trim()
        },
        technology: { 
            techName: document.getElementById('addTechNameInput').value.trim(),
            techVersion: document.getElementById('addTechVersionInput').value.trim()
        },
        device: { 
            deviceCategory: document.getElementById('addDeviceCategory').value,
            deviceName: document.getElementById('addDeviceNameInput').value.trim()
        },
        malware: { 
            malwareName: document.getElementById('addMalwareNameInput').value.trim(),
            malwareType: document.getElementById('addMalwareType').value
        }
    };

    // Get the node data using the inputs for the selected type
    const nodeData = createNodeData(type, inputs[type]);
    if (!nodeData) {
        // createNodeData already shows a toast for validation errors
        return;
    }

    // Check for duplicates based on key fields
    const existingNodes = nodes.get({
        filter: n => n.type === type && (
            (type === 'contact' && n.name === inputs[type].name && (!inputs[type].email || n.email === inputs[type].email)) ||
            (type === 'ip' && n.ip === inputs[type].ip) ||
            (type === 'domain' && n.domain === inputs[type].domain) ||
            (type === 'organization' && n.organization === inputs[type].organization) ||
            (type === 'port' && n.portNumber === inputs[type].portNumber && n.portType === inputs[type].portType) ||
            (type === 'wallet' && n.address === inputs[type].address) ||
            (type === 'bank' && n.accountNumber === inputs[type].accountNumber && n.sortCode === inputs[type].sortCode) ||
            (type === 'technology' && n.techName === inputs[type].techName && n.techVersion === inputs[type].techVersion) ||
            (type === 'device' && n.deviceCategory === inputs[type].deviceCategory && n.deviceName === inputs[type].deviceName) ||
            (type === 'malware' && n.malwareName === inputs[type].malwareName && n.malwareType === inputs[type].malwareType)
            (type === 'vulnerability' && n.vulnName === inputs[type].vulnName && 
             (!inputs[type].cve || n.cve === inputs[type].cve) && 
             (!inputs[type].url || n.url === inputs[type].url))
        )
    });

    if (existingNodes.length > 0) {
        showToast(`${type} already exists`, 'error');
        return;
    }

    // Add the node
    nodes.add({
        ...nodeData,
        size: 10, // Fixed initial size
        widthConstraint: false,
        heightConstraint: false
    });

    // Update UI and network
    updateSelectOptions();
    clearAddInputs();
    updateNodeSizes();
    stabilizeNetwork();
    saveStateAfterOperation();
    showToast(`${type} added successfully`, 'success');
}

        function editNode() {
            const nodeId = document.getElementById('editNodeSelect').value;
            if (!nodeId) { showToast('Please select a node to edit', 'error'); return; }
            const node = nodes.get(parseInt(nodeId));
            if (!node) { showToast('Selected node not found', 'error'); return; }

            const type = node.type;
            const inputs = {
                contact: { name: document.getElementById('editNameInput').value, email: document.getElementById('editEmailInput').value },
                ip: { ip: document.getElementById('editIpInput').value.trim() },
                domain: { domain: document.getElementById('editDomainInput').value },
                organization: { organization: document.getElementById('editOrgInput').value },
                port: { portNumber: document.getElementById('editPortNumInput').value, portType: document.getElementById('editPortType').value },
                wallet: { address: document.getElementById('editWalletAddressInput').value },
                bank: { accountNumber: document.getElementById('editAccountNumberInput').value, sortCode: document.getElementById('editSortCodeInput').value },
                technology: { techName: document.getElementById('editTechNameInput').value, techVersion: document.getElementById('editTechVersionInput').value },
                device: { deviceCategory: document.getElementById('editDeviceCategory').value, deviceName: document.getElementById('editDeviceNameInput').value },
                malware: { malwareName: document.getElementById('editMalwareNameInput').value, malwareType: document.getElementById('editMalwareType').value },
                vulnerability: {vulnName: document.getElementById('editVulnNameInput').value.trim(),
            cve: document.getElementById('editVulnCVEInput').value.trim(),
            url: document.getElementById('editVulnUrlInput').value.trim()
            }
            };
            const updatedNodeData = createNodeData(type, inputs[type]);
            if (updatedNodeData) {
                const existingNode = nodes.get({ filter: n => n.id !== parseInt(nodeId) && n.type === type && Object.keys(inputs[type]).every(key => n[key] === inputs[type][key]) });
                if (existingNode) { showToast(`Another ${type} with these values already exists`, 'error'); return; }
                updatedNodeData.id = node.id;
                nodes.update(updatedNodeData);
                updateSelectOptions();
                clearEditInputs();
                stabilizeNetwork();
                saveStateAfterOperation(); 
            }
        }

        function loadNodeForEdit() {
            const nodeId = document.getElementById('editNodeSelect').value;
            clearEditInputs();
            if (!nodeId) return;

            const node = nodes.get(parseInt(nodeId));
            if (!node) return;

            document.getElementById('editEntityType').value = node.type;
            switch (node.type) {
                case 'contact':
                    document.getElementById('editNameInput').value = node.name || '';
                    document.getElementById('editEmailInput').value = node.email || '';
                    break;
                case 'ip':
                    document.getElementById('editIpInput').value = node.ip || '';
                    break;
                case 'domain':
                    document.getElementById('editDomainInput').value = node.domain || '';
                    break;
                case 'organization':
                    document.getElementById('editOrgInput').value = node.organization || '';
                    break;
                case 'port':
                    document.getElementById('editPortNumInput').value = node.portNumber || '';
                    document.getElementById('editPortType').value = node.portType || 'TCP';
                    break;
                case 'wallet':
                    document.getElementById('editWalletAddressInput').value = node.address || '';
                    break;
                case 'bank':
                    document.getElementById('editAccountNumberInput').value = node.accountNumber || '';
                    document.getElementById('editSortCodeInput').value = node.sortCode || '';
                    break;
                case 'technology':
                    document.getElementById('editTechNameInput').value = node.techName || '';
                    document.getElementById('editTechVersionInput').value = node.techVersion || '';
                    break;
                case 'device':
                    document.getElementById('editDeviceCategory').value = node.deviceCategory || 'Server';
                    document.getElementById('editDeviceNameInput').value = node.deviceName || '';
                    break;
                case 'malware':
                    document.getElementById('editMalwareNameInput').value = node.malwareName || '';
                    document.getElementById('editMalwareType').value = node.malwareType || 'Wiper';
                    break;
                case 'vulnerability':
                    document.getElementById('editVulnNameInput').value = node.vulnName || '';
                    document.getElementById('editVulnCVEInput').value = node.cve || '';
                    document.getElementById('editVulnUrlInput').value = node.url || '';
                    break;
            }
            document.getElementById('editNameInput').style.display = node.type === 'contact' ? 'block' : 'none';
            document.getElementById('editEmailInput').style.display = node.type === 'contact' ? 'block' : 'none';
            document.getElementById('editIpInput').style.display = node.type === 'ip' ? 'block' : 'none';
            document.getElementById('editDomainInput').style.display = node.type === 'domain' ? 'block' : 'none';
            document.getElementById('editOrgInput').style.display = node.type === 'organization' ? 'block' : 'none';
            document.getElementById('editPortNumInput').style.display = node.type === 'port' ? 'block' : 'none';
            document.getElementById('editPortType').style.display = node.type === 'port' ? 'block' : 'none';
            document.getElementById('editWalletAddressInput').style.display = node.type === 'wallet' ? 'block' : 'none';
            document.getElementById('editAccountNumberInput').style.display = node.type === 'bank' ? 'block' : 'none';
            document.getElementById('editSortCodeInput').style.display = node.type === 'bank' ? 'block' : 'none';
            document.getElementById('editTechNameInput').style.display = node.type === 'technology' ? 'block' : 'none';
            document.getElementById('editTechVersionInput').style.display = node.type === 'technology' ? 'block' : 'none';
            document.getElementById('editDeviceCategory').style.display = node.type === 'device' ? 'block' : 'none';
            document.getElementById('editDeviceNameInput').style.display = node.type === 'device' ? 'block' : 'none';
            document.getElementById('editMalwareNameInput').style.display = node.type === 'malware' ? 'block' : 'none';
            document.getElementById('editMalwareType').style.display = node.type === 'malware' ? 'block' : 'none';
            document.getElementById('editVulnNameInput').style.display = node.type === 'vulnerability' ? 'block' : 'none';
            document.getElementById('editVulnCVEInput').style.display = node.type === 'vulnerability' ? 'block' : 'none';
            document.getElementById('editVulnUrlInput').style.display = node.type === 'vulnerability' ? 'block' : 'none';
        }

        function clearAddInputs() {
            document.querySelectorAll('#object-management .input-group:first-child input').forEach(input => input.value = '');
            document.getElementById('addDeviceCategory').value = 'Server';
            document.getElementById('addMalwareType').value = 'Wiper';
            document.getElementById('addPortType').value = 'TCP';
            document.getElementById('addVulnNameInput').value = '';
            document.getElementById('addVulnCVEInput').value = '';
            document.getElementById('addVulnUrlInput').value = '';
        }

        function clearEditInputs() {
            document.querySelectorAll('#object-management .input-group:nth-child(2) input').forEach(input => input.value = '');
            document.getElementById('editDeviceCategory').value = 'Server';
            document.getElementById('editMalwareType').value = 'Wiper';
            document.getElementById('editPortType').value = 'TCP';
            document.getElementById('editVulnNameInput').value = '';
            document.getElementById('editVulnCVEInput').value = '';
            document.getElementById('editVulnUrlInput').value = '';
        }

        
        function addEdge() {
            let from = document.getElementById('fromNode').value; 
            let to = document.getElementById('toNode').value; 
            let label = document.getElementById('edgeLabel').value;
            if (!from || !to || from === to) return showToast('Please select different nodes', 'error');
            edges.add({ 
        id: `edge_${from}_${to}_${Date.now()}`, 
        from: parseInt(from), 
        to: parseInt(to), 
        label: label || '',
        originalLabel: label || ''  // Add this line
    });
            updateNodeSizes(); 
            updateEdgeSelectOptions(); 
            document.getElementById('edgeLabel').value = ''; 
            stabilizeNetwork();
            saveStateAfterOperation();
        }

        function removeNode() {
            let nodeId = document.getElementById('removeNode').value;
            if (!nodeId) return showToast('Please select a node', 'error');
            edges.remove(edges.get({ filter: edge => edge.from === parseInt(nodeId) || edge.to === parseInt(nodeId) }));
            nodes.remove({ id: parseInt(nodeId) });
            updateNodeSizes(); 
            updateSelectOptions(); 
            stabilizeNetwork();
            saveStateAfterOperation();
        }

        function removeEdge() {
            let edgeId = document.getElementById('removeEdge').value;
            if (!edgeId) return showToast('Please select an edge', 'error');
            edges.remove({ id: edgeId });
            updateNodeSizes(); 
            updateEdgeSelectOptions(); 
            document.getElementById('removeEdge').value = ''; 
            stabilizeNetwork();
            saveStateAfterOperation();
        }

        function clearGraph() {
    if (!confirm('Are you sure you want to clear the entire graph? This action cannot be undone.')) return;
    nodes.clear();
    edges.clear();
    nextId = 1;
    updateSelectOptions();
    updateEdgeSelectOptions();
    clearAddInputs();
    clearEditInputs();
    stabilizeNetwork();
    saveStateAfterOperation();
    showToast('Graph cleared', 'success');
}

function updateNodeSizes(affectedNodeIds = null) {
    const nodesToUpdate = affectedNodeIds ? nodes.get(affectedNodeIds) : nodes.get();
    nodesToUpdate.forEach(node => {
        const connections = edges.get({ filter: edge => edge.from === node.id || edge.to === node.id }).length;
        const newSize = Math.min(15 + connections * 10, 120);
        nodes.update({ id: node.id, size: newSize, widthConstraint: false, heightConstraint: false });
    });
}




        function updateSelectOptions() {
            ['editNodeSelect', 'fromNode', 'toNode', 'removeNode'].forEach(id => {
                let select = document.getElementById(id);
                select.innerHTML = '<option value="">Select</option>';
                nodes.forEach(node => { 
                    let option = document.createElement('option'); 
                    option.value = node.id; 
                    option.text = node.label.split('\n')[0]; 
                    select.appendChild(option); 
                });
            });
            updateEdgeSelectOptions();
        }

        function updateEdgeSelectOptions() {
            let select = document.getElementById('removeEdge');
            select.innerHTML = '<option value="">Select Edge</option>';
            edges.forEach(edge => {
                let fromNode = nodes.get(edge.from); 
                let toNode = nodes.get(edge.to);
                if (fromNode && toNode) {
                    let option = document.createElement('option');
                    option.value = edge.id; 
                    option.text = `${fromNode.label.split('\n')[0]} -> ${toNode.label.split('\n')[0]}${edge.label ? ' (' + edge.label + ')' : ''}`;
                    select.appendChild(option);
                }
            });
        }

        function exportGraph() {
            const exportData = { 
                nodes: nodes.get().map(node => ({ 
                    id: node.id, type: node.type, name: node.name, email: node.email, ip: node.ip, domain: node.domain, 
                    organization: node.organization, portType: node.portType, portNumber: node.portNumber, address: node.address, 
                    accountNumber: node.accountNumber, sortCode: node.sortCode, techName: node.techName, techVersion: node.techVersion, 
                    deviceCategory: node.deviceCategory, deviceName: node.deviceName, malwareName: node.malwareName, malwareType: node.malwareType, 
                    country: node.country, asn: node.asn, city: node.city, value: node.value, vulnName: node.vulnName, cve: node.cve, url: node.url 
                })), 
                edges: edges.get().map(edge => ({ id: edge.id, from: edge.from, to: edge.to, label: edge.label })) 
            };
            const json = JSON.stringify(exportData, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); 
            a.href = url; 
            a.download = 'network_graph.json'; 
            a.click(); 
            URL.revokeObjectURL(url);
        }

        function importGraph() {
    const fileInput = document.getElementById('importFile');
    const file = fileInput.files[0];
    if (!file) {
        showToast('Please select a JSON file', 'error');
        return;
    }

    const reader = new FileReader();
    reader.onload = function(event) {
        try {
            const importedData = JSON.parse(event.target.result);
            if (!importedData.nodes || !importedData.edges) {
                throw new Error('Invalid JSON format: missing nodes or edges');
            }

            nodes.clear();
            edges.clear();

            importedData.nodes.forEach(node => {
                const nodeData = {
                    id: node.id,
                    size: node.size || 10,
                    type: node.type,
                    label: node.label,
                    title: node.title,
                    color: node.color || { background: '#ffffff' }, // Default color if missing
                    originalLabel: node.originalLabel,
                    x: node.x,
                    y: node.y
                };

                // Populate type-specific properties and set defaults
                switch (node.type) {
                    case 'contact':
                        if (!node.name) return;
                        nodeData.name = node.name;
                        nodeData.email = node.email;
                        nodeData.label = `Contact: ${node.email ? `${node.name}\n${node.email}` : node.name}`;
                        nodeData.title = node.email ? `Contact\nName: ${node.name}\nEmail: ${node.email}` : `Contact\nName: ${node.name}`;
                        nodeData.color.background = node.color?.background || '#4ade80';
                        break;
                    case 'ip':
                        if (!node.ip) return;
                        nodeData.ip = node.ip;
                        nodeData.label = `IP: ${node.ip}`;
                        nodeData.title = `IP Address: ${node.ip}`;
                        nodeData.color.background = node.color?.background || '#f87171';
                        break;
                    case 'domain':
                        if (!node.domain) return;
                        nodeData.domain = node.domain;
                        nodeData.label = `Domain: ${node.domain}`;
                        nodeData.title = `Domain: ${node.domain}`;
                        nodeData.color.background = node.color?.background || '#60a5fa';
                        break;
                    case 'organization':
                        if (!node.organization) return;
                        nodeData.organization = node.organization;
                        nodeData.label = `Organization: ${node.organization}`;
                        nodeData.title = `Organization: ${node.organization}`;
                        nodeData.color.background = node.color?.background || '#facc15';
                        break;
                    case 'port':
                        if (!node.portNumber || !node.portType) return;
                        nodeData.portType = node.portType;
                        nodeData.portNumber = node.portNumber;
                        nodeData.label = `Port: ${node.portType}/${node.portNumber}`;
                        nodeData.title = `Port\nType: ${node.portType}\nNumber: ${node.portNumber}`;
                        nodeData.color.background = node.color?.background || '#a78bfa';
                        break;
                    case 'wallet':
                        if (!node.address) return;
                        nodeData.address = node.address;
                        nodeData.label = `Wallet: ${node.address}`;
                        nodeData.title = `Wallet\nAddress: ${node.address}`;
                        nodeData.color.background = node.color?.background || '#fb923c';
                        break;
                    case 'bank':
                        if (!node.accountNumber || !node.sortCode) return;
                        nodeData.accountNumber = node.accountNumber;
                        nodeData.sortCode = node.sortCode;
                        nodeData.label = `Bank: ${node.accountNumber}\nSort Code: ${node.sortCode}`;
                        nodeData.title = `Bank Account\nAccount Number: ${node.accountNumber}\nSort Code: ${node.sortCode}`;
                        nodeData.color.background = node.color?.background || '#10b981';
                        break;
                    case 'technology':
                        if (!node.techName || !node.techVersion) return;
                        nodeData.techName = node.techName;
                        nodeData.techVersion = node.techVersion;
                        nodeData.label = `Technology: ${node.techName}\nVersion: ${node.techVersion}`;
                        nodeData.title = `Technology\nName: ${node.techName}\nVersion: ${node.techVersion}`;
                        nodeData.color.background = node.color?.background || '#ec4899';
                        break;
                    case 'device':
                        if (!node.deviceCategory || !node.deviceName) return;
                        nodeData.deviceCategory = node.deviceCategory;
                        nodeData.deviceName = node.deviceName;
                        nodeData.label = `Device: ${node.deviceName}\nCategory: ${node.deviceCategory}`;
                        nodeData.title = `Device\nName: ${node.deviceName}\nCategory: ${node.deviceCategory}`;
                        nodeData.color.background = node.color?.background || '#14b8a6';
                        break;
                    case 'malware':
                        if (!node.malwareName || !node.malwareType) return;
                        nodeData.malwareName = node.malwareName;
                        nodeData.malwareType = node.malwareType;
                        nodeData.label = `Malware: ${node.malwareName}\nType: ${node.malwareType}`;
                        nodeData.title = `Malware\nName: ${node.malwareName}\nType: ${node.malwareType}`;
                        nodeData.color.background = node.color?.background || '#ef4444';
                        break;
                    case 'vulnerability':
                        if (!node.vulnName) return;
                        nodeData.vulnName = node.vulnName;
                        nodeData.cve = node.cve;
                        nodeData.url = node.url;
                        nodeData.label = `Vulnerability: ${node.vulnName}${node.cve ? '\nCVE: ' + node.cve : ''}${node.url ? '\nURL: ' + node.url : ''}`;
                        nodeData.title = `Vulnerability\nName: ${node.vulnName}${node.cve ? '\nCVE: ' + node.cve : ''}${node.url ? '\nURL: ' + node.url : ''}`;
                        nodeData.color.background = node.color?.background || '#dc2626';
                        break;
                    case 'favicon':
                        if (!node.hash) return;
                        nodeData.hash = node.hash;
                        nodeData.location = node.location;
                        nodeData.label = `Favicon: ${node.hash.substring(0, 8)}...`;
                        nodeData.title = `Favicon\nHash: ${node.hash}${node.location ? '\nPath: ' + node.location : ''}`;
                        nodeData.color.background = node.color?.background || '#22d3ee';
                        break;
                    case 'http_hash':
                        if (!node.hash) return;
                        nodeData.hash = node.hash;
                        nodeData.label = `HTTP Hash: ${node.hash.substring(0, 8)}...`;
                        nodeData.title = `HTTP Headers Hash\nSHA256: ${node.hash}`;
                        nodeData.color.background = node.color?.background || '#f97316';
                        break;
                    case 'html_hash':
                        if (!node.hash) return;
                        nodeData.hash = node.hash;
                        nodeData.label = `HTML Hash: ${node.hash.substring(0, 8)}...`;
                        nodeData.title = `HTML Hash\nSHA256: ${node.hash}`;
                        nodeData.color.background = node.color?.background || '#f59e0b';
                        break;
                    case 'ssl_hash':
                        if (!node.hash) return;
                        nodeData.hash = node.hash;
                        nodeData.label = `SSL Hash: ${node.hash.substring(0, 8)}...`;
                        nodeData.title = `SSL Certificate Hash\nSHA256: ${node.hash}`;
                        nodeData.color.background = node.color?.background || '#8b5cf6';
                        break;
                    case 'asn':
                        if (!node.asn) return;
                        nodeData.asn = node.asn;
                        nodeData.label = `ASN: ${node.asn}`;
                        nodeData.title = `ASN: ${node.asn}`;
                        nodeData.color.background = node.color?.background || '#a3e635';
                        break;
                    case 'city':
                        if (!node.city) return;
                        nodeData.city = node.city;
                        nodeData.label = `City: ${node.city}`;
                        nodeData.title = `City: ${node.city}`;
                        nodeData.color.background = node.color?.background || '#f97316';
                        break;
                    case 'country':
                        if (!node.country) return;
                        nodeData.country = node.country;
                        nodeData.label = `Country: ${node.country}`;
                        nodeData.title = `Country: ${node.country}`;
                        nodeData.color.background = node.color?.background || '#34d399';
                        break;
                    case 'os':
                        if (!node.os) return;
                        nodeData.os = node.os;
                        nodeData.label = `OS: ${node.os}`;
                        nodeData.title = `Operating System: ${node.os}`;
                        nodeData.color.background = node.color?.background || '#10b981';
                        break;
                    case 'product':
                        if (!node.product) return;
                        nodeData.product = node.product;
                        nodeData.label = `Product: ${node.product}`;
                        nodeData.title = `Product: ${node.product}`;
                        nodeData.color.background = node.color?.background || '#ec4899';
                        break;
                    case 'http_title':
                        if (!node.title) return;
                        nodeData.title = node.title; // Already set as base property
                        nodeData.label = `Title: ${node.title}`;
                        nodeData.color.background = node.color?.background || '#3b82f6';
                        break;
                    case 'vpn':
                    case 'proxy':
                    case 'tor':
                    case 'relay':
                    case 'hosting':
                        if (!node.value) return;
                        nodeData.value = node.value;
                        nodeData.label = `${node.type.charAt(0).toUpperCase() + node.type.slice(1)}: ${node.value}`;
                        nodeData.title = `${node.type.charAt(0).toUpperCase() + node.type.slice(1)} for IP: ${node.value}`;
                        nodeData.color.background = node.color?.background || {
                            vpn: '#9333ea',
                            proxy: '#f43f5e',
                            tor: '#64748b',
                            relay: '#eab308',
                            hosting: '#14b8a6'
                        }[node.type];
                        break;
                    default:
                        console.warn(`Unhandled node type in importGraph: ${node.type}`);
                        return; // Skip unknown types
                }

                // Check for duplicates based on key properties
                if (!nodes.get({ filter: n => 
                    n.type === nodeData.type && (
                        (nodeData.ip && n.ip === nodeData.ip) ||
                        (nodeData.domain && n.domain === nodeData.domain) ||
                        (nodeData.organization && n.organization === nodeData.organization) ||
                        (nodeData.portNumber && nodeData.portType && n.portNumber === nodeData.portNumber && n.portType === nodeData.portType) ||
                        (nodeData.address && n.address === nodeData.address) ||
                        (nodeData.accountNumber && nodeData.sortCode && n.accountNumber === nodeData.accountNumber && n.sortCode === nodeData.sortCode) ||
                        (nodeData.techName && nodeData.techVersion && n.techName === nodeData.techName && n.techVersion === nodeData.techVersion) ||
                        (nodeData.deviceCategory && nodeData.deviceName && n.deviceCategory === nodeData.deviceCategory && n.deviceName === nodeData.deviceName) ||
                        (nodeData.malwareName && nodeData.malwareType && n.malwareName === nodeData.malwareName && n.malwareType === nodeData.malwareType) ||
                        (nodeData.vulnName && n.vulnName === nodeData.vulnName && (!nodeData.cve || n.cve === nodeData.cve) && (!nodeData.url || n.url === nodeData.url)) ||
                        (nodeData.hash && n.hash === nodeData.hash) || // For hash-based nodes
                        (nodeData.asn && n.asn === nodeData.asn) ||
                        (nodeData.city && n.city === nodeData.city) ||
                        (nodeData.country && n.country === nodeData.country) ||
                        (nodeData.os && n.os === nodeData.os) ||
                        (nodeData.product && n.product === nodeData.product) ||
                        (nodeData.value && n.value === nodeData.value)
                    )
                }).length) {
                    nodes.add(nodeData);
                }
            });

            // Import edges
            importedData.edges.forEach(edge => {
                if (edge.from && edge.to && nodes.get(edge.from) && nodes.get(edge.to)) { // Ensure nodes exist
                    if (!edges.get({ filter: e => e.from === edge.from && e.to === edge.to && e.label === (edge.label || undefined) }).length) {
                        edges.add({
                            id: edge.id || `edge_${edge.from}_${edge.to}_${Date.now()}`,
                            from: edge.from,
                            to: edge.to,
                            label: edge.label || undefined,
                            originalLabel: edge.originalLabel
                        });
                    }
                } else {
                    console.warn('Skipping edge due to missing nodes:', edge);
                }
            });

            // Update UI and state
            updateNodeSizes();
            updateSelectOptions();
            nextId = Math.max(...importedData.nodes.map(n => n.id)) + 1 || 1;
            fileInput.value = '';
            stabilizeNetwork();
            saveStateAfterOperation();
            showToast('Graph imported successfully', 'success');
        } catch (e) {
            console.error('Error importing JSON:', e);
            showToast('Error importing JSON: ' + e.message, 'error');
        }
    };
    reader.readAsText(file);
}


document.addEventListener('keypress', event => {
            if (event.key === 'Enter') {
                event.preventDefault();
                const activeElement = document.activeElement;
                if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA')) {
                    const start = activeElement.selectionStart; 
                    const end = activeElement.selectionEnd; 
                    const value = activeElement.value;
                    activeElement.value = value.substring(0, start) + '\r\n' + value.substring(end);
                    activeElement.selectionStart = activeElement.selectionEnd = start + 2;
                }
            }
        });

   
        function toggleNodeLabels() {
    nodeLabelsVisible = document.getElementById('showNodeLabels').checked;
    
    // Update each node individually while preserving original labels
    nodes.forEach(node => {
        // Ensure original label is stored
        if (!node.hasOwnProperty('originalLabel')) {
            node.originalLabel = node.label || '';
        }
        
        nodes.update({
            id: node.id,
            label: nodeLabelsVisible ? node.originalLabel : '',  // Toggle between original and empty
            font: {
                size: nodeLabelsVisible ? 12 : 0,
                color: isDarkMode ? '#e2e8f0' : '#1f2a44',
                multi: true,
                align: 'center',
                vadjust: 0,
                strokeWidth: 0
            }
        });
    });
    
    // Update global network options
    network.setOptions({
        nodes: {
            font: {
                size: nodeLabelsVisible ? 12 : 0,
                color: isDarkMode ? '#e2e8f0' : '#1f2a44',
                multi: true,
                align: 'center',
                vadjust: 0,
                strokeWidth: 0
            },
            chosen: {
                label: function(values, id, selected, hovering) {
                    values.size = nodeLabelsVisible ? 12 : 0;
                }
            }
        }
    });
    
    // Force a full network refresh
    network.setData({ nodes: nodes, edges: edges });  // Reset data to force update
    network.stabilize(100);
    network.redraw();
    saveStateAfterOperation();
}

  

function toggleEdgeLabels() {
    edgeLabelsVisible = document.getElementById('showEdgeLabels').checked;
    
    // Update each edge individually while preserving original labels
    edges.forEach(edge => {
        // Ensure original label is stored
        if (!edge.hasOwnProperty('originalLabel')) {
            edge.originalLabel = edge.label || '';
        }
        
        edges.update({
            id: edge.id,
            label: edgeLabelsVisible ? edge.originalLabel : '',  // Toggle between original and empty
            font: {
                size: edgeLabelsVisible ? 12 : 0,
                color: isDarkMode ? '#e2e8f0' : '#1f2a44',
                strokeWidth: 0,
                strokeColor: 'transparent',
                align: 'middle',
                multi: true
            }
        });
    });
    
    // Update global network options
    network.setOptions({
        edges: {
            font: {
                size: edgeLabelsVisible ? 12 : 0,
                color: isDarkMode ? '#e2e8f0' : '#1f2a44',
                strokeWidth: 0,
                strokeColor: 'transparent',
                align: 'middle',
                multi: true
            },
            chosen: {
                label: function(values, id, selected, hovering) {
                    values.size = edgeLabelsVisible ? 12 : 0;
                }
            }
        }
    });
    
    // Force a full network refresh
    network.setData({ nodes: nodes, edges: edges });  // Reset data to force update
    network.stabilize(100);
    network.redraw();
    saveStateAfterOperation();
}

function updateLabelVisibility() {
    network.setOptions({
        nodes: {
            font: {
                size: nodeLabelsVisible ? 12 : 0,
                color: isDarkMode ? '#e2e8f0' : '#1f2a44'
            }
        },
        edges: {
            font: {
                size: edgeLabelsVisible ? 12 : 0,
                color: isDarkMode ? '#e2e8f0' : '#1f2a44'
            }
        }
    });
    network.redraw();
}

function toggleIsolatedNodes() {
    const hideIsolated = document.getElementById('hideIsolatedNodes').checked;
    
    nodes.forEach(node => {
        const connections = edges.get({
            filter: edge => edge.from === node.id || edge.to === node.id
        });
        
        nodes.update({
            id: node.id,
            hidden: hideIsolated && connections.length === 0
        });
    });
    
    stabilizeNetwork().then(() => {
        network.fit({
            animation: {
                duration: 300,
                easingFunction: 'easeInOutQuad'
            }
        });
    });
    
    saveStateAfterOperation();
}


async function processShodanData(ipNodeId, data) {
    // Ensure nodes and edges are defined (assuming vis.js DataSets)
    if (!nodes || !edges) {
        console.error('Nodes or edges DataSet not initialized');
        return;
    }

    // Deduplication maps
    let existingPorts = new Map(nodes.get({ filter: n => n.type === 'port' }).map(n => [`${n.portType}/${n.portNumber}`, n.id]));
    let existingDomains = new Map(nodes.get({ filter: n => n.type === 'domain' }).map(n => [n.domain, n.id]));
    let existingSslHashes = new Map(nodes.get({ filter: n => n.type === 'ssl_hash' }).map(n => [n.hash, n.id]));
    let existingHtmlHashes = new Map(nodes.get({ filter: n => n.type === 'html_hash' }).map(n => [n.hash, n.id]));
    let existingOs = new Map(nodes.get({ filter: n => n.type === 'os' }).map(n => [n.os, n.id]));
    let existingProducts = new Map(nodes.get({ filter: n => n.type === 'product' }).map(n => [n.product, n.id]));
    let existingHttpHashes = new Map(nodes.get({ filter: n => n.type === 'http_hash' }).map(n => [n.hash, n.id]));
    let existingTitles = new Map(nodes.get({ filter: n => n.type === 'http_title' }).map(n => [n.title, n.id]));
    let existingFavicons = new Map(nodes.get({ filter: n => n.type === 'favicon' }).map(n => [n.hash, n.id]));
    let existingPortTitles = new Map(nodes.get({ filter: n => n.type === 'port_title' }).map(n => [`${n.portType}/${n.portNumber}/${n.title}`, n.id]));

    const newNodes = [];
    const newEdges = [];

    console.log(`Processing Shodan data for IP: ${ipNodeId}`);

    // Top-level domains and hostnames linked to IP
    if (data.domains && Array.isArray(data.domains)) {
        data.domains.forEach(domain => {
            let domainId = existingDomains.get(domain);
            if (!domainId) {
                domainId = nextId++;
                newNodes.push({
                    id: domainId,
                    type: 'domain',
                    label: `Domain: ${domain}`,
                    title: `Domain: ${domain}`,
                    color: { background: '#60a5fa' },
                    domain: domain
                });
                existingDomains.set(domain, domainId);
            }
            const edgeId = `${ipNodeId}-${domainId}-ResolvesTo`;
            if (!newEdges.some(e => e.id === edgeId) && !edges.get(edgeId)) {
                newEdges.push({ id: edgeId, from: ipNodeId, to: domainId, label: 'Resolves to' });
            }
        });
    }

    if (data.hostnames && Array.isArray(data.hostnames)) {
        data.hostnames.forEach(hostname => {
            let domainId = existingDomains.get(hostname);
            if (!domainId) {
                domainId = nextId++;
                newNodes.push({
                    id: domainId,
                    type: 'domain',
                    label: `Hostname: ${hostname}`,
                    title: `Hostname: ${hostname}`,
                    color: { background: '#60a5fa' },
                    domain: hostname
                });
                existingDomains.set(hostname, domainId);
            }
            const edgeId = `${ipNodeId}-${domainId}-ResolvesTo`;
            if (!newEdges.some(e => e.id === edgeId) && !edges.get(edgeId)) {
                newEdges.push({ id: edgeId, from: ipNodeId, to: domainId, label: 'Resolves to' });
            }
        });
    }

    // Process nested data array for port-specific entities
    if (data.data && Array.isArray(data.data)) {
        for (const banner of data.data) {
            // Port creation
            let portId = null;
            if (banner.port && banner.transport) {
                const portKey = `${banner.transport.toUpperCase()}/${banner.port}`;
                portId = existingPorts.get(portKey);
                if (!portId) {
                    portId = nextId++;
                    newNodes.push({
                        id: portId,
                        type: 'port',
                        label: `${banner.transport.toUpperCase()}/${banner.port}`,
                        title: `Port\nType: ${banner.transport.toUpperCase()}\nNumber: ${banner.port}`,
                        color: { background: '#a78bfa' },
                        portType: banner.transport.toUpperCase(),
                        portNumber: banner.port.toString()
                    });
                    existingPorts.set(portKey, portId);
                    console.log(`Created port node: ${portKey} with ID: ${portId}`);
                }
                const edgeId = `${ipNodeId}-${portId}-Exposes`;
                if (!newEdges.some(e => e.id === edgeId) && !edges.get(edgeId)) {
                    newEdges.push({ id: edgeId, from: ipNodeId, to: portId, label: 'Exposes' });
                    console.log(`Linked port ${portKey} to IP with edge: ${edgeId}`);
                }
            } else {
                console.warn(`No port or transport found in banner:`, banner);
            }

            // Operating System (linked to IP)
            if (banner.os) {
                let osId = existingOs.get(banner.os);
                if (!osId) {
                    osId = nextId++;
                    newNodes.push({
                        id: osId,
                        type: 'os',
                        label: `OS: ${banner.os}`,
                        title: `Operating System: ${banner.os}`,
                        color: { background: '#10b981' },
                        os: banner.os
                    });
                    existingOs.set(banner.os, osId);
                }
                const edgeId = `${ipNodeId}-${osId}-Runs`;
                if (!newEdges.some(e => e.id === edgeId) && !edges.get(edgeId)) {
                    newEdges.push({ id: edgeId, from: ipNodeId, to: osId, label: 'Runs' });
                }
            }

            // Products (linked to IP)
            if (banner.product) {
                let productId = existingProducts.get(banner.product);
                if (!productId) {
                    productId = nextId++;
                    newNodes.push({
                        id: productId,
                        type: 'product',
                        label: `Product: ${banner.product}`,
                        title: `Product: ${banner.product}`,
                        color: { background: '#ec4899' },
                        product: banner.product
                    });
                    existingProducts.set(banner.product, productId);
                }
                const edgeId = `${ipNodeId}-${productId}-Uses`;
                if (!newEdges.some(e => e.id === edgeId) && !edges.get(edgeId)) {
                    newEdges.push({ id: edgeId, from: ipNodeId, to: productId, label: 'Uses' });
                }
            }

            // HTTP Hash (linked to port if available)
            if (banner.http && banner.http.headers_hash && portId) {
                const httpHash = banner.http.headers_hash.toString();
                let httpHashId = existingHttpHashes.get(httpHash);
                if (!httpHashId) {
                    httpHashId = nextId++;
                    newNodes.push({
                        id: httpHashId,
                        type: 'http_hash',
                        label: `HTTP Hash: ${httpHash.substring(0, 8)}...`,
                        title: `HTTP Headers Hash\nValue: ${httpHash}`,
                        color: { background: '#f97316' },
                        hash: httpHash
                    });
                    existingHttpHashes.set(httpHash, httpHashId);
                }
                const edgeId = `${portId}-${httpHashId}-Serves`;
                if (!newEdges.some(e => e.id === edgeId) && !edges.get(edgeId)) {
                    newEdges.push({ id: edgeId, from: portId, to: httpHashId, label: 'Serves' });
                    console.log(`Linked HTTP Hash ${httpHash} to port ${portId} with edge: ${edgeId}`);
                }
            }

            // Favicon (linked to port if available)
            if (banner.http && banner.http.favicon && banner.http.favicon.hash && portId) {
                const faviconHash = banner.http.favicon.hash.toString();
                let faviconId = existingFavicons.get(faviconHash);
                if (!faviconId) {
                    faviconId = nextId++;
                    newNodes.push({
                        id: faviconId,
                        type: 'favicon',
                        label: `Favicon: ${faviconHash.substring(0, 8)}...`,
                        title: `Favicon\nHash: ${faviconHash}\nPath: ${banner.http.favicon.location || 'N/A'}`,
                        color: { background: '#22d3ee' },
                        hash: faviconHash
                    });
                    existingFavicons.set(faviconHash, faviconId);
                }
                const edgeId = `${portId}-${faviconId}-Serves`;
                if (!newEdges.some(e => e.id === edgeId) && !edges.get(edgeId)) {
                    newEdges.push({ id: edgeId, from: portId, to: faviconId, label: 'Serves' });
                    console.log(`Linked Favicon ${faviconHash} to port ${portId} with edge: ${edgeId}`);
                }
            }

            // HTTP Title and Port Title (linked to port if available)
            if (banner.http && banner.http.title && portId) {
                // HTTP Title
                let titleId = existingTitles.get(banner.http.title);
                if (!titleId) {
                    titleId = nextId++;
                    newNodes.push({
                        id: titleId,
                        type: 'http_title',
                        label: `Title: ${banner.http.title}`,
                        title: `HTTP Title: ${banner.http.title}`,
                        color: { background: '#3b82f6' },
                        title: banner.http.title
                    });
                    existingTitles.set(banner.http.title, titleId);
                }
                const titleEdgeId = `${portId}-${titleId}-HasTitle`;
                if (!newEdges.some(e => e.id === titleEdgeId) && !edges.get(titleEdgeId)) {
                    newEdges.push({ id: titleEdgeId, from: portId, to: titleId, label: 'Has Title' });
                    console.log(`Linked HTTP Title "${banner.http.title}" to port ${portId} with edge: ${titleEdgeId}`);
                }

                // Port-Specific Title
                const portTitleKey = `${banner.transport.toUpperCase()}/${banner.port}/${banner.http.title}`;
                let portTitleId = existingPortTitles.get(portTitleKey);
                if (!portTitleId) {
                    portTitleId = nextId++;
                    newNodes.push({
                        id: portTitleId,
                        type: 'port_title',
                        label: `Title ${banner.transport.toUpperCase()}/${banner.port}`,
                        title: `Port Title\nPort: ${banner.transport.toUpperCase()}/${banner.port}\nTitle: ${banner.http.title}`,
                        color: { background: '#4b5e40' },
                        portType: banner.transport.toUpperCase(),
                        portNumber: banner.port.toString(),
                        title: banner.http.title
                    });
                    existingPortTitles.set(portTitleKey, portTitleId);
                }
                const portTitleEdgeId = `${portId}-${portTitleId}-HasPortTitle`;
                if (!newEdges.some(e => e.id === portTitleEdgeId) && !edges.get(portTitleEdgeId)) {
                    newEdges.push({ id: portTitleEdgeId, from: portId, to: portTitleId, label: 'Has Port Title' });
                    console.log(`Linked Port Title "${portTitleKey}" to port ${portId} with edge: ${portTitleEdgeId}`);
                }
            }

            // HTML Hash (linked to port if available)
            if (banner.http && banner.http.html_hash && portId) {
                const htmlHash = banner.http.html_hash.toString();
                let htmlId = existingHtmlHashes.get(htmlHash);
                if (!htmlId) {
                    htmlId = nextId++;
                    newNodes.push({
                        id: htmlId,
                        type: 'html_hash',
                        label: `HTML Hash: ${htmlHash.substring(0, 8)}...`,
                        title: `HTML Hash\nValue: ${htmlHash}`,
                        color: { background: '#f59e0b' },
                        hash: htmlHash
                    });
                    existingHtmlHashes.set(htmlHash, htmlId);
                }
                const edgeId = `${portId}-${htmlId}-Serves`;
                if (!newEdges.some(e => e.id === edgeId) && !edges.get(edgeId)) {
                    newEdges.push({ id: edgeId, from: portId, to: htmlId, label: 'Serves' });
                    console.log(`Linked HTML Hash ${htmlHash} to port ${portId} with edge: ${edgeId}`);
                }
            }

            // SSL Hash (linked to port if available)
            if (banner.ssl && banner.ssl.cert && banner.ssl.cert.fingerprint && banner.ssl.cert.fingerprint.sha256 && portId) {
                const sslHash = banner.ssl.cert.fingerprint.sha256;
                let sslId = existingSslHashes.get(sslHash);
                if (!sslId) {
                    sslId = nextId++;
                    newNodes.push({
                        id: sslId,
                        type: 'ssl_hash',
                        label: `SSL Hash: ${sslHash.substring(0, 8)}...`,
                        title: `SSL Certificate Hash\nSHA256: ${sslHash}`,
                        color: { background: '#8b5cf6' },
                        hash: sslHash
                    });
                    existingSslHashes.set(sslHash, sslId);
                }
                const edgeId = `${portId}-${sslId}-Uses`;
                if (!newEdges.some(e => e.id === edgeId) && !edges.get(edgeId)) {
                    newEdges.push({ id: edgeId, from: portId, to: sslId, label: 'Uses' });
                    console.log(`Linked SSL Hash ${sslHash} to port ${portId} with edge: ${edgeId}`);
                }
            }
        }
    }

    console.log('New Nodes:', newNodes);
    console.log('New Edges:', newEdges);

    if (newNodes.length > 0) {
        try {
            nodes.add(newNodes);
            console.log(`Added ${newNodes.length} nodes`);
        } catch (error) {
            console.error('Error adding nodes:', error);
        }
    }
    if (newEdges.length > 0) {
        try {
            edges.add(newEdges);
            console.log(`Added ${newEdges.length} edges`);
        } catch (error) {
            console.error('Error adding edges:', error);
        }
    }
}





// Password toggle functionality
document.querySelectorAll('.toggle-password').forEach(button => {
    button.addEventListener('click', function() {
        const targetId = this.getAttribute('data-target');
        const input = document.getElementById(targetId);
        if (input.type === 'password') {
            input.type = 'text';
            this.textContent = 'Hide';
        } else {
            input.type = 'password';
            this.textContent = 'Show';
        }
    });
});



const stateLoaded = loadState();
    document.getElementById('stop-task').disabled = true;

    if (!stateLoaded) {
        console.log('No saved state found or loading failed, applying defaults');
        updateTheme();
        ensureInteractionSettings();
    } else {
        // Force UI and network update after successful load
        updateSelectOptions();
        updateEdgeSelectOptions();
        stabilizeNetwork().then(() => {
            network.fit({ 
                animation: { 
                    duration: 500, 
                    easingFunction: 'easeInOutQuad' 
                } 
            });
        });
    }

    // Update UI elements regardless of state
    updateSelectOptions();

    if (window.innerWidth <= 768) {
        document.getElementById('controls').classList.add('collapsed');
    }

    setInterval(saveState, 5 * 60 * 1000);

    // Test Harness for Network Graph Visualization Tool
    async function runAllTests() {
        console.log("Starting All Tests...");
        showToast("All Tests Started", "info");

        // Helper function to wait
        const wait = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        // Step 1: Add a Domain Entity (dns.google.com)
        console.log("Step 1: Adding dns.google.com entity");
        document.getElementById('addEntityType').value = 'domain';
        document.getElementById('addDomainInput').value = 'dns.google.com';
        document.getElementById('addDomainInput').style.display = 'block';
        addNode();
        await wait(1000); // Wait for node addition to complete

        // Verify node was added
        const domainNode = nodes.get({ filter: n => n.type === 'domain' && n.domain === 'dns.google.com' })[0];
        if (!domainNode) {
            console.error("Failed to add dns.google.com node");
            showToast("Failed to add dns.google.com", "error");
            return;
        }
        console.log("dns.google.com added with ID:", domainNode.id);
        showToast("Added dns.google.com", "success");

        // Step 2: Run Enrichment Functions
        console.log("Step 2: Running Enrichment Functions");

        // Google DNS Enrichment (should resolve to IPs like 8.8.8.8)
        console.log("Enriching with Google DNS...");
        await throttledEnrichGoogleDNS('dns.google.com', domainNode.id);
        await wait(2000);

        // Get an IP node to enrich further (e.g., 8.8.8.8)
        const ipNode = nodes.get({ filter: n => n.type === 'ip' && n.ip })[0];
        if (ipNode) {
            console.log("Found IP node to enrich:", ipNode.ip);

            // IPinfo Enrichment
            console.log("Enriching with IPinfo...");
            await throttledEnrichIP(ipNode.ip, ipNode.id);
            await wait(2000);

            // Shodan Enrichment
            console.log("Enriching with Shodan...");
            await throttledEnrichShodan(ipNode.ip, ipNode.id);
            await wait(2000);

            // InternetDB Enrichment
            console.log("Enriching with InternetDB...");
            await throttledEnrichInternetDB(ipNode.ip, ipNode.id);
            await wait(2000);
        } else {
            console.warn("No IP node found after Google DNS enrichment");
            showToast("No IP found to enrich further", "warning");
        }

        // Step 3: Test Bulk Enrichment
        console.log("Step 3: Testing Bulk Enrichment");
        await enrichAllIpinfo();
        await wait(2000);
        await enrichAllShodan();
        await wait(2000);
        await enrichAllInternetDB();
        await wait(2000);
        await enrichAllGoogleDNS();
        await wait(2000);

        // Step 4: Test Layouts
        console.log("Step 4: Testing Layouts");
        setOrganicLayout();
        await wait(1000);
        setCircularLayout();
        await wait(1000);
        setOrthogonalLayout();
        await wait(1000);
        setTreeLayout();
        await wait(1000);
        setHierarchicalLayout();
        await wait(1000);

        // Step 5: Test Import/Export
        console.log("Step 5: Testing Import/Export");
        exportGraph(); // Export current graph
        await wait(1000);
        // Simulate importing IOCs
        document.getElementById('iocText').value = "8.8.4.4\nexample.com";
        importIOCsFromText();
        await wait(1000);

        // Step 6: Test Physics Toggle
        console.log("Step 6: Testing Physics Toggle");
        togglePhysics(); // Pause
        await wait(1000);
        togglePhysics(); // Resume
        await wait(1000);

        // Step 7: Test Mode Toggle
        console.log("Step 7: Testing Mode Toggle");
        toggleMode(); // Switch to light/dark
        await wait(1000);
        toggleMode(); // Switch back
        await wait(1000);

        // Step 8: Test Label Visibility
        console.log("Step 8: Testing Label Visibility");
        document.getElementById('showNodeLabels').checked = false;
        toggleNodeLabels();
        await wait(1000);
        document.getElementById('showNodeLabels').checked = true;
        toggleNodeLabels();
        await wait(1000);

        // Step 9: Clean Up - Delete the Original Node
        console.log("Step 9: Cleaning Up");
        if (domainNode) {
            document.getElementById('removeNode').value = domainNode.id;
            removeNode();
            await wait(1000);
            console.log("dns.google.com removed");
            showToast("Removed dns.google.com", "success");
        }

        console.log("All Tests Completed");
        showToast("All Tests Completed", "success");
        clearGraph();
    }

    function showProgressBar() {
    const progressBar = document.getElementById('progress-bar');
    progressBar.textContent = 'Task in progress...';
    progressBar.classList.remove('progress-hidden', 'progress-complete');
    progressBar.classList.add('progress-active');
}

function completeProgressBar() {
    const progressBar = document.getElementById('progress-bar');
    progressBar.textContent = 'Task Complete';
    progressBar.classList.remove('progress-active');
    progressBar.classList.add('progress-complete');
    
    setTimeout(() => {
        progressBar.classList.add('progress-hidden');
    }, 5000); // Hide after 5 seconds
}

function showGraphSummary() {
    // Get all nodes and count by type
    const typeCounts = {};
    nodes.forEach(node => {
        typeCounts[node.type] = (typeCounts[node.type] || 0) + 1;
    });
    
    // Build the table
    const tbody = document.querySelector('#summary-table tbody');
    tbody.innerHTML = ''; // Clear existing content
    
    const types = Object.keys(typeCounts).sort();
    types.forEach(type => {
        const row = document.createElement('tr');
        row.innerHTML = `
            <td>${type.charAt(0).toUpperCase() + type.slice(1)}</td>
            <td>${typeCounts[type]}</td>
        `;
        tbody.appendChild(row);
    });
    
    // Add total row
    const totalRow = document.createElement('tr');
    totalRow.innerHTML = `
        <td><strong>Total</strong></td>
        <td><strong>${nodes.length}</strong></td>
    `;
    tbody.appendChild(totalRow);
    
    // Show the modal
    document.getElementById('summary-modal').style.display = 'block';
    
    // Optional: Add an overlay to dim the background
    if (!document.getElementById('modal-overlay')) {
        const overlay = document.createElement('div');
        overlay.id = 'modal-overlay';
        overlay.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1999;
        `;
        document.body.appendChild(overlay);
    }
}

function hideGraphSummary() {
    document.getElementById('summary-modal').style.display = 'none';
    const overlay = document.getElementById('modal-overlay');
    if (overlay) overlay.remove();
}

// Close modal when clicking outside
document.addEventListener('click', (event) => {
    const modal = document.getElementById('summary-modal');
    if (modal.style.display === 'block' && !modal.contains(event.target) && event.target.id !== 'summary-button') {
        hideGraphSummary();
    }
});

function toggleMenu() {
    const controls = document.getElementById('controls');
    const menuToggle = document.getElementById('menu-toggle');
    
    controls.classList.toggle('collapsed');
    
    if (controls.classList.contains('collapsed')) {
        menuToggle.textContent = '>'; // Points right when collapsed
        menuToggle.style.transform = 'rotate(0deg)'; // Normal orientation
    } else {
        menuToggle.textContent = '<'; // Points left when expanded
        menuToggle.style.transform = 'rotate(0deg)'; // No rotation needed, just text change
    }
    
    // Adjust network view
    network.fit({
        animation: {
            duration: 300,
            easingFunction: 'easeInOutQuad'
        }
    });
}

const throttledEnrichGoogleDNS = throttleRequest(async function enrichGoogleDNS(domain, domainNodeId, isBulk = false, signal) {
    network.setOptions({ physics: { enabled: false } });
    try {
        const url = constructUrl(`https://dns.google.com/resolve?name=${domain}&type=A`);
        const response = await fetch(url, { signal });
        if (!response.ok) throw new Error('Failed to fetch Google DNS data');
        const data = await response.json();

        if (data.Answer) {
            data.Answer.forEach(answer => {
                if (answer.type === 1) { // Type A record (IPv4)
                    const ip = answer.data;
                    const existingIP = nodes.get({ filter: n => n.type === 'ip' && n.ip === ip })[0];
                    const ipId = existingIP ? existingIP.id : nextId++;
                    if (!existingIP) {
                        nodes.add({
                            id: ipId,
                            type: 'ip',
                            label: `IP: ${ip}`,
                            title: `IP Address: ${ip}`,
                            color: { background: '#f87171' },
                            ip: ip,
                            size: 20
                        });
                    }
                    const edgeId = `${domainNodeId}-${ipId}-ResolvesTo`;
                    if (!edges.get(edgeId)) {
                        edges.add({
                            id: edgeId,
                            from: domainNodeId,
                            to: ipId,
                            label: 'Resolves to'
                        });
                    }
                }
            });
        }

        updateNodeSizes();
        updateSelectOptions();
        await stabilizeNetwork();
        if (!isBulk) showToast(`Domain ${domain} enrichment completed using Google DNS`, 'success');
    } catch (error) {
        if (error.name === 'AbortError') {
            showToast(`Enrichment of domain ${domain} was cancelled`, 'info');
            return;
        }
        console.error(`Error enriching domain ${domain} with Google DNS: ${error.message}`);
        showToast(`Error enriching domain ${domain}: ${error.message}`, 'error');
        await stabilizeNetwork();
    }
}, RATE_LIMIT_MS); // Use the default rate limit (500ms)


const throttledEnrichGoogleDNSMultiple = throttleRequest(async function enrichGoogleDNSMultiple(domains, nodeIds) {
    if (!Array.isArray(domains) || !Array.isArray(nodeIds) || domains.length !== nodeIds.length) {
        showToast('Invalid input for multiple domain enrichment', 'error');
        return;
    }

    for (let i = 0; i < domains.length; i++) {
        if (activeTaskController && activeTaskController.signal.aborted) {
            showToast('Google DNS enrichment stopped', 'info');
            break;
        }
        await throttledEnrichGoogleDNS(domains[i], nodeIds[i], true); // isBulk = true
    }

    updateNodeSizes();
    updateSelectOptions();
    await stabilizeNetwork();
    showToast(`Enriched ${domains.length} domains with Google DNS`, 'success');
}, RATE_LIMIT_MS);

const throttledEnrichIPMultiple = throttleRequest(async function enrichIPMultiple(ips, nodeIds) {
    if (!Array.isArray(ips) || !Array.isArray(nodeIds) || ips.length !== nodeIds.length) {
        showToast('Invalid input for multiple IP enrichment', 'error');
        return;
    }

    if (!ipinfoApiKey && !ignoreApiKeysViaProxy) {
        showToast('Please set your IPinfo API key in the "API Keys" tab first.', 'error');
        return;
    }

    for (let i = 0; i < ips.length; i++) {
        if (activeTaskController && activeTaskController.signal.aborted) {
            showToast('IPinfo enrichment stopped', 'info');
            break;
        }
        await throttledEnrichIP(ips[i], nodeIds[i], true); // isBulk = true
    }

    updateNodeSizes();
    updateSelectOptions();
    await stabilizeNetwork();
    showToast(`Enriched ${ips.length} IPs with IPinfo`, 'success');
}, RATE_LIMIT_MS);

const throttledEnrichShodanMultiple = throttleRequest(async function enrichShodanMultiple(targets, nodeIds) {
    if (!Array.isArray(targets) || !Array.isArray(nodeIds) || targets.length !== nodeIds.length) {
        showToast('Invalid input for multiple Shodan enrichment', 'error');
        return;
    }

    if (!shodanApiKey && !ignoreApiKeysViaProxy) {
        showToast('Please set your Shodan API key in the "API Keys" tab first.', 'error');
        return;
    }

    showProgressBar();
    network.setOptions({ physics: { enabled: false } });
    const totalTargets = targets.length;
    let processedTargets = 0;

    showToast(`Starting Shodan enrichment for ${totalTargets} targets`, 'info');

    const batchSize = 5;
    const delayBetweenBatches = 100;
    const totalBatches = Math.ceil(totalTargets / batchSize);
    const timePerBatchMs = SHODAN_RATE_LIMIT_MS * batchSize;
    const totalBatchDelays = (totalBatches - 1) * delayBetweenBatches;
    const estimatedTimeMs = (timePerBatchMs * totalBatches) + totalBatchDelays + 1000;

    const estimatedSeconds = Math.ceil(estimatedTimeMs / 1000);
    const estimatedMinutes = Math.floor(estimatedSeconds / 60);
    const remainingSeconds = estimatedSeconds % 60;
    const timeEstimateStr = estimatedMinutes > 0 
        ? `${estimatedMinutes}m ${remainingSeconds}s` 
        : `${estimatedSeconds}s`;

    showToast(`Estimated time for Shodan enrichment: ~${timeEstimateStr}`, 'info');
    document.getElementById('progress-bar').textContent = `Shodan Enrichment: 0/${totalTargets} Targets (0%) - Est. ${timeEstimateStr}`;

    let lastProgressUpdate = 0;
    const progressUpdateInterval = 500;
    const startTime = Date.now();

    for (let i = 0; i < totalTargets; i += batchSize) {
        if (activeTaskController && activeTaskController.signal.aborted) {
            showToast('Shodan enrichment stopped', 'info');
            document.getElementById('progress-bar').textContent = `Shodan Enrichment: Stopped at ${processedTargets}/${totalTargets} Targets`;
            break;
        }

        const batchTargets = targets.slice(i, Math.min(i + batchSize, totalTargets));
        const batchNodeIds = nodeIds.slice(i, Math.min(i + batchSize, totalTargets));

        for (let j = 0; j < batchTargets.length; j++) {
            await throttledEnrichShodan(batchTargets[j], batchNodeIds[j], true); // isBulk = true
            processedTargets++;
        }

        const currentTime = Date.now();
        if (currentTime - lastProgressUpdate >= progressUpdateInterval || processedTargets === totalTargets) {
            const progress = ((processedTargets / totalTargets) * 100).toFixed(1);
            const remainingTargets = totalTargets - processedTargets;
            const remainingTimeMs = remainingTargets * SHODAN_RATE_LIMIT_MS;
            const remainingSeconds = Math.ceil(remainingTimeMs / 1000);
            const remainingMinutes = Math.floor(remainingSeconds / 60);
            const remainingSecondsPart = remainingSeconds % 60;
            const remainingTimeStr = remainingMinutes > 0 
                ? `${remainingMinutes}m ${remainingSecondsPart}s` 
                : `${remainingSeconds}s`;

            document.getElementById('progress-bar').textContent = 
                `Shodan Enrichment: ${processedTargets}/${totalTargets} Targets (${progress}%) - Est. ${remainingTimeStr} remaining`;
            lastProgressUpdate = currentTime;
            updateSelectOptions();
        }

        await new Promise(resolve => setTimeout(resolve, delayBetweenBatches));
    }

    updateNodeSizes();
    updateSelectOptions();
    await stabilizeNetwork();
    ensureInteractionSettings();

    if (!(activeTaskController && activeTaskController.signal.aborted)) {
        completeProgressBar();
        showToast(`Shodan enrichment completed: ${processedTargets}/${totalTargets} targets enriched`, 'success');
    } else {
        showToast(`Shodan enrichment stopped: ${processedTargets}/${totalTargets} targets processed`, 'info');
    }

    if (window.innerWidth <= 768) {
        const controls = document.getElementById('controls');
        controls.classList.add('collapsed');
        document.getElementById('myNetwork').style.display = 'block';
        network.fit({ animation: { duration: 300, easingFunction: 'easeInOutQuad' } });
    }
}, SHODAN_RATE_LIMIT_MS);










const throttledEnrichInternetDBMultiple = throttleRequest(async function enrichInternetDBMultiple(ips, nodeIds) {
    if (!Array.isArray(ips) || !Array.isArray(nodeIds) || ips.length !== nodeIds.length) {
        showToast('Invalid input for multiple InternetDB enrichment', 'error');
        return;
    }

    showProgressBar();
    network.setOptions({ physics: { enabled: false } });
    const totalIPs = ips.length;
    let successfulEnrichments = 0;

    showToast(`Starting InternetDB enrichment for ${totalIPs} IPs`, 'info');

    const batchSize = 50; // Consistent with other bulk functions
    const delayBetweenBatches = 200; // Consistent with other bulk functions
    const totalBatches = Math.ceil(totalIPs / batchSize);
    const assumedRequestTimeMs = 100; // Estimated time per request
    const timePerBatchMs = assumedRequestTimeMs * batchSize;
    const totalBatchDelays = (totalBatches - 1) * delayBetweenBatches;
    const estimatedTimeMs = (timePerBatchMs * totalBatches) + totalBatchDelays + 1000;

    const estimatedSeconds = Math.ceil(estimatedTimeMs / 1000);
    const estimatedMinutes = Math.floor(estimatedSeconds / 60);
    const remainingSeconds = estimatedSeconds % 60;
    const timeEstimateStr = estimatedMinutes > 0 
        ? `${estimatedMinutes}m ${remainingSeconds}s` 
        : `${estimatedSeconds}s`;

    showToast(`Estimated time for InternetDB enrichment: ~${timeEstimateStr}`, 'info');
    document.getElementById('progress-bar').textContent = `InternetDB Enrichment: 0/${totalIPs} IPs (0%) - Est. ${timeEstimateStr}`;

    let lastProgressUpdate = 0;
    const progressUpdateInterval = 1000;
    const startTime = Date.now();

    for (let i = 0; i < totalIPs; i += batchSize) {
        if (activeTaskController && activeTaskController.signal.aborted) {
            showToast('InternetDB enrichment stopped', 'info');
            document.getElementById('progress-bar').textContent = `InternetDB Enrichment: Stopped at ${successfulEnrichments}/${totalIPs} IPs`;
            break;
        }

        const batchIPs = ips.slice(i, Math.min(i + batchSize, totalIPs));
        const batchNodeIds = nodeIds.slice(i, Math.min(i + batchSize, totalIPs));

        const promises = batchIPs.map((ip, index) => {
            return throttledEnrichInternetDB(ip, batchNodeIds[index], true) // isBulk = true
                .then(() => successfulEnrichments++)
                .catch(error => {
                    console.error(`Failed to enrich IP ${ip}: ${error.message}`);
                    showToast(`Failed to enrich IP ${ip}: ${error.message}`, 'error');
                });
        });

        await Promise.all(promises);

        const currentTime = Date.now();
        if (currentTime - lastProgressUpdate >= progressUpdateInterval || i + batchSize >= totalIPs) {
            const processedIPs = Math.min(i + batchSize, totalIPs);
            const progress = ((processedIPs / totalIPs) * 100).toFixed(1);
            const remainingIPs = totalIPs - processedIPs;
            const remainingTimeMs = Math.max(0, remainingIPs * assumedRequestTimeMs);
            const remainingSeconds = Math.ceil(remainingTimeMs / 1000);
            const remainingMinutes = Math.floor(remainingSeconds / 60);
            const remainingSecondsPart = remainingSeconds % 60;
            const remainingTimeStr = remainingMinutes > 0 
                ? `${remainingMinutes}m ${remainingSecondsPart}s` 
                : `${remainingSeconds}s`;

            document.getElementById('progress-bar').textContent = 
                `InternetDB Enrichment: ${successfulEnrichments}/${totalIPs} IPs (${progress}%) - Est. ${remainingTimeStr} remaining`;
            lastProgressUpdate = currentTime;
            updateSelectOptions();
        }

        await new Promise(resolve => setTimeout(resolve, delayBetweenBatches));
    }

    updateNodeSizes();
    updateSelectOptions();
    await stabilizeNetwork();
    ensureInteractionSettings();

    if (!(activeTaskController && activeTaskController.signal.aborted)) {
        completeProgressBar();
        showToast(`InternetDB enrichment completed: ${successfulEnrichments}/${totalIPs} IPs enriched`, 'success');
    } else {
        showToast(`InternetDB enrichment stopped: ${successfulEnrichments}/${totalIPs} IPs processed`, 'info');
    }

    if (window.innerWidth <= 768) {
        const controls = document.getElementById('controls');
        controls.classList.add('collapsed');
        document.getElementById('myNetwork').style.display = 'block';
        network.fit({ animation: { duration: 300, easingFunction: 'easeInOutQuad' } });
    }
}, RATE_LIMIT_MS); // Use default rate limit of 500ms

// Add these functions within your <script> tag, ideally near other layout-related functions like setOrganicLayout()

    function setNodeSizeLayout(mode) {
    // Disable physics to prevent interference during resizing
    network.setOptions({ physics: { enabled: false } });
    
    // Get all nodes
    const allNodes = nodes.get();
    
    // Calculate sizes based on mode
    allNodes.forEach(node => {
        let connectionCount = 0;
        
        switch (mode) {
            case 'incoming':
                // Count edges where this node is the target (to)
                connectionCount = edges.get({
                    filter: edge => edge.to === node.id
                }).length;
                break;
                
            case 'outgoing':
                // Count edges where this node is the source (from)
                connectionCount = edges.get({
                    filter: edge => edge.from === node.id
                }).length;
                break;
                
            case 'both':
                // Count all edges connected to this node
                connectionCount = edges.get({
                    filter: edge => edge.from === node.id || edge.to === node.id
                }).length;
                break;
                
            default:
                console.warn('Invalid mode for setNodeSizeLayout:', mode);
                return;
        }
        
        // Calculate new size: minimum 10, increases by 10 per connection, max 120
        const newSize = Math.min(10 + connectionCount * 10, 120);
        
        // Update node with new size
        nodes.update({
            id: node.id,
            size: newSize,
            widthConstraint: false,  // Remove any width constraints
            heightConstraint: false  // Remove any height constraints
        });
    });
    
    // Stabilize and fit the network after resizing
    stabilizeNetwork().then(() => {
        network.fit({
            animation: {
                duration: 300,
                easingFunction: 'easeInOutQuad'
            }
        });
        
        // Save the updated state
        saveStateAfterOperation();
        
        // Show confirmation
        const modeText = {
            'incoming': 'Incoming Links',
            'outgoing': 'Outgoing Links',
            'both': 'All Links'
        }[mode];
        showToast(`Node sizes updated based on ${modeText}`, 'success');
    });
}

const throttledSendHttpsRequestMultiple = throttleRequest(async function sendHttpsRequestMultiple(targets, type, protocol) {
    if (!Array.isArray(targets)) {
        showToast('Invalid input for multiple HTTPS requests', 'error');
        return;
    }

    showProgressBar();
    network.setOptions({ physics: { enabled: false } });
    const totalTargets = targets.length;
    let successfulRequests = 0;

    showToast(`Starting ${protocol.toUpperCase()} requests for ${totalTargets} ${type}s`, 'info');
    document.getElementById('progress-bar').textContent = `${protocol.toUpperCase()} Requests: 0/${totalTargets} ${type}s (0%)`;

    for (let i = 0; i < totalTargets; i++) {
        if (activeTaskController && activeTaskController.signal.aborted) {
            showToast(`${protocol.toUpperCase()} requests stopped`, 'info');
            document.getElementById('progress-bar').textContent = `${protocol.toUpperCase()} Requests: Stopped at ${successfulRequests}/${totalTargets} ${type}s`;
            break;
        }

        const target = targets[i];
        const url = constructUrl(`${protocol}://${target}`);
        
        try {
            const response = await fetch(url, {
                method: 'GET',
                headers: {
                    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                    'Origin': window.location.origin
                },
                mode: 'cors',
                credentials: 'omit',
                signal: activeTaskController?.signal
            });

            const status = response.status;
            const statusText = response.statusText;
            successfulRequests++;

            const progress = ((successfulRequests / totalTargets) * 100).toFixed(1);
            document.getElementById('progress-bar').textContent = 
                `${protocol.toUpperCase()} Requests: ${successfulRequests}/${totalTargets} ${type}s (${progress}%)`;

            showToast(`${protocol.toUpperCase()} request to ${target}: ${status} ${statusText}`, 'success');
        } catch (error) {
            if (error.name === 'AbortError') {
                break;
            }
            showToast(`${protocol.toUpperCase()} request to ${target} failed: ${error.message}`, 'error');
        }

        // Small delay between requests to avoid overwhelming the proxy/server
        await new Promise(resolve => setTimeout(resolve, 200));
    }

    await stabilizeNetwork();
    ensureInteractionSettings();

    if (!(activeTaskController && activeTaskController.signal.aborted)) {
        completeProgressBar();
        showToast(`${protocol.toUpperCase()} requests completed: ${successfulRequests}/${totalTargets} successful`, 'success');
    }

    if (window.innerWidth <= 768) {
        const controls = document.getElementById('controls');
        controls.classList.add('collapsed');
        document.getElementById('myNetwork').style.display = 'block';
        network.fit({ animation: { duration: 300, easingFunction: 'easeInOutQuad' } });
    }
}, RATE_LIMIT_MS);


function stopActiveTask() {
    if (activeTaskController) {
        activeTaskController.abort();
        showToast('Active task stopped', 'info');
        document.getElementById('stop-task').disabled = true;
        activeTaskController = null;
        completeProgressBar();
    } else {
        showToast('No active task to stop', 'warning');
    }
}
function startLinkCreation(nodeId) {
    linkFromNode = nodeId;
    nodes.update({ id: nodeId, color: { border: '#ff0000' } }); // Highlight source node
    showToast('Right-click another node to create a link, or click anywhere to cancel', 'info');
    network.once('oncontext', handleLinkDestination);
    network.once('click', cancelLinkCreation);
}

function handleLinkDestination(params) {
    const toNodeId = network.getNodeAt(params.pointer.DOM);
    if (toNodeId && toNodeId !== linkFromNode) {
        const label = prompt('Enter link label (optional):', '');
        edges.add({
            id: `edge_${linkFromNode}_${toNodeId}_${Date.now()}`,
            from: linkFromNode,
            to: toNodeId,
            label: label || ''
        });
        updateNodeSizes();
        stabilizeNetwork();
        showToast('Link created', 'success');
    }
    cancelLinkCreation();
}

const throttledEnrichHudsonRock = throttleRequest(async function enrichHudsonRock(email, emailNodeId, isBulk = false, signal) {
    network.setOptions({ physics: { enabled: false } });
    try {
        const url = constructUrl(`https://cavalier.hudsonrock.com/api/json/v2/osint-tools/search-by-email?email=${encodeURIComponent(email)}`);
        const response = await fetch(url, { signal });
        if (!response.ok) throw new Error(`Failed to fetch Hudson Rock data: ${response.statusText}`);
        const data = await response.json();

        // Deduplication maps
        const existingComputers = new Map(nodes.get({ filter: n => n.type === 'device' }).map(n => [n.deviceName, n.id]));
        const existingIPs = new Map(nodes.get({ filter: n => n.type === 'ip' }).map(n => [n.ip, n.id]));
        const existingMalwares = new Map(nodes.get({ filter: n => n.type === 'malware' }).map(n => [n.malwareName, n.id]));
        const existingOS = new Map(nodes.get({ filter: n => n.type === 'os' }).map(n => [n.os, n.id]));
        const existingAVs = new Map(nodes.get({ filter: n => n.type === 'technology' }).map(n => [n.techName, n.id]));

        const newNodes = [];
        const newEdges = [];

        // Process each stealer entry
        if (data.stealers && Array.isArray(data.stealers)) {
            data.stealers.forEach(stealer => {
                // Computer (Device)
                const computerName = stealer.computer_name || 'Unknown Computer';
                let computerId = existingComputers.get(computerName);
                if (!computerId) {
                    computerId = nextId++;
                    newNodes.push({
                        id: computerId,
                        type: 'device',
                        label: `Device: ${computerName}`,
                        title: `Device\nName: ${computerName}\nCategory: Infected Device`,
                        color: { background: '#14b8a6' },
                        deviceCategory: 'Infected Device',
                        deviceName: computerName
                    });
                    existingComputers.set(computerName, computerId);
                }
                const emailToComputerEdge = `${emailNodeId}-${computerId}-CompromisedOn`;
                if (!edges.get(emailToComputerEdge) && !newEdges.some(e => e.id === emailToComputerEdge)) {
                    newEdges.push({ id: emailToComputerEdge, from: emailNodeId, to: computerId, label: 'Compromised on' });
                }

                // IP Address
                const ip = stealer.ip || 'Unknown IP';
                if (ipRegex.ipv4.test(ip) || ipRegex.ipv6.test(ip)) {
                    let ipId = existingIPs.get(ip);
                    if (!ipId) {
                        ipId = nextId++;
                        newNodes.push({
                            id: ipId,
                            type: 'ip',
                            label: `IP: ${ip}`,
                            title: `IP Address: ${ip}`,
                            color: { background: '#f87171' },
                            ip: ip
                        });
                        existingIPs.set(ip, ipId);
                    }
                    const computerToIpEdge = `${computerId}-${ipId}-AssignedTo`;
                    if (!edges.get(computerToIpEdge) && !newEdges.some(e => e.id === computerToIpEdge)) {
                        newEdges.push({ id: computerToIpEdge, from: computerId, to: ipId, label: 'Assigned to' });
                    }
                }

                // Malware (assuming "jsc.exe" is indicative; we’ll use malware_path as a name)
                const malwareName = stealer.malware_path ? stealer.malware_path.split('\\').pop() : 'Unknown Malware';
                let malwareId = existingMalwares.get(malwareName);
                if (!malwareId) {
                    malwareId = nextId++;
                    newNodes.push({
                        id: malwareId,
                        type: 'malware',
                        label: `Malware: ${malwareName}`,
                        title: `Malware\nName: ${malwareName}\nType: Info-Stealer\nDate: ${stealer.date_compromised || 'N/A'}`,
                        color: { background: '#ef4444' },
                        malwareName: malwareName,
                        malwareType: 'Info-Stealer'
                    });
                    existingMalwares.set(malwareName, malwareId);
                }
                const computerToMalwareEdge = `${computerId}-${malwareId}-InfectedBy`;
                if (!edges.get(computerToMalwareEdge) && !newEdges.some(e => e.id === computerToMalwareEdge)) {
                    newEdges.push({ id: computerToMalwareEdge, from: computerId, to: malwareId, label: 'Infected by' });
                }

                // Operating System
                const os = stealer.operating_system || 'Unknown OS';
                let osId = existingOS.get(os);
                if (!osId) {
                    osId = nextId++;
                    newNodes.push({
                        id: osId,
                        type: 'os',
                        label: `OS: ${os}`,
                        title: `Operating System: ${os}`,
                        color: { background: '#10b981' },
                        os: os
                    });
                    existingOS.set(os, osId);
                }
                const computerToOsEdge = `${computerId}-${osId}-Runs`;
                if (!edges.get(computerToOsEdge) && !newEdges.some(e => e.id === computerToOsEdge)) {
                    newEdges.push({ id: computerToOsEdge, from: computerId, to: osId, label: 'Runs' });
                }

                // Antiviruses
                if (stealer.antiviruses && Array.isArray(stealer.antiviruses)) {
                    stealer.antiviruses.forEach(av => {
                        let avId = existingAVs.get(av);
                        if (!avId) {
                            avId = nextId++;
                            newNodes.push({
                                id: avId,
                                type: 'technology',
                                label: `AV: ${av}`,
                                title: `Technology\nName: ${av}\nVersion: N/A`,
                                color: { background: '#ec4899' },
                                techName: av,
                                techVersion: 'N/A'
                            });
                            existingAVs.set(av, avId);
                        }
                        const computerToAvEdge = `${computerId}-${avId}-ProtectedBy`;
                        if (!edges.get(computerToAvEdge) && !newEdges.some(e => e.id === computerToAvEdge)) {
                            newEdges.push({ id: computerToAvEdge, from: computerId, to: avId, label: 'Protected by' });
                        }
                    });
                }
            });
        }

        // Batch update
        if (newNodes.length > 0) nodes.add(newNodes);
        if (newEdges.length > 0) edges.add(newEdges);

        updateNodeSizes();
        updateSelectOptions();
        await stabilizeNetwork();
        if (!isBulk) showToast(`Email ${email} enrichment completed using Hudson Rock`, 'success');
    } catch (error) {
        if (error.name === 'AbortError') {
            showToast(`Enrichment of email ${email} was cancelled`, 'info');
            return;
        }
        console.error(`Error enriching email ${email} with Hudson Rock: ${error.message}`);
        showToast(`Error enriching email ${email}: ${error.message}`, 'error');
        await stabilizeNetwork();
    }
}, RATE_LIMIT_MS); // Using the default 500ms rate limit


const throttledEnrichHudsonRockMultiple = throttleRequest(async function enrichHudsonRockMultiple(emails, nodeIds) {
    if (!Array.isArray(emails) || !Array.isArray(nodeIds) || emails.length !== nodeIds.length) {
        showToast('Invalid input for multiple Hudson Rock enrichment', 'error');
        return;
    }

    showProgressBar();
    network.setOptions({ physics: { enabled: false } });
    const totalEmails = emails.length;
    let successfulEnrichments = 0;

    showToast(`Starting Hudson Rock enrichment for ${totalEmails} emails`, 'info');
    document.getElementById('progress-bar').textContent = `Hudson Rock Enrichment: 0/${totalEmails} Emails (0%)`;

    for (let i = 0; i < totalEmails; i++) {
        if (activeTaskController && activeTaskController.signal.aborted) {
            showToast('Hudson Rock enrichment stopped', 'info');
            document.getElementById('progress-bar').textContent = `Hudson Rock Enrichment: Stopped at ${successfulEnrichments}/${totalEmails} Emails`;
            break;
        }

        await throttledEnrichHudsonRock(emails[i], nodeIds[i], true); // isBulk = true
        successfulEnrichments++;

        const progress = ((successfulEnrichments / totalEmails) * 100).toFixed(1);
        document.getElementById('progress-bar').textContent = 
            `Hudson Rock Enrichment: ${successfulEnrichments}/${totalEmails} Emails (${progress}%)`;
        
        // Small delay to respect API limits
        await new Promise(resolve => setTimeout(resolve, 200));
    }

    updateNodeSizes();
    updateSelectOptions();
    await stabilizeNetwork();
    ensureInteractionSettings();

    if (!(activeTaskController && activeTaskController.signal.aborted)) {
        completeProgressBar();
        showToast(`Hudson Rock enrichment completed: ${successfulEnrichments}/${totalEmails} emails enriched`, 'success');
    }
}, RATE_LIMIT_MS);


const throttledEnrichHudsonRockDomain = throttleRequest(async function enrichHudsonRockDomain(domain, domainNodeId, isBulk = false, signal) {
    network.setOptions({ physics: { enabled: false } });
    try {
        const url = constructUrl(`https://cavalier.hudsonrock.com/api/json/v2/osint-tools/search-by-domain?domain=${encodeURIComponent(domain)}`);
        const response = await fetch(url, { signal });
        if (!response.ok) throw new Error(`Failed to fetch Hudson Rock domain data: ${response.statusText}`);
        const data = await response.json();

        // Deduplication maps
        const existingOrganizations = new Map(nodes.get({ filter: n => n.type === 'organization' }).map(n => [n.organization, n.id]));
        const existingDomains = new Map(nodes.get({ filter: n => n.type === 'domain' }).map(n => [n.domain, n.id]));
        const existingMalwares = new Map(nodes.get({ filter: n => n.type === 'malware' }).map(n => [n.malwareName, n.id]));
        const existingTechnologies = new Map(nodes.get({ filter: n => n.type === 'technology' }).map(n => [n.techName, n.id]));

        const newNodes = [];
        const newEdges = [];

        // Process organization (company name)
        if (data.data && data.data.company_name) {
            const companyName = data.data.company_name;
            let orgId = existingOrganizations.get(companyName);
            if (!orgId) {
                orgId = nextId++;
                newNodes.push({
                    id: orgId,
                    type: 'organization',
                    label: `Organization: ${companyName}`,
                    title: `Organization: ${companyName}`,
                    color: { background: '#facc15' },
                    organization: companyName
                });
                existingOrganizations.set(companyName, orgId);
            }
            const orgEdgeId = `${domainNodeId}-${orgId}-BelongsTo`;
            if (!edges.get(orgEdgeId) && !newEdges.some(e => e.id === orgEdgeId)) {
                newEdges.push({ id: orgEdgeId, from: domainNodeId, to: orgId, label: 'Belongs to' });
            }
        }

        // Process third-party domains
        if (data.thirdPartyDomains && Array.isArray(data.thirdPartyDomains)) {
            data.thirdPartyDomains.forEach(thirdParty => {
                if (thirdParty.domain && thirdParty.domain !== null) {
                    let thirdPartyId = existingDomains.get(thirdParty.domain);
                    if (!thirdPartyId) {
                        thirdPartyId = nextId++;
                        newNodes.push({
                            id: thirdPartyId,
                            type: 'domain',
                            label: `Domain: ${thirdParty.domain}`,
                            title: `Third-Party Domain: ${thirdParty.domain}\nOccurrences: ${thirdParty.occurrence}`,
                            color: { background: '#60a5fa' },
                            domain: thirdParty.domain
                        });
                        existingDomains.set(thirdParty.domain, thirdPartyId);
                    }
                    const thirdPartyEdgeId = `${domainNodeId}-${thirdPartyId}-AssociatedWith`;
                    if (!edges.get(thirdPartyEdgeId) && !newEdges.some(e => e.id === thirdPartyEdgeId)) {
                        newEdges.push({
                            id: thirdPartyEdgeId,
                            from: domainNodeId,
                            to: thirdPartyId,
                            label: `Associated with (${thirdParty.occurrence})`
                        });
                    }
                }
            });
        }

        // Process stealer families as malware
        if (data.stealerFamilies && typeof data.stealerFamilies === 'object') {
            for (const [malwareName, count] of Object.entries(data.stealerFamilies)) {
                if (malwareName !== 'total' && count > 0) {
                    let malwareId = existingMalwares.get(malwareName);
                    if (!malwareId) {
                        malwareId = nextId++;
                        newNodes.push({
                            id: malwareId,
                            type: 'malware',
                            label: `Malware: ${malwareName}`,
                            title: `Malware\nName: ${malwareName}\nType: Info-Stealer\nOccurrences: ${count}`,
                            color: { background: '#ef4444' },
                            malwareName: malwareName,
                            malwareType: 'Info-Stealer'
                        });
                        existingMalwares.set(malwareName, malwareId);
                    }
                    const malwareEdgeId = `${domainNodeId}-${malwareId}-InfectedBy`;
                    if (!edges.get(malwareEdgeId) && !newEdges.some(e => e.id === malwareEdgeId)) {
                        newEdges.push({
                            id: malwareEdgeId,
                            from: domainNodeId,
                            to: malwareId,
                            label: `Infected by (${count})`
                        });
                    }
                }
            }
        }

        // Process antiviruses as technologies
        if (data.antiviruses && data.antiviruses.list && Array.isArray(data.antiviruses.list)) {
            data.antiviruses.list.forEach(av => {
                if (av.name && av.count > 0) {
                    let avId = existingTechnologies.get(av.name);
                    if (!avId) {
                        avId = nextId++;
                        newNodes.push({
                            id: avId,
                            type: 'technology',
                            label: `AV: ${av.name}`,
                            title: `Technology\nName: ${av.name}\nVersion: N/A\nOccurrences: ${av.count}`,
                            color: { background: '#ec4899' },
                            techName: av.name,
                            techVersion: 'N/A'
                        });
                        existingTechnologies.set(av.name, avId);
                    }
                    const avEdgeId = `${domainNodeId}-${avId}-ProtectedBy`;
                    if (!edges.get(avEdgeId) && !newEdges.some(e => e.id === avEdgeId)) {
                        newEdges.push({
                            id: avEdgeId,
                            from: domainNodeId,
                            to: avId,
                            label: `Protected by (${av.count})`
                        });
                    }
                }
            });
        }

        // Batch update
        if (newNodes.length > 0) nodes.add(newNodes);
        if (newEdges.length > 0) edges.add(newEdges);

        updateNodeSizes();
        updateSelectOptions();
        await stabilizeNetwork();
        if (!isBulk) showToast(`Domain ${domain} enrichment completed using Hudson Rock`, 'success');
    } catch (error) {
        if (error.name === 'AbortError') {
            showToast(`Enrichment of domain ${domain} was cancelled`, 'info');
            return;
        }
        console.error(`Error enriching domain ${domain} with Hudson Rock: ${error.message}`);
        showToast(`Error enriching domain ${domain}: ${error.message}`, 'error');
        await stabilizeNetwork();
    }
}, RATE_LIMIT_MS);

const throttledEnrichHudsonRockDomainMultiple = throttleRequest(async function enrichHudsonRockDomainMultiple(domains, nodeIds) {
    if (!Array.isArray(domains) || !Array.isArray(nodeIds) || domains.length !== nodeIds.length) {
        showToast('Invalid input for multiple Hudson Rock domain enrichment', 'error');
        return;
    }

    showProgressBar();
    network.setOptions({ physics: { enabled: false } });
    const totalDomains = domains.length;
    let successfulEnrichments = 0;

    showToast(`Starting Hudson Rock enrichment for ${totalDomains} domains`, 'info');
    document.getElementById('progress-bar').textContent = `Hudson Rock Domain Enrichment: 0/${totalDomains} Domains (0%)`;

    for (let i = 0; i < totalDomains; i++) {
        if (activeTaskController && activeTaskController.signal.aborted) {
            showToast('Hudson Rock domain enrichment stopped', 'info');
            document.getElementById('progress-bar').textContent = `Hudson Rock Domain Enrichment: Stopped at ${successfulEnrichments}/${totalDomains} Domains`;
            break;
        }

        await throttledEnrichHudsonRockDomain(domains[i], nodeIds[i], true); // isBulk = true
        successfulEnrichments++;

        const progress = ((successfulEnrichments / totalDomains) * 100).toFixed(1);
        document.getElementById('progress-bar').textContent = 
            `Hudson Rock Domain Enrichment: ${successfulEnrichments}/${totalDomains} Domains (${progress}%)`;
        
        // Small delay to respect API limits
        await new Promise(resolve => setTimeout(resolve, 200));
    }

    updateNodeSizes();
    updateSelectOptions();xf
    await stabilizeNetwork();
    ensureInteractionSettings();

    if (!(activeTaskController && activeTaskController.signal.aborted)) {
        completeProgressBar();
        showToast(`Hudson Rock domain enrichment completed: ${successfulEnrichments}/${totalDomains} domains enriched`, 'success');
    }
}, RATE_LIMIT_MS);



function showPropertiesPanel(nodeId) {
    console.log('Attempting to show properties for node ID:', nodeId);
    const node = nodes.get(nodeId);
    
    if (!node) {
        console.error('Node not found for ID:', nodeId);
        showToast('Node not found', 'error');
        return;
    }

    console.log('Node data:', JSON.stringify(node, null, 2));

    const tbody = document.querySelector('#properties-table tbody');
    if (!tbody) {
        console.error('Properties table body not found');
        showToast('Properties table not found', 'error');
        return;
    }
    
    tbody.innerHTML = '';

    const properties = {};
    for (let key in node) {
        if (node.hasOwnProperty(key) && 
            !['id', 'x', 'y', 'fixed', 'physics', 'hidden', 'group', 'options', 
              'scaling', 'shadow', 'shapeProperties', 'chosen', 'mass'].includes(key)) {
            properties[key] = node[key];
        }
    }

    Object.entries(properties).forEach(([key, value]) => {
        if (typeof value === 'object' && value !== null && key !== 'color') {
            value = JSON.stringify(value, null, 2);
        } else if (value === null || value === undefined) {
            value = 'N/A';
        }
        const row = document.createElement('tr');
        row.innerHTML = `<td>${key}</td><td>${value}</td>`;
        tbody.appendChild(row);
    });

    const panel = document.getElementById('properties-panel');
    if (!panel) {
        console.error('Properties panel element not found');
        showToast('Properties panel not found', 'error');
        return;
    }

    // Ensure panel is visible and trigger transition
    panel.style.display = 'block'; // Ensure it’s not hidden
    panel.classList.add('active');

    // Force reflow for transition
    void panel.offsetHeight;

    // Adjust network layout
    const controls = document.getElementById('controls');
    const myNetwork = document.getElementById('myNetwork');
    myNetwork.style.marginRight = '300px';
    myNetwork.style.marginLeft = controls.classList.contains('collapsed') ? '50px' : '300px';

    console.log('Properties panel should now be visible on the right');
    network.fit({ animation: { duration: 300, easingFunction: 'easeInOutQuad' } });
}

function hidePropertiesPanel() {
    const panel = document.getElementById('properties-panel');
    if (!panel) return;

    panel.classList.remove('active');

    // Reset layout
    const controls = document.getElementById('controls');
    const myNetwork = document.getElementById('myNetwork');
    myNetwork.style.marginRight = '0';
    myNetwork.style.marginLeft = controls.classList.contains('collapsed') ? '50px' : '300px';

    // Optional: Hide panel after transition to avoid flicker
    panel.addEventListener('transitionend', function handler() {
        if (!panel.classList.contains('active')) {
            panel.style.display = 'none';
        }
        panel.removeEventListener('transitionend', handler);
    });

    network.fit({ animation: { duration: 300, easingFunction: 'easeInOutQuad' } });
}

// Ensure toggleMenu aligns with right-side panel
function toggleMenu() {
    const controls = document.getElementById('controls');
    const menuToggle = document.getElementById('menu-toggle');
    const propertiesPanel = document.getElementById('properties-panel');
    const myNetwork = document.getElementById('myNetwork');
    
    controls.classList.toggle('collapsed');
    
    if (controls.classList.contains('collapsed')) {
        menuToggle.textContent = '>'; 
        menuToggle.style.transform = 'rotate(0deg)';
        myNetwork.style.marginLeft = '50px';
    } else {
        menuToggle.textContent = '<'; 
        menuToggle.style.transform = 'rotate(0deg)';
        myNetwork.style.marginLeft = '300px';
    }

    myNetwork.style.marginRight = propertiesPanel.classList.contains('active') ? '300px' : '0';
    
    network.fit({
        animation: { duration: 300, easingFunction: 'easeInOutQuad' }
    });
}

// Update window resize handler
window.addEventListener('resize', () => {
    const propertiesPanel = document.getElementById('properties-panel');
    const controls = document.getElementById('controls');
    const myNetwork = document.getElementById('myNetwork');
    
    if (propertiesPanel.classList.contains('active')) {
        myNetwork.style.marginRight = '300px';
    } else {
        myNetwork.style.marginRight = '0';
    }
    myNetwork.style.marginLeft = controls.classList.contains('collapsed') ? '50px' : '300px';
});

// Add this at the end of the script section
window.addEventListener('beforeunload', function() {
    try {
        saveState();
    } catch (e) {
        console.error('Before unload save failed:', e);
    }
});

    </script>
</body>
</html>
